

#def square(T x) T : x * x

#decl map(function<T1, T2>, array<T1>) array<T2>



def sum(array<float> x) float :
	fold(\(float y, float s) float : y + s, x, 0.0)


def addOneToElements(array<float> x) array<float> :
	map(\(float y) float : (y + 1.0), x)





def main() float :
	sum([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0])


#struct Complex
#{
#	float re,
#	float im
#}

#def complexFunc() Complex :
#	Complex(1.0, 2.0)
	
	
#def add (Complex a, Complex b) Complex : 
#	Complex(re(a) + re(b), im(a) + im(b))


#def funcWithLambdaArg(function<int, int> f, int x) int :
#	f(f(x))
	

#def stringFunc() string :
#	"bleh"

#def funcThatReturnsLambda() function<int> :
#	\() int : 10

#def main() float :
#	im(add(Complex(1.0, 4.0), Complex(10.0, 100.0)))
	
	
	
	
	#let z = \(int a) int : a + 1
	#funcWithLambdaArg(z, 3)
	




#def lambdaTest(int x) int :
#	let z = \(int a) int : a + 3
#	z(x)


#def test


#1 + 1 == 3 # comment
#dsfg


#def operator_add(complex x, complex y) complex : complex(re(x) + re(y), im(x) + im(y))



#c + d




#def e() map<int, int> : { g(1, 3) : e() , 666:777}

#def f(int x) int : 3 * x

#def g(int x, int y) int : x + x * x
#def h(int x, int y) int : (x + x) * x
#def i(int x, int y) int : x - x * x

#def g(float x, float y) float : x + y


#def square(int x) int : 
#	let y = f(x)
#	x*y



