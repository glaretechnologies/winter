Copyright 2009- Nicholas Chapman


Helpful things todo:
====================
Allow lets anywhere, particularly inside if statements.

Allow optional type declarations for let statements


Type Coercion
=============
Integer -> Float
----------------
This should be done iff the integer can be exactly represented by the float.
This should also only be done for constant expressions (not function calls etc..).  Otherwise it will be impossible to check
that the result is exactly convertible as an integer.

Integer to float promotion in arithmetical expressions:
1 + 2.0   =>  1.0 + 2.0

Promotion to match function return type:

def f() float : 1

Promotion to match required arguments for function expression:

def f(float a, float b)

f(1, 2) =>  f(1.0, 2.0)

iff there are no other functions such as f(float, int), or f(int, int) etc.., e.g. as long as the overloading 
is not ambiguous.


Float -> Int
------------
Since floats can rarely be represented exactly as ints, and truncation may not be the desired behaviour for negative numbers,
type coercion of this kind should *not* be done.



Passing structures by value
===========================
"It's a frontend task to lower the code to follow the vendor ABI."
...
"The calling convention can be complex 
enough and operate with the language-dependent definitions (e.g. "C" 
structs, etc.), thus frontend should lower such constructs as needed."
-Anton

From http://old.nabble.com/Passing-structures-by-value-on-Windows-td28766193.html




Expression type depends on:

Return type of function expressions:

e.g.  f(1) depends on return type of f.

But that in turn depends on what f is bound to.


Binding of variables is by name only and so has no dependencies.

Binding of function expressions depends on type of argument subtrees, also on type of variable
expressions.









LLVMAnalysis.lib LLVMArchive.lib LLVMAsmParser.lib LLVMAsmPrinter.lib LLVMBitReader.lib LLVMBitWriter.lib LLVMCodeGen.lib LLVMCore.lib LLVMDebugger.lib LLVMExecutionEngine.lib LLVMHello.lib LLVMInstrumentation.lib LLVMInterpreter.lib LLVMipa.lib LLVMipo.lib LLVMJIT.lib LLVMLinker.lib LLVMScalarOpts.lib LLVMSelectionDAG.lib LLVMSupport.lib LLVMSystem.lib LLVMTarget.lib LLVMTransformUtils.lib LLVMX86AsmPrinter.lib LLVMX86CodeGen.lib

Runtime system
--------------


Build up LLVM code structure
compile whole thing using LLVM
Start worker threads
Make first work unit
Assign it to a worker thread work queue
wait until all worker threads are finished.
done.


Stages:

Lexing Stage
------------
Read text buffers, convert to token lists.

Parsing Stage
-------------
Convert token lists to abstract syntax trees


Type checking stage
-------------------


Object Layout stage
------------------------
Generate memory layouts for all structures

LLVM tree construction stage
-------------------
Generate LLVM tree structure corresponding to AST


LLVM codegen stage
------------------
Get LLVM to JIT compile all its stuff in tree structures


Create VM
------------
Get the VM ready to run, i.e. create worker threads

Get entry point function
------------------------
Get pointer to entry point function, e.g. main() or some other function

Make a call into that from client code
Control tranfers to VM.
VM creates work unit, puts on queue of worker thread
worker thread executes
worker thread sends done message back to VM
Vm returns control back to client code.







Type Memory Layout
------------------
Directly embedded types:  must have fixed size known at compile time
byte, ubyte, int, uint, float, double, 
tuple<T0, T1, .. TN> (as long as types Ti are all directly embedded types)
tuple<T, N> (as long as type T is directly embedded)

Otherwise, alloc in heap and store pointer to the object,
e.g. for tuple<string, string>:

{
	String* a;
	String* b;
}


class TypeLayout
{
}

class BasicTypeLayout
{
	Type* value;
}

class FieldPosition
{
	int offset; // in bytes
	bool pointer;
	Type* value;
}

class CompositeTypeLayout : TypeLayout
{
	std::vector<FieldPosition> contents;
}




class Value
{
	





Primitive Types			Description											Literal Syntax example
----------------------------------------------------------------------------------------------------

byte					8 bit signed integer								8b
ubyte					8 bit unsigned integer								8ub
int						32 bit signed integer								8	
uint					32 bit unsigned integer								8u
float					32 bit float										8.0f
double					64 bit float										8.0
string					Unicode string (utf-8?)								"bleh"
tuple<T0, T1, .. TN>	Ordered pair of types T0, T1, .. , TN	(struct?)	[8, "hello"]t
ntuple<T, n>			Where n is an integer literal.						[1, 2, 3, 4]t
map<T0, T1>				Map from T0 to T1									{8, "bleh"}
list<T>					Variable length list of 0 or more T's (std::vector)	[1, 2, 3, 4]
flist<T, n>				List of known length: n								[1, 2, 3, 4]f
array<T>				Variable length list of 0 or more T's (std::vector)	[1, 2, 3, 4]
function<T0, T1, ..., TN, R>	Function from T0, T1, T2, .. , TN to R		\(int a, int b)(a + 4*b)

vector<T, n>																[1, 2, 3, 4]v

Miscellaneous syntax
-----------------------------
Function Application			f(a, b)

Function Definition				def f(int a, int b) int : a + b

Let								let z = f(1, 2)




Structures
=================================================================

Structure Type Definition			
----------------------------
struct Complex
{
	float re,
	float im
}

Implicitly defines functions
Complex(float re, float im) Complex
re(Complex c) float
im(Complex c) float


Constructing a Structure value
------------------------------
z = Complex(1.0, 2.0)

Accessing Structure Members
---------------------------
z = Complex(1.0, 2.0)
zr = re(z)

With syntactic sugar:
zr = z.re

Operator overloading:
def + (Complex a, Complex b) Complex : Complex(a.re + b.re, a.im + b.im)
or
def add(Complex a, Complex b) Complex : Complex(a.re + b.re, a.im + b.im)
?

Using the structure type
------------------------
def norm(Complex a) Real : a.re*a.re + a.im*a.im

Syntactic sugar for method calls on structures:
------------------------------------------------
z = Complex(1.0, 2.0)

z.norm() is equivalent to norm(z)

? Have z.norm as syntactic sugar for z.norm() ?


Vectors
--------------------------
type: vector<T, n>				[n must be even]

Constructing a vector with vector literals
--------------------------
[1.0, 2.0, 3.0, 4.0]v   constructs a vector<float, 4>

Accessing a vector element
---------------------------
let x = [1.0, 2.0, 3.0, 4.0]v
e0(x) returns the 0th element
e1(x) returns the 1st element
etc...





Operators
*
/
+
-




module AModule
import AModule






Examples:

tuple(int, byte)

list<int>

list<function<int, string>>


Special Types
------------
tuple<float, float, float, float> : treated as SIMD 4-vector
tuple<double, double> : treated as SIMD 2-vector




Primitive Functions
-------------------
These are elementary functions that will be provided by the lanuage runtime / are part of the lanuage core.

Higher order primitive functions
--------------------------------
map(function<T, R>, list<T>) -> list<R>
fold(function<I, T, I> func, list<T>, I initial_val) -> I
zip(function<A, B, R>, list<A>, list<B>) -> list<R>



intToFloat(int i) -> float
intToDouble(int i) -> double


dot(vec<float, n>, vec<float, n>) -> float

add(vec<float, n>, vec<float, n>) -> vec<float, n>   [ Use LLVM IR op ]
sub(vec<float, n>, vec<float, n>) -> vec<float, n>   [ Use LLVM IR op ]

mul(vec<float, n>, float) -> vec<float, n>






Examples
--------


Apply sqrt to each element in an array of 100 elements

# Type declaration
sqrtArray<tuple<float, 100>, tuple<float, 100>>

# Function definition
def sqrtArray(list<T> a) -> list<T>
	map(Maths.sqrt, a)


sqrtArray(Tuple<T, n> a) -> Tuple<T, n>
	map(a, Maths.sqrt))
	
	
Gets mapped to something like
	result = alloc Tuple<float, 100> from program runtime heap
	for(0 to 99)
		result[i] = sqrt(a[i]);
		
		
		
List Literal
------------
[1, 2, 3]

Makes a list of type list<int>

Struct Literal
--------------
{ 1, "hello", true }

Makes a list of type struct<int, string, bool>

Nested struct literal:
{ 1, "hello", { "something, true} }

Map Literal
-----------
{ 1:"hello", 2 : "goodbye" }

Makes a map of type map<int, string>		


Anonymous function literals:
----------------------------

def doSomethingCoolToArray(list<T> a) -> list<T>
	map(a, lambda(T a) { a * Maths.sqrt(a) })




let add3 = lambda(int x) -> x

def addN(int n) -> int :
	lambda(int x) { x + n }



Classes
---------		


Type




ByteCode
--------
def add3(int x) -> int : x + 3

copy 0th arg from argument stack to working stack
push 3 onto the working stack
call operator +
pop result from working stack into return register





NodeIterator
{
	parentstack
	current
	vector<int> current_child_index
	
	stack to_process
}

NodeIterator::advance()
{
	if(to_process.empty())
		done = true
	else
	{
		current = to_process.back().node
		parentstack.resize(to_process.back().depth)
		to_process.pop_back()
		
		for each child of current
			to_process.push_back(child, depth+1)
	}
}


for(NodeIterator it(buffer_root); it.valid(); it.advance())
{
	it.current()->link(linker);
}


	// We have finished with current.
	
	// Process any children of current
	children = current.children
	if(children.size() > 0)
	{
		// Traverse to first child of current
		current_child_index.push_back(0)
		current = current.children[0]
	}
	
	// Else no children for current node.
	
	// Walk up to parent
	while(1)
	{
		current = parentstack.back()
		parentstack.pop_back()
	
		// are there any more children of the parent?
		if 
	
}




vector<ASTNode*> stack(1, bufferroot);

while(1)
{
	children = getChildren(n)
	
	add n to parent stack
	
	for each child in children:

