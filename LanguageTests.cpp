//
// Generated by makeclass.rb on Sun Oct 04 15:08:43 +1300 2009.
// Copyright Nicholas Chapman.
//
#include "LanguageTests.h"


#include <iostream>
#include <cassert>
#include <fstream>
#include "utils/FileUtils.h"
#include "Lexer.h"
#include "TokenBase.h"
#include "LangParser.h"
#include "ASTNode.h"
#include "VMState.h"
#include "Linker.h"
#include "Value.h"
#include "VirtualMachine.h"


namespace Winter
{


LanguageTests::LanguageTests()
{}


LanguageTests::~LanguageTests()
{}


typedef float(*float_void_func)();


static void testMainFloat(const std::string& src, float target_return_val)
{
	std::cout << "============================== testMainFloat() ============================" << std::endl;
	try
	{
		/*std::vector<Reference<TokenBase> > tokens;
		Lexer::process(src, tokens);

		LangParser parser;
		ASTNodeRef rootref = parser.parseBuffer(tokens, src.c_str());


		BufferRoot* root = dynamic_cast<BufferRoot*>(rootref.getPointer());

		// Bind variables
		{
			std::vector<ASTNode*> stack;
			TraversalPayload payload(TraversalPayload::BindVariables);
			root->traverse(payload, stack);
			assert(stack.size() == 0);
		}

		// Link functions
		Linker linker;
		linker.addFunctions(*root);
		{
			std::vector<ASTNode*> stack;
			TraversalPayload payload(TraversalPayload::LinkFunctions);
			payload.linker = &linker;
			root->traverse(payload, stack);
			assert(stack.size() == 0);
		}

		// TypeCheck.
		// At this point, all variables and function expressions should be bound.
		{
			std::vector<ASTNode*> stack;
			TraversalPayload payload(TraversalPayload::TypeCheck);
			root->traverse(payload, stack);
			assert(stack.size() == 0);
		}


		std::cout << "------------------------\n";
		rootref->print(0, std::cout);
		std::cout << "----Concrete funcs:----\n";
		for(size_t i=0; i<linker.concrete_funcs.size(); ++i)
			linker.concrete_funcs[i]->print(0, std::cout);
		std::cout << "------------------------\n";


		// Get main function
		FunctionSignature mainsig("main", std::vector<TypeRef>());
		Reference<FunctionDefinition> maindef = linker.findMatchingFunction(mainsig);

		if(maindef.isNull())
		{
			std::cerr << "Failed to find main()" << std::endl;
			exit(1);
		}*/

		VirtualMachine vm;
		vm.loadSource(src);

		// Get main function
		FunctionSignature mainsig("main", std::vector<TypeRef>());
		Reference<FunctionDefinition> maindef = vm.findMatchingFunction(mainsig);

		void* f = vm.getJittedFunction(mainsig);

		// cast to correct type
		float_void_func mainf = (float_void_func)f;

		// Call the JIT'd function
		const float jitted_result = mainf();


		// Check JIT'd result.
		if(jitted_result != target_return_val)
		{
			std::cerr << "Test failed: JIT'd main returned " << jitted_result << ", target was " << target_return_val << std::endl;
			exit(1);
		}



		VMState vmstate;
		vmstate.func_args_start.push_back(0);

		Value* retval = maindef->invoke(vmstate);

		vmstate.func_args_start.pop_back();
		FloatValue* val = dynamic_cast<FloatValue*>(retval);
		if(!val)
		{
			std::cerr << "main() Return value was of unexpected type." << std::endl;
			exit(1);
		}

		if(val->value != target_return_val)
		{
			std::cerr << "Test failed: main returned " << val->value << ", target was " << target_return_val << std::endl;
			exit(1);
		}

		delete retval;

	}
	catch(Winter::BaseException& e)
	{
		std::cerr << e.what() << std::endl;
		exit(1);
	}
	catch(Winter::LexerExcep& e)
	{
		std::cerr << e.what() << std::endl;
		exit(1);
	}
	catch(Winter::LangParserExcep& e)
	{
		std::cerr << e.what() << std::endl;
		exit(1);
	}
}


void LanguageTests::run()
{
	// Simple test
	testMainFloat("def main() float : 1.0", 1.0);

	// Test addition expression
	testMainFloat("def main() float : 1.0 + 2.0", 3.0);

	// Test multiplication expression
	testMainFloat("def main() float : 3.0 * 2.0", 6.0);

	// Test simple function call
	testMainFloat("def f(float x) float : x        def main() float : f(3.0)", 3.0);

	// Test function call with two parameters
	testMainFloat("def f(float x, float y) float : x        def main() float : f(3.0, 4.0)", 3.0);
	testMainFloat("def f(float x, float y) float : y        def main() float : f(3.0, 4.0)", 4.0);

	// Test inferred return type (for f)
	testMainFloat("def f(float x) : x        def main() float : f(3.0)", 3.0);

	// Test two call levels of inferred return type (f, g)
	testMainFloat("def f(float x) : g(x)    def g(float x) : x    def main() float : f(3.0)", 3.0);
	testMainFloat("def f(float x) : x    def g(float x) : f(x)    def main() float : g(3.0)", 3.0);

	// Test generic function
	testMainFloat("def f<T>(T x) T : x        def main() float : f(2.0)", 2.0);

	// Test generic function with inferred return type (f)
	testMainFloat("def f<T>(T x) : x        def main() float : f(2.0)", 2.0);

	// Test function overloading - call with int param, should select 1st overload
	testMainFloat("def overloadedFunc(int x) float : 4.0 \
				  def overloadedFunc(float x) float : 5.0 \
				  def main() float: overloadedFunc(1)", 4.0f);

	// Call with float param, should select 2nd overload.
	testMainFloat("def overloadedFunc(int x) float : 4.0 \
				  def overloadedFunc(float x) float : 5.0 \
				  def main() float: overloadedFunc(1.0)", 5.0f);

	// Test binding to different overloaded functions based on type parameter to generic function
	testMainFloat("def overloadedFunc(int x) float : 4.0 \
				  def overloadedFunc(float x) float : 5.0 \
				  def f<T>(T x) float: overloadedFunc(x)\
				  def main() float : f(1)", 4.0f);
	// Call f with float param
	testMainFloat("def overloadedFunc(int x) float : 4.0 \
				  def overloadedFunc(float x) float : 5.0 \
				  def f<T>(T x) float: overloadedFunc(x)\
				  def main() float : f(1.0)", 5.0f);

	// Test let
	testMainFloat("def f(float x) float : \
				  let z = 2.0 \
				  z \
				  def main() float : f(0.0)", 2.0);

	// Test two let clauses
	testMainFloat("def f(float x) float : \
				  let z = 2.0 \
				  let y = 3.0 \
				  y \
				  def main() float : f(0.0)", 3.0);

	// Test Lambda in let
	//Doesn't work with LLVM
	//testMainFloat("def main() float : let f = \\(float x) : x        f(2.0)", 2.0f);

	// Test addition expression in let
	testMainFloat("def f(float x) float : \
				  let z = 2.0 + 3.0 \
				  z \
				  def main() float : f(0.0)", 5.0);

	// Test function expression in let
	testMainFloat("	def g(float x) float : x + 1.0 \
					def f(float x) float : \
					let z = g(1.0) \
					z \
					def main() float : f(0.0)", 2.0);

	// Test function argument in let
	testMainFloat("	def f(float x) float : \
					let z = x + 1.0 \
					z \
					def main() float : f(2.0)", 3.0);

	// Test struct
	testMainFloat("struct Complex { float re, float im } \
				  def main() float : re(Complex(2.0, 3.0))", 2.0f);


	// Test vector
	testMainFloat("	def main() float : \
					let x = [1.0, 2.0, 3.0, 4.0]v \
					e0(x)", 1.0f);
	testMainFloat("	def main() float : \
					let x = [1.0, 2.0, 3.0, 4.0]v \
					e1(x)", 2.0f);

	// Test vector being returned from a function
	testMainFloat("	def f() vector<float, 4> : [1.0, 2.0, 3.0, 4.0]v \
					def main() float : e2(f())", 3.0f);


	std::cout << "===================All LanguageTests passed.=============================" << std::endl;
}


}
