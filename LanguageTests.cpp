//
// Generated by makeclass.rb on Sun Oct 04 15:08:43 +1300 2009.
// Copyright Nicholas Chapman.
//
#include "LanguageTests.h"


#include <maths/sse.h>

#include <iostream>
#include <cassert>
#include <fstream>
#include "utils/FileUtils.h"
#include "Lexer.h"
#include "TokenBase.h"
#include "LangParser.h"
#include "ASTNode.h"
#include "VMState.h"
#include "Linker.h"
#include "Value.h"
#include "VirtualMachine.h"


namespace Winter
{


LanguageTests::LanguageTests()
{}


LanguageTests::~LanguageTests()
{}


typedef float(*float_void_func)();


static void testMainFloat(const std::string& src, float target_return_val)
{
	std::cout << "============================== testMainFloat() ============================" << std::endl;
	try
	{
		VirtualMachine vm;
		vm.loadSource(src);

		// Get main function
		FunctionSignature mainsig("main", std::vector<TypeRef>());
		Reference<FunctionDefinition> maindef = vm.findMatchingFunction(mainsig);

		void* f = vm.getJittedFunction(mainsig);

		// cast to correct type
		float_void_func mainf = (float_void_func)f;

		// Call the JIT'd function
		const float jitted_result = mainf();


		// Check JIT'd result.
		if(jitted_result != target_return_val)
		{
			std::cerr << "Test failed: JIT'd main returned " << jitted_result << ", target was " << target_return_val << std::endl;
			exit(1);
		}

		VMState vmstate;
		vmstate.func_args_start.push_back(0);

		Value* retval = maindef->invoke(vmstate);

		vmstate.func_args_start.pop_back();
		FloatValue* val = dynamic_cast<FloatValue*>(retval);
		if(!val)
		{
			std::cerr << "main() Return value was of unexpected type." << std::endl;
			exit(1);
		}

		if(val->value != target_return_val)
		{
			std::cerr << "Test failed: main returned " << val->value << ", target was " << target_return_val << std::endl;
			exit(1);
		}

		delete retval;

	}
	catch(Winter::BaseException& e)
	{
		std::cerr << e.what() << std::endl;
		exit(1);
	}
	catch(Winter::LexerExcep& e)
	{
		std::cerr << e.what() << std::endl;
		exit(1);
	}
	catch(Winter::LangParserExcep& e)
	{
		std::cerr << e.what() << std::endl;
		exit(1);
	}
}


//typedef float(*float_void_func)();



#define WINTER_JIT_CALLING_CONV __cdecl


template <class StructType>
static void bleh(StructType* s)
{
	s->a = 1;
}


template <class StructType>
static void testMainStruct(const std::string& src, const StructType& target_return_val)
{
	std::cout << "============================== testMainStruct() ============================" << std::endl;
	try
	{
		VirtualMachine vm;
		vm.loadSource(src);

		// Get main function
		FunctionSignature mainsig("main", std::vector<TypeRef>());
		Reference<FunctionDefinition> maindef = vm.findMatchingFunction(mainsig);

		
		// __cdecl
		void (WINTER_JIT_CALLING_CONV *f)(StructType*) = (void (WINTER_JIT_CALLING_CONV *)(StructType*))vm.getJittedFunction(mainsig);

		// Call the JIT'd function
		SSE_ALIGN StructType jitted_result;

		bleh(&jitted_result);

		f(&jitted_result);

		/*std::cout << "============================" << std::endl;
		std::cout << jitted_result.a << std::endl;
		std::cout << jitted_result.b << std::endl;
		std::cout << jitted_result.c << std::endl;
		std::cout << jitted_result.d << std::endl;*/

		// Check JIT'd result.
		if(!(jitted_result == target_return_val))
		{
			std::cerr << "Test failed: jitted_result != target_return_val  " << std::endl;
			exit(1);
		}

		/*VMState vmstate;
		vmstate.func_args_start.push_back(0);

		Value* retval = maindef->invoke(vmstate);

		vmstate.func_args_start.pop_back();
		StructureValue* val = dynamic_cast<StructureValue*>(retval);
		if(!val)
		{
			std::cerr << "main() Return value was of unexpected type." << std::endl;
			exit(1);
		}*/


		/*if(val->value != target_return_val)
		{
			std::cerr << "Test failed: main returned " << val->value << ", target was " << target_return_val << std::endl;
			exit(1);
		}*/

		//delete retval;

	}
	catch(Winter::BaseException& e)
	{
		std::cerr << e.what() << std::endl;
		exit(1);
	}
	catch(Winter::LexerExcep& e)
	{
		std::cerr << e.what() << std::endl;
		exit(1);
	}
	catch(Winter::LangParserExcep& e)
	{
		std::cerr << e.what() << std::endl;
		exit(1);
	}
}


template <class InStructType, class OutStructType>
static void testMainStructInputAndOutput(const std::string& src, const InStructType& struct_in, const OutStructType& target_return_val)
{
	std::cout << "============================== testMainStructInputAndOutput() ============================" << std::endl;
	try
	{
		VirtualMachine vm;
		vm.loadSource(src);

		vector<string> field_names;
		field_names.push_back("x");
		field_names.push_back("y");

		// Get main function
		FunctionSignature mainsig(
			"main", 
			std::vector<TypeRef>(1, TypeRef(new StructureType(
				"TestStructIn", 
				std::vector<TypeRef>(2, TypeRef(new Float)), 
				field_names
			)))
		);
		Reference<FunctionDefinition> maindef = vm.findMatchingFunction(mainsig);


		// __cdecl
		void (WINTER_JIT_CALLING_CONV *f)(OutStructType*, InStructType*) = (void (WINTER_JIT_CALLING_CONV *)(OutStructType*, InStructType*))vm.getJittedFunction(mainsig);

		// Call the JIT'd function
		SSE_ALIGN OutStructType jitted_result;

		SSE_ALIGN InStructType aligned_struct_in = struct_in;

		f(&jitted_result, &aligned_struct_in);

		// Check JIT'd result.
		if(!(jitted_result == target_return_val))
		{
			std::cerr << "Test failed: jitted_result != target_return_val  " << std::endl;
			exit(1);
		}

		/*VMState vmstate;
		vmstate.func_args_start.push_back(0);

		Value* retval = maindef->invoke(vmstate);

		vmstate.func_args_start.pop_back();
		StructureValue* val = dynamic_cast<StructureValue*>(retval);
		if(!val)
		{
		std::cerr << "main() Return value was of unexpected type." << std::endl;
		exit(1);
		}*/


		/*if(val->value != target_return_val)
		{
		std::cerr << "Test failed: main returned " << val->value << ", target was " << target_return_val << std::endl;
		exit(1);
		}*/

		//delete retval;

	}
	catch(Winter::BaseException& e)
	{
		std::cerr << e.what() << std::endl;
		exit(1);
	}
	catch(Winter::LexerExcep& e)
	{
		std::cerr << e.what() << std::endl;
		exit(1);
	}
	catch(Winter::LangParserExcep& e)
	{
		std::cerr << e.what() << std::endl;
		exit(1);
	}
}


void LanguageTests::run()
{
	// Simple test
	testMainFloat("def main() float : 1.0", 1.0);

	// Test addition expression
	testMainFloat("def main() float : 1.0 + 2.0", 3.0);

	// Test multiplication expression
	testMainFloat("def main() float : 3.0 * 2.0", 6.0);

	// Test simple function call
	testMainFloat("def f(float x) float : x        def main() float : f(3.0)", 3.0);

	// Test function call with two parameters
	testMainFloat("def f(float x, float y) float : x        def main() float : f(3.0, 4.0)", 3.0);
	testMainFloat("def f(float x, float y) float : y        def main() float : f(3.0, 4.0)", 4.0);

	// Test inferred return type (for f)
	testMainFloat("def f(float x) : x        def main() float : f(3.0)", 3.0);

	// Test two call levels of inferred return type (f, g)
	testMainFloat("def f(float x) : g(x)    def g(float x) : x    def main() float : f(3.0)", 3.0);
	testMainFloat("def f(float x) : x    def g(float x) : f(x)    def main() float : g(3.0)", 3.0);

	// Test generic function
	testMainFloat("def f<T>(T x) T : x        def main() float : f(2.0)", 2.0);

	// Test generic function with inferred return type (f)
	testMainFloat("def f<T>(T x) : x        def main() float : f(2.0)", 2.0);

	// Test function overloading - call with int param, should select 1st overload
	testMainFloat("def overloadedFunc(int x) float : 4.0 \
				  def overloadedFunc(float x) float : 5.0 \
				  def main() float: overloadedFunc(1)", 4.0f);

	// Call with float param, should select 2nd overload.
	testMainFloat("def overloadedFunc(int x) float : 4.0 \
				  def overloadedFunc(float x) float : 5.0 \
				  def main() float: overloadedFunc(1.0)", 5.0f);

	// Test binding to different overloaded functions based on type parameter to generic function
	testMainFloat("def overloadedFunc(int x) float : 4.0 \
				  def overloadedFunc(float x) float : 5.0 \
				  def f<T>(T x) float: overloadedFunc(x)\
				  def main() float : f(1)", 4.0f);
	// Call f with float param
	testMainFloat("def overloadedFunc(int x) float : 4.0 \
				  def overloadedFunc(float x) float : 5.0 \
				  def f<T>(T x) float: overloadedFunc(x)\
				  def main() float : f(1.0)", 5.0f);

	// Test let
	testMainFloat("def f(float x) float : \
				  let z = 2.0 \
				  z \
				  def main() float : f(0.0)", 2.0);

	// Test two let clauses
	testMainFloat("def f(float x) float : \
				  let z = 2.0 \
				  let y = 3.0 \
				  y \
				  def main() float : f(0.0)", 3.0);

	// Test Lambda in let
	//Doesn't work with LLVM
	//testMainFloat("def main() float : let f = \\(float x) : x        f(2.0)", 2.0f);

	// Test addition expression in let
	testMainFloat("def f(float x) float : \
				  let z = 2.0 + 3.0 \
				  z \
				  def main() float : f(0.0)", 5.0);

	// Test function expression in let
	testMainFloat("	def g(float x) float : x + 1.0 \
					def f(float x) float : \
					let z = g(1.0) \
					z \
					def main() float : f(0.0)", 2.0);

	// Test function argument in let
	testMainFloat("	def f(float x) float : \
					let z = x + 1.0 \
					z \
					def main() float : f(2.0)", 3.0);

	// Test struct
	testMainFloat("struct Complex { float re, float im } \
				  def main() float : re(Complex(2.0, 3.0))", 2.0f);
	
	testMainFloat("struct Complex { float re, float im } \
 				  def main() float : im(Complex(2.0, 3.0))", 3.0f);


	// Test vector
	testMainFloat("	def main() float : \
					let x = [1.0, 2.0, 3.0, 4.0]v \
					e0(x)", 1.0f);
	testMainFloat("	def main() float : \
					let x = [1.0, 2.0, 3.0, 4.0]v \
					e1(x)", 2.0f);

	// Test vector being returned from a function
	testMainFloat("	def f() vector<float, 4> : [1.0, 2.0, 3.0, 4.0]v \
					def main() float : e2(f())", 3.0f);


	// Test structures
	{
		struct TestStruct
		{
			float a;
			float b;
			float c;
			float d;

			bool operator == (const TestStruct& other) const { return (a == other.a) && (b == other.b); }
		};

		TestStruct target_result;
		target_result.a = 1;
		target_result.b = 2;
		target_result.c = 3;
		target_result.d = 4;
		testMainStruct<TestStruct>("struct TestStruct { float a, float b, float c, float d } \
								   def main() TestStruct : TestStruct(1.0, 2.0, 3.0, 4.0)", target_result);

		testMainStruct<TestStruct>("struct TestStruct { float a, float b, float c, float d } \
								   def main() TestStruct : TestStruct(1.0, 2.0, 3.0, 4.0)", target_result);

	}
	{
		struct TestStruct
		{
			float a;
			float b;
			float c;
			float d;

			bool operator == (const TestStruct& other) const { return (a == other.a) && (b == other.b); }
		};

		TestStruct target_result;
		target_result.a = 5;
		target_result.b = 6;
		target_result.c = 3;
		target_result.d = 4;

		struct TestStructIn
		{
			float x;
			float y;
		};

		TestStructIn in;
		in.x = 5;
		in.y = 6;

		testMainStructInputAndOutput("struct TestStruct { float a, float b, float c, float d } \
									 struct TestStructIn { float x, float y } \
									 def main(TestStructIn in) TestStruct : TestStruct(x(in), y(in), 3.0, 4.0)", in, target_result);
	}


	std::cout << "===================All LanguageTests passed.=============================" << std::endl;
}


}
