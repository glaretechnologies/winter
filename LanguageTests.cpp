//
// Generated by makeclass.rb on Sun Oct 04 15:08:43 +1300 2009.
// Copyright Nicholas Chapman.
//
#include "LanguageTests.h"


#include "LanguageTestUtils.h"
#include "FuzzTests.h"
#include "wnt_ArrayLiteral.h"
#include "wnt_VectorLiteral.h"
#include "wnt_TupleLiteral.h"
#include "wnt_IfExpression.h"
#include "wnt_FunctionExpression.h"
#include <utils/Timer.h>
#include <utils/MTwister.h>
#include <utils/Task.h>
#include <utils/TaskManager.h>
#include <utils/MemMappedFile.h>
#include <utils/FileUtils.h>
#include <unordered_set>


#if BUILD_TESTS


namespace Winter
{


LanguageTests::LanguageTests()
{}


LanguageTests::~LanguageTests()
{}


#define testAssert(expr) (doTestAssert((expr), (#expr), (__LINE__), (__FILE__)))
void doTestAssert(bool expr, const char* test, long line, const char* file)
{
	if(!expr)
	{
		std::cerr << std::string("Test assertion failed: " + std::string(file) + ", line " + toString((int)line) + ":\n" + std::string(test)) << std::endl;
		exit(1);
	}
}

/*

def main(int x) int : 
	if x < 5 then
		10 
	else
		20

def main(int x) int : 
	if x < 5
		10 
	else
		20

def main(int x) int : if x < 5 then 10 else	20

def main(int x) int : if (x < 5) then 10 else 20
def main(int x) int : if (x < 5) then 10 else 20

def main(int x) int : if (x < 5, 10, 20)

parse 'if ('
parse expression 'x < 5'
if next token == ')', then it's if-then-else.
if next token == ',', then it's if(,,)
*/

/*
static Value* identity(Value* v)
{
	return v;
}


static Value* h(Value* v, float x)
{
	if(x < 0.5)
	{
		Value* ret = new IntValue(99);
		ret->incRefCount(); // Set ref count to 1
		return ret;
	}
	else
		return v;
}


static int length(Value* v)
{
	return v->toString().size();
}

// no ref counting on v done in function
static int f(Value* v)
{
	return f(v);
}



static int bleh(float x)
{
	Value* v = new IntValue(99);
	v->incRefCount(); // Set v ref count to 1

	Value* v2 = h(v, x); // If we don't know how h is defined, then we may have v2 = v, or we may have v2 = new value
	// If it just returned v, we have one allocation in total.  Otherwise we have two.  
	// There is no way of knowing at compile time.

	const int len = length(v2);

	delete v;
}


static int meh()
{
	Value* v = new IntValue(99);
	v->incRefCount(); // Set v ref count to 1

	const int len = length(v);

	delete v; // No ref count check required. Still need to delete though
}


// Function meh2 akes a ref-counted value, no reference counting code required for the argument though, as doesn't return a value of the same type.
static int meh2(Value* v)
{
	const int len = length(v);
	return len + 2;
}


// Can do another optimisation:  Since meh3 doesn't take a Value as argument, we know that the return value must have refcount = 1.
static Value* meh3(int x)
{
	Value* v = new IntValue(99);
	v->incRefCount(); // Set v ref count to 1
	return v;
}


// So take something like:
static int useKnownReturnRefCountOptimsiation(int x)
{
	Value* v = meh3(x);
	// We know rc(v) = 1
	const int len = length(v);
	// We still know rc(v) = 1

	// At this point we can just delete v;
	assert(v->getRefCount() == 1);
	v->decRefCount();
	delete v;

	return len + 2;
}*/


void LanguageTests::doLLVMInit()
{
	testMainFloatArg("def main(float x) float : sqrt(4)", 2.0f, 2.0f);
}


static const bool DO_OPENCL_TESTS = false;


void LanguageTests::run()
{
	//TEMP///////////////
	
	//useKnownReturnRefCountOptimsiation(3);


	//////////////////


	Timer timer;

	const TypeRef ta = new Int();
	const TypeRef tb = new Int();

	//assert(ta == tb);
	//assert(!(ta < tb));
	//assert(!(tb < ta));

	std::set<TypeRef, TypeRefLessThan> type_set;
	type_set.insert(ta);
	type_set.insert(tb);
	assert(type_set.size() == 1);

	//testMainFloatArgInvalidProgram("struct s { s a, s b } def main(float x) float : x");
	//testMainFloatArgInvalidProgram("def main(float x) float : let varray<T> v = [v]va in x");
	
	// ===================================================================
	// 
	// ===================================================================
	//testMainFloatArgAllowUnsafe("def main(float x) float : let A = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]a   i = truncateToInt(x) in A[i] + A[i+1]", 2.f, 7.0f);
	//testMainFloatArgAllowUnsafe("A = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]a       def main(float x) float : let i = truncateToInt(x) in A[i] + A[i+1] + A[i+2]", 2.f, 12.0f);

	// Test map with more elems
	/*{
		const size_t N = 1 << 28;
		js::Vector<float, 32> input(N, 4.0f);
		js::Vector<float, 32> target_results(N, 16.f);//std::pow(4.0f, 2.2f));//std::sqrt(std::sqrt(std::sqrt(4.0))));


		testFloatArray(
			"def f(float x) float : pow(x, 2.2)			\n\
			def main(array<float, 268435456> a, array<float, 268435456> b) array<float, 268435456> : map(f, a)",
			&input[0], &input[0], &target_results[0], N);

		// Reference c++ code:
		{
			js::Vector<float, 32> output(N);

			

			// Warm up cache, page table etc..
			std::memcpy(&output[0], &input[0], N * sizeof(float));

			double sum1 = 0;
			for(size_t i=0; i<N; ++i)
				sum1 += output[i];

			Timer timer;

			//float sum = 0;
			//for(size_t i=0; i<N; ++i)
			//	sum += input[i];
			for(size_t i=0; i<N; ++i)
				output[i] = std::pow(input[i], 2.2f);//std::sqrt(std::sqrt(std::sqrt(input[i])));
			//std::memcpy(&output[0], &input[0], N * sizeof(float));

			const double elapsed = timer.elapsed();

			double sum = 0;
			for(size_t i=0; i<N; ++i)
				sum += output[i];

			std::cout << "C++ ref elapsed: " << (elapsed * 1.0) << " s" << std::endl;
			const double bandwidth = N * sizeof(float) / elapsed;
			std::cout << "C++ ref bandwidth: " << (bandwidth * 1.0e-9) << " GiB/s" << std::endl;
			std::cout << "sum1: " << sum << std::endl;
			std::cout << "sum: " << sum << std::endl;
		}
	}*/


	// ===================================================================
	// Test sign()
	// ===================================================================
	testMainFloatArg("def main(float x) float :	sign(x)", 4.f, 1.f);
	testMainFloatArg("def main(float x) float :	sign(x)", -4.f, -1.f);
	//NOTE: a bit of a problem wtih sign(0).  sign(0) is plus/minus zero in OpenCL.
	// but copysign(1.0, 0.f) is one.
	//testMainFloatArg("def main(float x) float :	sign(x)", 0.f, 1.f);


	testMainFloatArgAllowUnsafe("struct S { float x }   def f(S s) float : s.x   def main(float x) float :	f(S(x))", 1.f, 1.f);


	testMainIntegerArg("def main(int x) int :	 stringLength(\"hello\")", 1, 5, INVALID_OPENCL);

	// ===================================================================
	// Test optimisation of varray from heap allocated to stack allocated
	// ===================================================================
	ProgramStats stats;
	stats = testMainFloatArgAllowUnsafe("def main(float x) float :	 [3.0, 4.0, 5.0]va[0]", 1.f, 3.f, INVALID_OPENCL);
	testAssert(stats.num_heap_allocation_calls == 0);

	stats = testMainFloatArgAllowUnsafe("def main(float x) float :	 let v = [3.0, 4.0, 5.0]va in v[0]", 1.f, 3.f, INVALID_OPENCL);
	testAssert(stats.num_heap_allocation_calls == 0);

	stats = testMainFloatArgAllowUnsafe("def main(float x) float :	 let v = [3.0, 4.0, 5.0]va in v[1]", 1.f, 4.f, INVALID_OPENCL);
	testAssert(stats.num_heap_allocation_calls == 0);

	stats = testMainFloatArgAllowUnsafe("def main(float x) float :	 let v = [3.0, 4.0, 5.0]va in v[2]", 1.f, 5.f, INVALID_OPENCL);
	testAssert(stats.num_heap_allocation_calls == 0);

	stats = testMainFloatArgAllowUnsafe("def main(float x) float :	 let v = [x + 3.0, x + 4.0, x + 5.0]va in v[0]", 10.f, 13.f, INVALID_OPENCL);
	testAssert(stats.num_heap_allocation_calls == 0);

	// Test varray being returned from function, has to be heap allocated.  (Assuming no inlining of f)
	stats = testMainFloatArgAllowUnsafe("def f(float x) : [x + 3.0, x + 4.0, x + 5.0]va             def main(float x) float :	 let v = f(x) in v[0]", 10.f, 13.f, INVALID_OPENCL);
	testAssert(stats.num_heap_allocation_calls == 1);

	
	// ===================================================================
	// Test destructuring assignment
	// ===================================================================
	testMainFloatArg("def main(float x) float :	 let a, b = (x + 1.0, x + 2.0) in a", 4.f, 5.f);

	testMainFloatArg("def main(float x) float :	 let a, b = (3, 4) in a", 1.f, 3.f);
	testMainFloatArg("def main(float x) float :	 let a, b = (3, 4) in b", 1.f, 4.f);

	// Test on a tuple returned from a function
	testMainFloatArg("def f(float x) : (x + 1.0, x + 2.0)           def main(float x) float :	 let a, b = f(x) in a", 1.f, 2.f);
	testMainFloatArg("def f(float x) : (x + 1.0, x + 2.0)           def main(float x) float :	 let a, b = f(x) in b", 1.f, 3.f);

	// Not enough vars
	testMainFloatArgInvalidProgram("def main(float x) float :	 let a, b = (1, 2, 3) in a");
	testMainFloatArgInvalidProgram("def main(float x) float :	 let a, b, c = (1, 2, 3, 4) in a");

	// Too many vars
	testMainFloatArgInvalidProgram("def main(float x) float :	 let a, b = [1]t in a");
	testMainFloatArgInvalidProgram("def main(float x) float :	 let a, b, c = (1, 2) in a");
	testMainFloatArgInvalidProgram("def main(float x) float :	 let a, b, c, d = (1, 2, 3) in a");

	// Test type declarations on let vars
	testMainFloatArg("def main(float x) float :	 let float a, b = (3.0, 4.0) in a", 1.f, 3.f);
	testMainFloatArg("def main(float x) float :	 let float a, float b = (3.0, 4.0f) in a", 1.f, 3.f);
	testMainFloatArg("def main(float x) float :	 let a, float b = (3.0, 4.0f) in a", 1.f, 3.f);
	testMainFloatArg("def main(float x) float :	 let float a, b = (3.0, 4.0) in b", 1.f, 4.f);
	testMainFloatArg("def main(float x) float :	 let float a, float b = (3.0, 4.0f) in a", 1.f, 3.f);
	testMainFloatArg("def main(float x) float :	 let a, float b = (3.0, 4.0f) in a", 1.f, 3.f);

	// TODO: test type coercion

	// Test ref-counted types
	testMainFloatArgAllowUnsafe("def main(float x) float :	 let a, b = ([3.0, 4.0, 5.0]va, 10.0) in a[0]", 1.f, 3.f, INVALID_OPENCL);
	testMainFloatArgAllowUnsafe("def main(float x) float :	 let a, b = ([3.0, 4.0, 5.0]va, 10.0) in a[1]", 1.f, 4.f, INVALID_OPENCL);

	// Test with structs
	testMainFloatArg("struct S { float s }     def main(float x) float :	 let a, b = (S(3.0), 10.0) in a.s", 1.f, 3.f);


	


	// Test on a tuple returned from a function with a struct
	testMainFloatArg("struct S { float s }     def f(float x) : (S(x + 1.0), x + 2.0)           def main(float x) float :	 let a, b = f(x) in a.s", 1.f, 2.f);
	
	// Test on a tuple returned from a function with a varray
	testMainFloatArgAllowUnsafe("def f(float x) : ([x + 1.0]va, x + 2.0)           def main(float x) float :	 let a, b = f(x) in a[0]", 1.f, 2.f, INVALID_OPENCL);



	// Test map
	{
		const float a[] = {1.0f, 2.0f, 3.0f, 4.0f};
		const float b[] = {10.0f, 20.0f, 30.0f, 40.0f};
		float target_results[] = {1.0f, 4.0f, 9.0f, 16.0f};

		testFloatArray(
			"def square(float x) float : x*x			\n\
			def main(array<float, 4> a, array<float, 4> b) array<float, 4> : map(square, a)",
			a, b, target_results, 4);
	}

	

	testMainFloatArg("struct S { int x }  def f(S s) S : let t = S(1) in s   def main(float x) float : let v = [99]va in x", 1.f, 1.0f, INVALID_OPENCL);


	// ===================================================================
	// Test Refcounting optimisations: test that a let variable used as a function argument is not incremented and decremented
	// ===================================================================

	testMainIntegerArg("def f(string s, int x) int : stringLength(s) + x       def main(int x) int : let s = \"hello\" in f(s, x)", 1, 6, INVALID_OPENCL);


	// ===================================================================
	// Test Refcounting optimisations: test that a argument variable used as a function argument is not incremented and decremented
	// ===================================================================

	testMainIntegerArg("def f(string s, int x) int : stringLength(s) + x     def g(string s, int x) int : f(s, x)      def main(int x) int : g(\"hello\", x)", 1, 6, INVALID_OPENCL);

	// test that a argument variable used as a function argument is not incremented and decremented, even when the argument may be stored and returned in the result.
	testMainIntegerArg("struct S { string str }      def f(string str) S : S(str)     def g(string s) S : f(s)      def main(int x) int : stringLength(g(\"hello\").str)", 1, 5, INVALID_OPENCL);



	testMainIntegerArg("def f(string s, int x) int : stringLength(s) + x       def main(int x) int : f(\"hello\", x)", 1, 6, INVALID_OPENCL);


	// ===================================================================
	// Test length function
	// ===================================================================
	// Test length() function on varrays
	testMainInt64Arg("def main(int64 x) int64 : length([1.0]va)", 1, 1);
	testMainInt64Arg("def main(int64 x) int64 : length([1.0, 2.0, 3.0]va)", 1, 3);

	// Test length() function on tuples
	testMainInt64Arg("def main(int64 x) int64 : length([1.0]t)", 1, 1);
	testMainInt64Arg("def main(int64 x) int64 : length([1.0, 2.0, 3.0]t)", 1, 3);

	// Test length() function on arrays
	testMainInt64Arg("def main(int64 x) int64 : length([1.0]a)", 1, 1);
	testMainInt64Arg("def main(int64 x) int64 : length([1.0, 2.0, 3.0]a)", 1, 3);

	// Test length() function on vectors
	testMainInt64Arg("def main(int64 x) int64 : length([1.0]v)", 1, 1);
	testMainInt64Arg("def main(int64 x) int64 : length([1.0, 2.0, 3.0]v)", 1, 3);

	// ===================================================================
	// Test VArrays
	// ===================================================================
	
	// Test VArray let variables.
	testMainFloatArg("def main(float x) float : let v = [99]va in x", 1.f, 1.0f, INVALID_OPENCL);
	testMainFloatArg("def main(float x) float : let v = [1.0, 2.0, 3.0]va in x", 1.f, 1.0f, INVALID_OPENCL);
	testMainFloatArg("def main(float x) float : let v = [x + 1.0, x + 2.0, x + 3.0]va in x", 1.f, 1.0f, INVALID_OPENCL);

	// Two VArray let variables
	testMainFloatArg("def main(float x) float : let a = [1]va  b = [2]va   in x", 1.f, 1.0f, INVALID_OPENCL);

	// Back-references in let variables
	testMainFloatArg("def main(float x) float : let a = [1]va  b = a   in x", 1.f, 1.0f, INVALID_OPENCL);

	// Test a reference to a let var from another let block
	testMainFloatArg("def main(float x) float :			\n\
					 let								\n\
						a = [1]va						\n\
					in									\n\
						let								\n\
							b = a						\n\
						in								\n\
							x", 1.f, 1.0f, INVALID_OPENCL);


	// Return a varray from a function
	testMainFloatArg("def f() varray<int> : [3]va      def main(float x) float : let v = f() in x", 1.f, 1.0f, INVALID_OPENCL);
	
	// Test a varray with access
	//testMainFloatArgAllowUnsafe("def main(float x) float : [x + 1.0, x + 2.0, x + 3.0]va[1]", 1.f, 3.0f);

	// Test a varray returned from a function with access
	testMainFloatArgAllowUnsafe("def f(float x) varray<float> : [x]va    def main(float x) float : elem(f(x), 0)", 1.f, 1.0f, INVALID_OPENCL);
	testMainFloatArgAllowUnsafe("def f(float x) varray<float> : [x + 1.0, x + 2.0, x + 3.0]va    def main(float x) float : f(x)[0]", 1.f, 2.0f, INVALID_OPENCL);
	testMainFloatArgAllowUnsafe("def f(float x) varray<float> : [x + 1.0, x + 2.0, x + 3.0]va    def main(float x) float : f(x)[2]", 1.f, 4.0f, INVALID_OPENCL);
	
	// Test varray returned from an if expression
	testMainFloatArgAllowUnsafe("def main(float x) float : let v = (if x < 2.0 then [x + 1.0]va else [x + 2.0]va) in elem(v, 0)", 1.f, 2.0f, INVALID_OPENCL);
	testMainFloatArgAllowUnsafe("def main(float x) float : (if x < 2.0 then [x + 1.0]va else [x + 2.0]va)[0]", 1.f, 2.0f, INVALID_OPENCL);

	// Test varray returned from an if expression in a function
	testMainFloatArgAllowUnsafe("def f(float x) varray<float> : if x < 2.0 then [x + 1.0]va else [x + 2.0]va      def main(float x) float : f(x)[0]", 1.f, 2.0f, INVALID_OPENCL);



	testMainFloatArgAllowUnsafe("struct S { float x }     def f(float x) S : S(x)        def main(float x) float : f(x).x", 1.f, 1.0f, INVALID_OPENCL);

	

	// Test varray in struct (just assigned to let var but not used)
	testMainFloatArgAllowUnsafe("struct S { varray<float> v }     def main(float x) float : let s = S([x]va) in x", 1.f, 1.0f, INVALID_OPENCL);
	
	// Test varray in struct
	testMainFloatArgAllowUnsafe("struct S { varray<float> v }     def main(float x) float : S([x]va).v[0]", 1.f, 1.0f, INVALID_OPENCL);

	// Test two varrays in struct
	testMainFloatArgAllowUnsafe("struct S { varray<float> a, varray<float> b }  def main(float x) float : S([x]va, [x]va).a[0]", 1.f, 1.0f, INVALID_OPENCL);

	// Test varray in struct returned from function
	testMainFloatArgAllowUnsafe("struct S { varray<float> v }     def f(float x) S : S([x + 1.0]va)        def main(float x) float : f(x).v[0]", 1.f, 2.0f, INVALID_OPENCL);

	// Test two varrays in struct returned from function
	testMainFloatArgAllowUnsafe("struct S { varray<float> a, varray<float> b }     def f(float x) S : S([x + 1.0]va, [x + 2.0]va)        def main(float x) float : f(x).a[0]", 1.f, 2.0f, INVALID_OPENCL);
	

	//------------------------ VArrays as function arguments --------------------------
	// Test a VArray returned from identity function
	testMainFloatArgAllowUnsafe("def f(varray<float> v) varray<float> : v      def main(float x) float : f([99.0]va)[0]", 1.f, 99.0f, INVALID_OPENCL);
	testMainFloatArgAllowUnsafe("def f(varray<float> v) varray<float> : v      def main(float x) float : let v = f([99.0]va) in x", 99.f, 99.0f, INVALID_OPENCL);

	// Test a VArray returned from 'identity' function with two args
	testMainFloatArgAllowUnsafe("def f(varray<float> v, varray<float> v2) varray<float> : v      def main(float x) float : f([88.0]va, [99.0]va)[0]", 1.f, 88.0f, INVALID_OPENCL);
	testMainFloatArgAllowUnsafe("def f(varray<float> v, varray<float> v2) varray<float> : v2      def main(float x) float : f([88.0]va, [99.0]va)[0]", 1.f, 99.0f, INVALID_OPENCL);

	testMainFloatArgAllowUnsafe("def f(varray<float> v, varray<float> v2) varray<float> : v2      def main(float x) float : let v = [99.0]va in f(v, v)[0]", 1.f, 99.0f, INVALID_OPENCL);


	// Test a VArray passed as a function argument (but not used)
	testMainFloatArgAllowUnsafe("def f(varray<float> v) float : 1.0      def main(float x) float : f([99.0]va)", 1.f, 1.0f, INVALID_OPENCL);

	// Test a VArray passed as a function argument, then indexed into.
	testMainFloatArgAllowUnsafe("def f(varray<float> v) float : v[0]      def main(float x) float : f([x]va)", 10.f, 10.0f, INVALID_OPENCL);

	// Test two VArrays passed as function arguments, then indexed into.
	testMainFloatArgAllowUnsafe("def f(varray<float> v_a, varray<float> v_b) float : v_a[0] + v_b[0]      def main(float x) float : f([x]va, [1.0]va)", 10.f, 11.0f, INVALID_OPENCL);


	// Test nested function call with varray
	testMainFloatArgAllowUnsafe("def f(varray<float> v) float : v[0]      def g(varray<float> v) float : f(v)      def main(float x) float : g([x]va)", 10.f, 10.0f, INVALID_OPENCL);

	testMainFloatArgAllowUnsafe("def f(varray<float> v) float : v[0]      def g(varray<float> v) float : f(v) + 1.0     def main(float x) float : g([x]va)", 10.f, 11.0f, INVALID_OPENCL);

	// Test varray function argument being referenced by let
	testMainFloatArgAllowUnsafe("def f(varray<float> v) float : let v_2 = v in v_2[0]      def main(float x) float : f([x]va)", 10.f, 10.0f, INVALID_OPENCL);
	testMainFloatArgAllowUnsafe("def f(varray<float> v) float : let v_2 = v in v[0]      def main(float x) float : f([x]va)", 10.f, 10.0f, INVALID_OPENCL);

	// Test varray passed as function argument but returned in struct (tests return of argument via enclosing type)
	testMainFloatArgAllowUnsafe("struct S { varray<float> v }     def f(varray<float> arg) S : S(arg)      def main(float x) float : f([x]va).v[0]", 10.f, 10.0f, INVALID_OPENCL);

	testMainFloatArgAllowUnsafe("struct S { varray<float> a, varray<float> b }     def f(varray<float> arg) S : S(arg, arg)      def main(float x) float : f([x]va).a[0]", 10.f, 10.0f, INVALID_OPENCL);

	testMainFloatArgAllowUnsafe("struct S { varray<float> a, varray<float> b }     def f(varray<float> arg, varray<float> arg2) S : S(arg, arg2)      def main(float x) float : f([x]va, [x]va).a[0]", 10.f, 10.0f, INVALID_OPENCL);
	

	//------------------------ VArrays in tuples --------------------------
	testMainFloatArgAllowUnsafe("def f(varray<float> arg) tuple<varray<float>> : [arg]t      def main(float x) float : f([x]va)[0][0]", 10.f, 10.0f, INVALID_OPENCL);

	testMainFloatArgAllowUnsafe("def f(varray<float> arg) tuple<varray<float>, varray<float>> : (arg, arg)      def main(float x) float : f([x]va)[0][0]", 10.f, 10.0f, INVALID_OPENCL);


	//------------------------ Test a VArray in a VArray --------------------------
	testMainFloatArgAllowUnsafe("def main(float x) float : let a = [[99]va]va in x", 10.f, 10.0f, INVALID_OPENCL);

	
	//------------------------ Test a string in a VArray --------------------------
	testMainFloatArgAllowUnsafe("def main(float x) float : let a = [\"hello\"]va in x", 10.f, 10.0f, INVALID_OPENCL);

	testMainFloatArgAllowUnsafe("def main(float x) float : let a = [[\"hello\"]va]va in x", 10.f, 10.0f, INVALID_OPENCL);
	
	//------------------------ Test a struct, with a ref counted field, in a VArray --------------------------
	testMainFloatArgAllowUnsafe("struct S { string str }      def main(float x) float : let a = S(\"hello\") in x", 10.f, 10.0f, INVALID_OPENCL);

	testMainFloatArgAllowUnsafe("struct S { string str }      def main(float x) float : let a = [S(\"hello\")]va in x", 10.f, 10.0f, INVALID_OPENCL);

	testMainFloatArgAllowUnsafe("struct S { string str }      def main(float x) float : let a = [S(\"hello\"), S(\"world\")]va in x", 10.f, 10.0f, INVALID_OPENCL);

	// Test a struct with two ref counted fields
	testMainFloatArgAllowUnsafe("struct S { string s_a, string s_b }      def main(float x) float : let a = S(\"hello\", \"world\") in x", 10.f, 10.0f, INVALID_OPENCL);

	testMainFloatArgAllowUnsafe("struct S { string s_a, string s_b }      def main(float x) float : let a = [S(\"hello\", \"world\")]va in x", 10.f, 10.0f, INVALID_OPENCL);
	


	//------------------------ Test a tuple, with a ref counted field, in a VArray --------------------------
	testMainFloatArgAllowUnsafe("struct S { string str }      def main(float x) float : let a = S(\"hello\") in x", 10.f, 10.0f, INVALID_OPENCL);
	testMainFloatArgAllowUnsafe("def main(float x) float : let a = [\"hello\"]t in x", 10.f, 10.0f, INVALID_OPENCL);

	testMainFloatArgAllowUnsafe("def main(float x) float : let a = [[\"hello\"]t]va in x", 10.f, 10.0f, INVALID_OPENCL);

	testMainFloatArgAllowUnsafe("def main(float x) float : let a = [[\"hello\"]t, [\"world\"]t]va in x", 10.f, 10.0f, INVALID_OPENCL);

	// Test a tuple with two ref counted fields
	testMainFloatArgAllowUnsafe("def main(float x) float : let a = (\"hello\", \"world\") in x", 10.f, 10.0f, INVALID_OPENCL);

	testMainFloatArgAllowUnsafe("def main(float x) float : let a = [(\"hello\", \"world\")]va in x", 10.f, 10.0f, INVALID_OPENCL);

	
	//------------------------ Test a VArray in a named constant --------------------------
	testMainFloatArgAllowUnsafe("TEST = [99.0]va     def main(float x) float : TEST[0]", 10.f, 99.0f, INVALID_OPENCL);
	testMainFloatArgAllowUnsafe("TEST = [99.0]va     def main(float x) float : TEST[0] + TEST[0]", 10.f, 198.0f, INVALID_OPENCL);

	testMainFloatArgAllowUnsafe("TEST = [1.0 + 2.0]va     def main(float x) float : TEST[0] + TEST[0]", 10.f, 6.0f, INVALID_OPENCL);

	testMainFloatArgAllowUnsafe("def f(varray<float> v) : v     TEST = f([3.0]va)     def main(float x) float : TEST[0]", 10.f, 3.0f, INVALID_OPENCL);
	testMainFloatArgAllowUnsafe("def f(varray<float> v) : v     TEST = f([3.0]va)     def main(float x) float : TEST[0] + TEST[0]", 10.f, 6.0f, INVALID_OPENCL);



	
	// Test fold built-in function with update
	/*{
		const int len = 256;
		js::Vector<int, 32> vals(len, 0);
		js::Vector<int, 32> b(len, 0);
		js::Vector<int, 32> target_results(len, 1);

		testIntArray("																\n\
		def f(array<int, 256> state, int iteration) tuple<array<int, 256>, bool> :			\n\
				[update(state, iteration, elem(state, iteration) + 1),					\n\
				iteration < 255]t																\n\
																							\n\
		def main(array<int, 256> vals, array<int, 256> initial_counts) array<int, 256>:  iterate(f, vals)",
			&vals[0], &b[0], &target_results[0], vals.size(),
			true // allow_unsafe_operations
		);
	}

	std::cout << timer.elapsedString() << std::endl;
	int a = 9;
	return;*/

	// Test with pass-by-reference data (struct)
	testMainIntegerArg("															\n\
		struct s { int x, int y }													\n\
		def f(s current_state, int iteration) tuple<s, bool> :					\n\
			if iteration >= current_state.y												\n\
				[current_state, false]t # break										\n\
			else																	\n\
				[s(current_state.x*current_state.x, current_state.y), true]t					\n\
		def main(int x) int :  iterate(f, s(x, x)).x", 3, 6561, INVALID_OPENCL);
	

	// This test triggers a problem with __chkstk when >= 4K is allocated on stack
	/*{
		const int len = 1024;
		js::Vector<int, 32> vals(len, 0);
		js::Vector<int, 32> b(len, 0);
		js::Vector<int, 32> target_results(len, 0);
		target_results[0] = len;

		testIntArray("																\n\
		def f(array<int, 1024> counts, int x) array<int, 1024> :			\n\
				update(counts, x, elem(counts, x) + 1)			\n\
		def main(array<int, 1024> vals, array<int, 1024> initial_counts) array<int, 1024>:  fold(f, vals, initial_counts)",
			&vals[0], &b[0], &target_results[0], vals.size(),
			true // allow_unsafe_operations
		);
	}*/

	//testMainFloatArg("def f(array<float, 1024> a, float x) float : a[0]       def main(float x) float : f([x]a1024, x) ", 2.f, 2.f);

	// Test that binding to a let variable overrides (shadows) a global function definition
	testMainIntegerArg("def f(int x) int : 1		   def main(int x) int : let y = 1 f = 2 in f", 10, 2);

	testMainIntegerArg("def f(int x) tuple<int, int> : [1, 2]t		   def main(int x) int : f(x)[1 - 1]", 10, 1);

	testMainIntegerArg("def f() bool : 1 + 2 < 3         def main(int x) int : x", 1, 1);
	//testMainIntegerArg("def f() bool : 1 + 2 * 3         def main(int x) int : x", 1, 1);

	//TEMP:
	testMainFloatArgInvalidProgram("def main(float x) float :  x [bleh");

	testMainIntegerArg("def f(int x) tuple<int, int> : [1, 2]t		   def main(int x) int : f(x)[0]", 10, 1);
		//testMainIntegerArg("def f(int x) tuple<int, int> : if x < 0 [1, 2]t else [3, 4]t			\n\
		//			   def main(int x) int : f(x)[0]", 10, 3);

	testMainIntegerArg("def f(int x) tuple<int> : if x < 0 [1]t else [3]t			\n\
					   def main(int x) int : f(x)[0]", 10, 3);




	//testMainFloatArg("struct vec2 { vector<float, 2> v }     def main(float x) float : let a = vec2([1.0, 2.0]v)  in a.v[0]", 0.f, 1.0f);
	testMainFloatArg("struct vec2 { vector<float, 2> v }     def main(float x) float : let a = vec2([1.0, 2.0]v) in a.v[0]", 0.f, 1.0f);

	testMainFloatArg("struct s { float y }     def main(float x) float : s(x).y", 3.f, 3.0f);

	testMainFloatArg("struct vec2 { vector<float, 2> v }     def main(float x) float : let a = vec2([x, 2.0]v)  in (a.v)[0]", 3.f, 3.0f);
	testMainFloatArg("struct vec2 { vector<float, 2> v }     def main(float x) float : let a = vec2([1.0, 2.0]v)  in a.v[0]", 0.f, 1.0f);
	testMainFloatArg("struct vec2 { vector<float, 2> v }     def main(float x) float : let a = vec2([x, 2.0]v)  in a.v[0]", 3.f, 3.0f);
	testMainFloatArg("struct vec2 { vector<float, 2> v }     def main(float x) float : let a = vec2([1.0, 2.0]v)  in  elem(a.v, 0)", 0.f, 1.0f);



	// Test constant folding with a vector literal that is not well typed (has boolean element).
	// Make sure that constant folding doesn't allow it.
	testMainFloatArgInvalidProgram("def main(float x) float : elem(  [2.0, false]v   , 0)");

	// Check constant folding with elem() and collections
	testMainFloatArgCheckConstantFolded("def main(float x) float : elem([1.0, 2.0]v, 1)", 1.f, 2.f);
	testMainFloatArgCheckConstantFolded("def main(float x) float : elem([1.0, 2.0]t, 1)", 1.f, 2.f);
	testMainFloatArgCheckConstantFolded("def main(float x) float : elem([1.0, 2.0]a, 1)", 1.f, 2.f);

	// Check constant folding with elem() and collections, and operations on collections
	testMainFloatArgCheckConstantFolded("def main(float x) float : elem([1.0, 2.0]v + [3.0, 4.0]v, 1)", 1.f, 6.f);
	testMainFloatArgCheckConstantFolded("def main(float x) float : elem([1.0, 2.0]v - [3.0, 4.0]v, 1)", 1.f, -2.f);
	testMainFloatArgCheckConstantFolded("def main(float x) float : elem([1.0, 2.0]v * [3.0, 4.0]v, 1)", 1.f, 8.f);



	testMainFloatArg("def main(float x) float : elem([x, 2.0]v, 1)", 1.f, 2.f);


	testMainFloatArgCheckConstantFolded("def main(float x) float : 1.0 + 2.0", 1.f, 3.f);

	testFuzzProgram("def main(float x) float : x!");

	testFuzzProgram("struct vec3 { float x, float y, float z }	 		def vec3(float v) vec3 : vec3(v, v, v)		 		def op_add(vec3 a, vec3 b) vec3 : vec3(a.x+b.x, a.y+b.y, a.z+b.z)	 		def eval(vec3 pos) vec3 :					 			let											 				scale = 2/0.0							 			in											 				vec3(scale) + vec3(0.2)					 		def main(float x) float: x(eval(vec3(x, x, x)))");

	testFuzzProgram("def main(float x) float : (1 * (1 * ((1 + 1) * (1 - 1 + 1)) - 1 - ((1 + (((((1 + 		 1 / (1 + (((1 + 1 / (1 * (1 - 1 + 1 / 1 / 1))) - 1 - 1 - (1 + 1 / 1) + (((1 * 1 		) * 1) * 1) / 1) - 1 + 1)) - 1 / 1) + (1 * 1)) + 1 - 1) + 1) * 1)) + 1) / (1 + 1 		) / 1 - ((1 + 1 / 1 - (((1 * ((1 - 1 - 1 / 1 - 1 * 1) - (1 / 1 - 1 * 1) + ((1 +	 		1) - 1 * 1) - 1 / 1)) + (1 / 1 / 1 - 1 - (1 + 1) / (1 + 1) + 1)) * (1 * ((((1 +	 		1) * 1) / 1 - 1 - 1 - (((1 + 1) * 1 - (((1 / 1 * 1) * (1 + 1) - 1) / 1 / 1 / 1 - 		 (1 + (((1 + 1) + 1) * 1)) - 1 / ((1 + 1) / (1 * 1) / (1 + (1 / 1 * 1 / 1 - 1 -	 		(1 * 1) / (1 + 1) - 1 - 1 - 1 - 1 - 1 / 1)) / (1 / 1 * 1) + (((1 + 1) * ((1 + 1) 		 * 1)) / 1 + ((1 - ((1 * 1) + 1) + 1) + 1 - 1 / ((1 / (1 - ((1 + 1) - ((((1 - (( 		1 * ((1 * ((1 + 1) + ((1 - (1 * 1) + (1 - (1 - 1 - (1 * 1) / (1 + 1) / 1 * (1 -	 		1 + (1 + 1) - ((1 / 1 / 1 + 1) * 1) - (1 - 1 * 1))) * 1) - 1 - 1 - 1 - (1 * (((1 		 * 1) * ((1 + (1 / (1 * 1) * 1 - 1)) * (1 + (((1 + 1) + 1) + 1)))) + 1) / 1)) +	 		1 / 1) / 1 - 1)) * 1 - 1)) / 1 * (1 * 1) - 1 - 1 / (1 * ((((1 + 1) + 1) * 1 - 1	 		- 1 / ((1 + 1) / (1 * 1) - ((1 / 1 + 1) * 1) + (1 + (1 * 1) - 1 - 1 - 1 - (1 + ( 		1 + 1))) / 1)) - 1 * (1 / ((1 * 1) + ((1 - 1 + (1 + 1)) + ((1 int  + 1) * 1))) / 1 *	 		1)) - 1) / 1 / 1 / 1) / 1 + 1) / (1 / (1 + (1 + (1 * 1 - 1)) - 1) / 1 - ((1 * 1	 		/ 1 / (1 / (1 * 1 / 1 - 1) / 1 * 1) / 1) - 1 * ((1 + (((1 + 1) + 1) - ((1 * ((1	 		+ 1) + 1)) * ((1 * 1) * 1) - 1) / 1 / (1 - 1 / (1 - 1 * 1) / 1 * 1) / ((1 - (1 + 		 1) / 1 * 1) + 1 - (1 + (1 * 1)) - 1) - 1 * 1) - 1 / 1) * 1)) + (((1 - (1 / 1 -	 		1 + 1 - (1 * (1 + 1)) / (1 + (1 + 1))) + 1) - ((1 + 1) * (1 * 1 / 1)) * 1 - 1) + 		 1) - 1 / 1 - (((1 * 1 - 1) + 1) - (1 + 1) - 1 - 1 * 1)) / (1 + 1) + (((1 * ((1	 		/ (1 * 1) * 1) * 1)) * 1) + 1 - (1 * 1)) / 1) * 1) + (1 / 1 * 1 / (1 * (1 + (1 / 		 1 / 1 - ((1 + ((1 - 1 / 1 + 1 / 1 - 1) * 1)) * 1) - 1 / 1 / 1 / (1 + 1) - (1 +	 		((1 + (((1 + 1 - 1 / ((1 + 1) * (1 + (1 / 1 + (1 + 1))))) * 1) * ((1 - 1 / (1 +	 		1 - (((1 / 1 - 1 / 1 * (1 + (((1 * 1) * (1 - 1 * (1 * 1))) - 1 + ((1 * 1) * ((1	 		- 1 * 1) / 1 + (1 + 1)))))) * 1) + 1 - 1 - 1 / (1 + ((1 * (1 + 1)) * 1)))) / (1	 		+ 1 - 1) + 1) - 1 * 1) / 1 - 1 / 1 - ((((1 + (1 * 1 - 1)) * ((1 + (1 * 1)) * 1)) 		 * ((1 + 1) + 1)) + 1) / 1 / 1 - ((1 / 1 - (((1 + (1 * 1) - 1) - 1 * 1 - (1 + 1) 		 - 1) + 1) + (1 / (1 + (1 * 1)) / 1 * 1 / 1) / (1 + 1)) * 1 / 1 - 1) - 1 - 1 - 1 		) / 1) * 1) / 1) + 1)) / 1 / 1)) / 1) * ((((1 / 1 + 1) - 1 * 1 / (1 + 1)) * 1 /	 		1) / 1 * 1) / 1 / 1 / 1 - ((1 * (((1 / 1 * (1 * (1 / ((1 - 1 * (1 * 1 / 1)) + (( 		1 * (1 + 1)) * 1)) * (1 + (1 + (1 * (1 + 1 / 1 - (1 - 1 * ((1 + 1) + 1 - (1 * 1) 		) / ((1 - 1 + 1) - 1 + 1)))) - 1 / (1 + 1) / 1 / 1 / 1 / (1 + (1 * (1 - (1 * 1 / 		 1) * 1))) / 1 - 1 - 1))) / ((1 + 1) + 1 /  + (1 * 1) / 1 / (1 * 1 / 1) - 1 - 1 - 1 		 / (1 * ((1 / 1 - 1 / 1 - 1 / 1 / 1 / 1 / 1 * 1) - 1 / (1 - ((1 / 1 + 1) + 1) -	 		1 / (1 * (1 + 1)) / 1 * (1 * 1) / 1) / 1 * 1)) / (1 + 1) / (((1 - 1 * 1) + (1 -	 		(1 + 1) + 1 / 1)) * 1) - (1 / 1 / 1 * 1) - (1 - ((1 * (1 - (1 + 1) + 1)) * (1 +	 		1)) / 1 / 1 + (1 - 1 - (1 + (1 * 1)) - ((1 + 1 - ((1 + ((1 * 1) * 1 - 1 / 1)) +	 		1) - 1) / 1 - 1 + 1) / (((1 * 1) + 1) + 1) * (1 * 1)))) / 1 / ((1 * 1) + 1 - 1)) 		 / 1) * 1) * 1)) * ((1 - (1 * 1 / 1) + 1) * 1 / 1)) / (1 + 1) / 1) + (1 / 1 * (1 		 + 1 / 1 - (1 / (1 - 1 + 1) + 1) / (1 + 1) - (1 * 1)) - (((1 / 1 + 1 - 1 - 1) /	 		1 * 1) + (1 * 1) / (1 / 1 * 1) - 1 - (1 + 1))) / 1) + 1) + 1)) / 1 / 1)) + 1) -	 		1 - (1 * 1 - 1)) * ((1 + 1) * 1)) - 1 * (1 + ((1 * 1) + (1 * 1)))) - 1 * 1)))) * 		 1) - 1 - 1 - 1))");


	// NaN
	testFuzzProgram("def g(float x) float :  pow( -2 + x, -(1.0 / 8.0))         def main(float x) float : g(0.5)");

	//testMainFloatArgReturnsInt("def main(float x) : if(x < 10.0, 3, 4)", 1.f, 3);
	testMainFloatArg("def main(float x) float : if(x < 10.0, 3, 4)", 1.f, 3.f);

	// Main function that is generic.
	testMainFloatArgInvalidProgram("struct Float4Struct { vector<float, 4> v }  		\n\
								   def pow(Float4Struct a, Float4Struct b) : Float4Struct(pow(a.v, b.v))		 	\n\
								   def main<T>(T x) T : x*x           \n\
								   def m(Float4Struct a, Float4Struct b) Float4Struct : pow(a, b)");

	testMainFloatArg("def f(int x) int : x*x	      def main(float x) float : f(2)", 2.0f, 4.0f);

	// Some constant folding tests
	testMainIntegerArgInvalidProgram("def main(int x) int : ((1 + 2) + (3 + true)) + (5 + 6)");
	testMainIntegerArg("def main(int x) int : ((1 + 2) + (3 + 4)) + (5 + 6)", 1, 21);

	testMainIntegerArgInvalidProgram("def g(function<float, float> f, float x) : f(xow(x, 3))");


	timer.reset();
	testMainFloatArgInvalidProgram("def main(float x) float : (1 * (1 * ((1 + 1) * (1 - 1 + 1)) - 1 - ((1 + (((((1 +\n\
		 1 / (1 + (((1 + 1 / (1 * (1 - 1 + 1 / 1 / 1))) - 1 - 1 - (1 + 1 / 1) + (((1 * 1\n\
		) * 1) * 1) / 1) - 1 + 1)) - 1 / 1) + (1 * 1)) + 1 - 1) + 1) * 1)) + 1) / (1 + 1\n\
		) / 1 - ((1 + 1 / 1 - (((1 * ((1 - 1 - 1 / 1 - 1 * 1) - (1 / 1 - 1 * 1) + ((1 +	\n\
		1) - 1 * 1) - 1 / 1)) + (1 / 1 / 1 - 1 - (1 + 1) / (1 + 1) + 1)) * (1 * ((((1 +	\n\
		1) * 1) / 1 - 1 - 1 - (((1 + 1) * 1 - (((1 / 1 * 1) * (1 + 1) - 1) / 1 / 1 / 1 -\n\
		 (1 + (((1 + 1) + 1) * 1)) - 1 / ((1 + 1) / (1 * 1) / (1 + (1 / 1 * 1 / 1 - 1 -	\n\
		(1 * 1) / (1 + 1) - 1 - 1 - 1 - 1 - 1 / 1)) / (1 / 1 * 1) + (((1 + 1) * ((1 + 1)\n\
		 * 1)) / 1 + ((1 - ((1 * 1) + 1) + 1) + 1 - 1 / ((1 / (1 - ((1 + 1) - ((((1 - ((\n\
		1 * ((1 * ((1 + 1) + ((1 - (1 * 1) + (1 - (1 - 1 - (1 * 1) / (1 + 1) / 1 * (1 -	\n\
		1 + (1 + 1) - ((1 / 1 / 1 + 1) * 1) - (1 - 1 * 1))) * 1) - 1 - 1 - 1 - (1 * (((1\n\
		 * 1) * ((1 + (1 / (1 * 1) * 1 - 1)) * (1 + (((1 + 1) + 1) + 1)))) + 1) / 1)) +	\n\
		1 / 1) / 1 - 1)) * 1 - 1)) / 1 * (1 * 1) - 1 - 1 / (1 * ((((1 + 1) + 1) * 1 - 1	\n\
		- 1 / ((1 + 1) / (1 * 1) - ((1 / 1 + 1) * 1) + (1 + (1 * 1) - 1 - 1 - 1 - (1 + (\n\
		1 + 1))) / 1)) - 1 * (1 / ((1 * 1) + ((1 - 1 + (1 + 1)) + ((1 + 1) * 1))) / 1 *	\n\
		1)) - 1) / 1 / 1 / 1) / 1 + 1) / (1 / (1 + (1 + (1 * 1 - 1)) - 1) / 1 - ((1 * 1	\n\
		/ 1 / (1 / (1 * 1 / 1 - 1) / 1 * 1) / 1) - 1 * ((1 + (((1 + 1) + 1) - ((1 * ((1	\n\
		+ 1) + 1)) * ((1 * 1) * 1) - 1) / 1 / (1 - 1 / (1 - 1 * 1) / 1 * 1) / ((1 - (1 +\n\
		 1) / 1 * 1) + 1 - (1 + (1 * 1)) - 1) - 1 * 1) - 1 / 1) * 1)) + (((1 - (1 / 1 -	\n\
		1 + 1 - (1 * (1 + 1)) / (1 + (1 + 1))) + 1) - ((1 + 1) * (1 * 1 / 1)) * 1 - 1) +\n\
		 1) - 1 / 1 - (((1 * 1 - 1) + 1) - (1 + 1) - 1 - 1 * 1)) / (1 + 1) + (((1 * ((1	\n\
		/ (1 * 1) * 1) * 1)) * 1) + 1 - (1 * 1)) / 1) * 1) + (1 / 1 * 1 / (1 * (1 + (1 /\n\
		 1 / 1 - ((1 + ((1 - 1 / 1 + 1 / 1 - 1) * 1)) * 1) - 1 / 1 / 1 / (1 + 1) - (1 +	\n\
		((1 + (((1 + 1 - 1 / ((1 + 1) * (1 + (1 / 1 + (1 + 1))))) * 1) * ((1 - 1 / (1 +	\n\
		1 - (((1 / 1 - 1 / 1 * (1 + (((1 * 1) * (1 - 1 * (1 * 1))) - 1 + ((1 * 1) * ((1	\n\
		- 1 * 1) / 1 + (1 + 1)))))) * 1) + 1 - 1 - 1 / (1 + ((1 * (1 + 1)) * 1)))) / (1	\n\
		+ 1 - 1) + 1) - 1 * 1) / 1 - 1 / 1 - ((((1 + (1 * 1 - 1)) * ((1 + (1 * 1)) * 1))\n\
		 * ((1 + 1) + 1)) + 1) / 1 / 1 - ((1 / 1 - (((1 + (1 * 1) - 1) - 1 * 1 - (1 + 1)\n\
		 - 1) + 1) + (1 / (1 + (1 * 1)) / 1 * 1 / 1) / (1 + 1)) * 1 / 1 - 1) - 1 - 1 - 1\n\
		) / 1) * 1) / 1) + 1)) / 1 / 1)) / 1) * ((((1 / 1 + 1) - 1 * 1 / (1 + 1)) * 1 /	\n\
		1) / 1 * 1) / 1 / 1 / 1 - ((1 * (((1 / 1 * (1 * (1 / ((1 - 1 * (1 * 1 / 1)) + ((\n\
		1 * (1 + 1)) * 1)) * (1 + (1 + (1 * (1 + 1 / 1 - (1 - 1 * ((1 + 1) + 1 - (1 * 1)\n\
		) / ((1 - 1 + 1) - 1 + 1)))) - 1 / (1 + 1) / 1 / 1 / 1 / (1 + (1 * (1 - (1 * 1 /\n\
		 1) * 1))) / 1 - 1 - 1))) / ((1 + 1) + 1 / (1 * 1) / 1 / (1 * 1 / 1) - 1 - 1 - 1\n\
		 / (1 * ((1 / 1 - 1 / 1 - 1 / 1 / 1 / 1 / 1 * 1) - 1 / (1 - ((1 / 1 + 1) + 1) -	\n\
		1 / (1 * (1 + 1)) / 1 * (1 * 1) / 1) / 1 * 1)) / (1 + 1) / (((1 - 1 * 1) + (1 -	\n\
		(1 + 1) + 1 / 1)) * 1) - (1 / 1 / 1 * 1) - (1 - ((1 * (1 - (1 + 1) + 1)) * (1 +	\n\
		1)) / 1 / 1 + (1 - 1 - (1 + (1 * 1)) - ((1 + 1 - ((1 + ((1 * 1) * 1 - 1 / 1)) +	\n\
		1) - 1) / 1 - 1 + 1) / (((1 * 1) + 1) + 1) * (1 * 1)))) / 1 / ((1 * 1) + 1 - 1))\n\
		 / 1) * 1) * 1)) * ((1 - (1 * 1 / 1) + 1) * 1 / 1)) / (1 + 1) / 1) + (1 / 1 * (1\n\
		 + 1 / 1 - (1 / (1 - 1 + 1) + 1) / (1 + 1) - (1 * 1)) - (((1 / 1 + 1 - 1 - 1) /	\n\
		1 * 1) + (1 * 1) / (1 / 1 * 1) - 1 - (1 + 1))) / 1) + 1) + 1)) / 1 / 1)) + 1) -	\n\
		1 - (1 * 1 - 1)) * ((1 + 1) * 1)) - 1 * (1 + ((1 * 1) + (1 * 1)))) - 1 * 1)))) *\n\
		 1) - 1 - 1 - 1))");

	std::cout << timer.elapsedString() << std::endl;


	testMainIntegerArgInvalidProgram("def f<T>(T x) : x ()        def main() float : 0  +  f(2.0)");
	testMainIntegerArgInvalidProgram("def f<T>(T x) : x ()        def main() float : 0  -  f(2.0)");
	testMainIntegerArgInvalidProgram("def f<T>(T x) : x ()        def main() float : 0  *  f(2.0)");
	testMainIntegerArgInvalidProgram("def f<T>(T x) : x ()        def main() float : 0  /  f(2.0)");
	testMainIntegerArgInvalidProgram("def f<T>(T x) : x ()        def main() float : 0  <  f(2.0)");

	testMainIntegerArg("def main(int x) int : elem( [1, 1, 1, 1]v + [x, x, x, x]v, 2)", 1, 2);
	testMainIntegerArg("def main(int x) int : elem( [1, 1, 1, 1]v - [x, x, x, x]v, 2)", 1, 0);
	testMainIntegerArg("def main(int x) int : elem( [1, 1, 1, 1]v * [x, x, x, x]v, 2)", 1, 1);
	testMainIntegerArgInvalidProgram("def main(int x) int : elem( [1, 1, 1, 1]v / [x, x, x, x]v, 2)"); // Vector divides are not allowed for now


	//fuzzTests();

	testMainFloatArg(
		"def main(float x) float: elem(   2.0 * [1.0, 2.0, 3, 4]v, 1)",
		1.0f, 4.0f);

	
	testMainFloatArgInvalidProgram("def main(float x) float : [1.f, elem([1, 1.f]a, elem([1, 1.f]a, 1))]t");
	testMainFloatArgInvalidProgram("def main(float x) float : [false, [[1, 1]t, ((true - false) / (1.f / 1))]a]a");

	testMainFloatArgInvalidProgram("def main(float x) float : ([[false, (1.f && 1)]a, elem([1.f, false]v, - (1))]v / elem([1.f, (1 && 1)]v, - (- (1) ) ))");

	testMainFloatArgInvalidProgram("def main(float x) float : ([[[true, 1.f]a, !false]a, 1]v * [([false, 1]a * true), [-true, (false * true)]v]t)");

	testMainFloatArgInvalidProgram("def main(float x) float : ([[1.f, true]v / if 1 then true else 1, (-1 + (1 - 1.f))]a - ([[false, 1.f]t, (false + 1.f)]a - !-1.f))");

	testMainIntegerArg("def main(int x) int : (1 + 2) + (3 + 4)", 1, 10);



	testMainFloatArg("def main(float x) float : (1 * (1 + ((1 / (1 - 1 / 1 - 1 / ((1 / 1 / 1 + (1 + (1\n\
		 * 1))) * 1) - 1 - (1 - 1 / 1 - 1 - (1 * 1) * (1 + 1 - 1 / 1)) - (1 + 1) - 1 / (\n\
		(1 * 1) - ((1 - 1 * 1) + 1 - ((1 + 1) * (1 * 1) - 1) - 1 / 1 - (1 + (((1 + 1) +\n\
		(1 - 1 - 1 / 1 + 1)) - 1 + 1))) + 1) + ((((1 * (1 + (((1 * ((1 + 1) * 1)) + 1) /\n\
		 1 * 1) - 1 - 1 / ((1 + 1 - 1) + 1) - 1 - 1)) * (1 + (1 + (1 / (1 * (1 * 1)) - (\n\
		1 + 1 - (1 * 1)) + 1) - 1)) / 1) * ((1 + 1) + 1) / 1 / 1) / 1 * 1)) + 1) * (1 *\n\
		1)) - 1 / 1)) / (1 * 1)",
	1.f, 1.f);

	//fuzzTests();

	// Out of bounds elem()
	testMainFloatArgInvalidProgram("def main(int x) int :  elem(update([0]a, -1, 1), 0)");

	// Test coercion of int to float, after it is used to bind to a given function (toFloat).
	testMainFloatArgInvalidProgram("def main(float x) float : toFloat(3*x)");
	testMainFloatArgInvalidProgram("def main(float x) float : toFloat(truncateToInt(3.1)*x)");
	testMainFloatArgInvalidProgram("def main(float x) float : toFloat(truncateToInt(3.1)+x)");
	testMainFloatArgInvalidProgram("def main(float x) float : toFloat(truncateToInt(3.1)-x)");
	testMainFloatArgInvalidProgram("def main(float x) float : toFloat(truncateToInt(3.1)/x)");

	
	// Test circular reference between a named constant and function.
	testMainIntegerArgInvalidProgram("TEN = main(0)		def main(int x) : TEN + x");




	// Test division is only valid for integers, floats
	testMainFloatArgInvalidProgram("def main(float x) float : [1, 2]a / [3, 4]a"); 	


	testMainIntegerArgInvalidProgram("def f<T>(T x) : x        def main() float : f + (2.0)");
	//	testFuzzProgram("def f(array<int, 16> current_state, int elem) array<int, 16> :				 			let																		 				old_count = elem(current_state, elem)								 				new_count = old_count + 1											 			in																		 				update(curreQnt_state, elem, new int _count)		");
//	testFuzzProgram("		def main() floa string t : 				 array 	 let a = [1.0[11.0, , 2.0, 3.0, 4.0]v 					 b = [11.0, 12.0, 13.0, 14.0]v in 					 e2(min(a, b)) 		def main() float : 				  let a = [1.0, 2.0, 3.0, 4.0]v 				  b = [11.0, 12.0, 13.0, 14.0]v in 				  e2( 1.0 min(b, a))");
	testMainIntegerArgInvalidProgram("	struct s { float x, float y }						 				  def op_adsd(s a, s b) : s(a.x + b.x, a.y + b.y)		 				  def f<T>(T a, T b) : a + b							 				  def main() float : x(!f(s(1, 2), s(3, 4)))");
//	testFuzzProgram("def main(floa string t x) float : 1.0   1  def f(int x) int : f(0)  ");


	//testFuzzProgram("def f(array<int, 4> a, int i) int :		 			if inBounds(a, i)						 				elem(a, i)			 										 			else						 				0									 		def main(int i) int :						 			f([1, 2, 3, 4]a, i)");
	//testFuzzProgram("#	def main(float x) float : 					 l main(float x) fet v = [x, x, x, x]v in\				 dot(v, v)");
//	testFuzzProgram("struct vec4 { vector<float, 4> v }					 				   struct vec16 { vector<float, 16> v }					 				   st ruct large_struct { vec4 a, vec16 b }				 				   def main(float x) float : large_struct(vec4([x, x, x, x]v), ve char c16([x, x, x, x, x int64 , x, x, x, x, x, x, x, x, x, x, x]v)).a.v.e0");
	testMainFloatArg("def overloadedFunc(int x) float : 4.0 	  def overloadedFunc(float x) float : 5.0 		def f<T>(T x) float: overloadedFunc(x) / 4  def main(float x) float : f(1.0)", 1.0f, 5.f/4);

	testMainIntegerArg("def main(int x) int : 1 * 2 + 3", 1, 5);
	testMainIntegerArg("def main(int x) int : 1 * (2 + 3)", 1, 5);
	testMainIntegerArg("def main(int x) int : [0, 1, 2, 3]a[0] + 1", 1, 1);

	testMainIntegerArg(
		"struct SpectralVector { vector<float, 8> v }			\n\
		def f(SpectralVector layer_contribution) float :			\n\
				layer_contribution.v[0] * 2.0f				\n\
																\n\
		def main(int x) int : 1", 1, 1);

	/*testMainIntegerArg(
		"struct SpectralVector { vector<float, 8> v }			\n\
		def splatsForLayerContribution(SpectralVector layer_contribution, SpectralVector wavelens) float :			\n\
			let													\n\
					XYZ_0 = wavelens.v[0]						\n\
				in												\n\
					layer_contribution.v[0] * XYZ_0				\n\
																\n\
		def main(int x) int : 1", 1, 1);*/

	// ===================================================================
	// Test logical negation operator (!)
	// ===================================================================
	testMainIntegerArg("def main(int x) int : if !true then 10 else 20", 1, 20);
	testMainIntegerArg("def main(int x) int : if !false then 10 else 20", 1, 10);
	testMainIntegerArg("def main(int x) int : if !(x < 5) then 10 else 20", 1, 20);
	testMainIntegerArg("def main(int x) int : if !(x >= 5) then 10 else 20", 1, 10);

	testMainIntegerArg("def main(int x) int : if !true then 10 else 20", 1, 20);
	testMainIntegerArg("def main(int x) int : if !!true then 10 else 20", 1, 10);
	testMainIntegerArg("def main(int x) int : if !!!true then 10 else 20", 1, 20);

	testMainIntegerArgInvalidProgram("def main(int x) int : if !1 then 10 else 20");
	testMainIntegerArgInvalidProgram("def main(int x) int : if ![1, 2]t then 10 else 20");

	// int64 - int mixing
	testMainIntegerArgInvalidProgram("def main(int64 x) int :	x + 1");
	testMainIntegerArgInvalidProgram("def main(int64 x) int :	x - 1");
	testMainIntegerArgInvalidProgram("def main(int64 x) int :	x * 1");
	testMainIntegerArgInvalidProgram("def main(int64 x) int :	x / 1");
	testMainIntegerArgInvalidProgram("def main(int64 x) int :	if x < 5 1 else 2");

	testMainFloatArgInvalidProgram("	def f(float x) float if(x < 1.0) : 				  let	 					z = 2.0 					y = 3.0 				  in 					y + z 				  def main() float : f(0.0)");
	testMainFloatArgInvalidProgram("def main() float : 					 let a = [1.0, 2.0, 3.0, 4.0]v 					 b = [11.0, 12.0, 13.0, 14 else .0]v in 					 e2(min(a, b)) 		de if f main() float : 				  let a = [1.0, 2.0, 3.0, 4.0]v 				  b = [11.0, 12.0, 13.0, 14.0]v in 				  e2(min(b, a))");
	testMainFloatArgInvalidProgram("		main(int i) int :								 			let												 				a = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]v		 				b = string  [1.0, 1.6, 1.0, 1.0, 1.3, 1.6, 1.8, 1.6]v		 				c = [1.7, 2.8, 3.0, 4 true .7, 5.5, 6.7, 7.0, 8.4] int64 v		 			in												 				truncateToInt(elem(a + if(i < 1, b, c), i))");
	testMainFloatArgInvalidProgram("		def main() float : 					let x = [1.0, 2.0, 3.0, 4.0]v 					y = [10.0, 20.0, 30.0, 40.0]v* sin(x + 0.03) in 					e1(x + y)");

	// Test that we can't put a structure in a vector
	testMainFloatArgInvalidProgram("struct teststruct { float y } \n\
        def main(float x) float : elem([teststruct(x)]v, 0).y");

	testMainFloatArgInvalidProgram("struct teststruct { int y } \n\
								   def f(teststruct a, teststruct b, bool condition) teststruct : let x = if(condition, a, b) in let v = [x, x, x, x, x, x, x, x]v in x \n\
        def main(int x) int : y( f(teststruct(1), teststruct(2), x < 5) )");

	testMainFloatArgInvalidProgram("struct s { float x, float yd }  	def op_sub(s a, s b) : s(a.x - b.x, a.y - b.y)  	def main() float : x( true  < s(2, 3) - s(3, 4))");

	testMainFloatArgInvalidProgram("def f(float x) float : x*x def main(int x) int :  elem(fold(f, [0, 0, 1, 2]a, [0]a16), 1)    def main(float x) float : f(x) - 3");

	
	// A vector of elements that contains one or more float-typed elements will be considered to be a float-typed vector.
	// Either all integer elements will be succesfully constant-folded and coerced to a float literal, or type checking will fail.

	// OLD: A vector of elements, where each element is either an integer literal, or has float type, and there is at least one element with float tyoe, 
	// and each integer literal can be converted to a float literal, will be converted to a vector of floats

	// Test incoercible integers
	testMainFloatArgInvalidProgram("def main(float x) float : elem(  [100000001, 2.0]v   , 0)");
	testMainFloatArgInvalidProgram("def main(float x) float : elem(  [2.0, 100000001]v   , 0)");

	testMainFloatArg("def main(float x) float : elem(  [1, 2.0]v   , 0)", 1.0f, 1.0f);
	testMainFloatArg("def main(float x) float : elem(  [1.0, 2]v   , 0)", 1.0f, 1.0f);

	testMainFloatArg("def main(float x) float : elem(  [1, x]v   , 0)", 1.0f, 1.0f);
	testMainFloatArg("def main(float x) float : elem(  [x, 2]v   , 0)", 1.0f, 1.0f);

	testMainFloatArg("def main(float x) float : elem(  [1, x, 3.0]v   , 0)", 1.0f, 1.0f);
	testMainFloatArg("def main(float x) float : elem(  [x, 2, 3.0]v   , 0)", 1.0f, 1.0f);

	testMainIntegerArgInvalidProgram("struct Float4Struct { vector<float, 4> v }  			def main(Float4Struct a, Float4Struct b) Float4Struct :  				Float4Struct(a.v + [eleFm(b.v, 0)]v4)");


	testMainIntegerArgInvalidProgram("def main(int i) int : if i >= 0 && i < 10 then elem([1, 2, 3, 4, 5 + 1.0, 6, 7, 8, 9, 10]v, i) else 0");
		
	testMainIntegerArgInvalidProgram("def main(int x) int :  elem(update([0]a, 0, [  x ]t ), 0)");
	
	testMainIntegerArgInvalidProgram("def main(int i) int : if i >= 0 && i < 1i0 then elem([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]v, i) else 0");

	// Test circular definitions between named constants and function definitions
	testMainIntegerArgInvalidProgram("TEN = main			def main(int x) : TEN + x");
	
	testMainFloatArgInvalidProgram("struct S { tuple<float, float> a, int b }		 		def f(float x) S : S([x + 2.0, x(f(x), 0).a]t, 1)    		def main(float x) float :  elem(f(x).a, 0)");
	
	testMainFloatArgInvalidProgram("def f(float x) float :	let	float z = 2.0 in x + z       def main(int x) int :  iterate(f, 0)");
//	testMainFloatArgInvalidProgram("def f(float x) float :	let	float z = 2.0 in x + z       def main(int x) int :  iterate(f, 0)	  def main(float x) float : f(x)");
	
	
	testMainFloatArgInvalidProgram("def main(float x) float : elem(   shuffle([1.0, 20, 4.0]v, [2, 3]v)   , 1)");

	testMainIntegerArgInvalidProgram("def main(int i) int : if i >= 0 && i < 10 then elem([1, 2, 3, 4, 5, 6, 7, 8., 9, 10]t, i) else 0");
	testMainIntegerArgInvalidProgram("def main(int i) int : if i >= 0 && i < 10 then elem([1, 2, 3, 4, 5, 6, 7, 8., 9, 10]a, i) else 0");

	// Test type coercion in vector literal changing elem() type
	testMainFloatArgInvalidProgram("def main(int i) int : if i >= 0 && i < 10 then elem([1, 2, 3, 4, 5, 6, 7, 8., 9, 10]v, i) else 0");

	testMainFloatArgInvalidProgram("def mul(vector<float, 4> v, float x) vector<float, 4> : v * [x, x,]v  					def main() float : 	let x = [1.0, 2.0, 3.0, 4.0]v 		y = 10.0 in   mul(x, y).e1");
	
		

	testMainFloatArgInvalidProgram("def main() float : 					let x = [1.0, 2.0, 3.0, 4.0]v 					y = [10.0, 20.0, 30.0, 40.0]v  <1.0 in 					e1(x + y)");

	testMainFloatArgInvalidProgram("def f(array<int, 4> a, int i) int : if inBounds(a, i) elem(a, i) else 0       def main(int i) int : f([1, 2, 3]a, i)");


	// This function has special static global variabl-creating mem-leaking powers.
	testMainFloatArg(
		"def expensiveA(float x) float : cos(x * 0.456 + cos(x))			\n\
		def expensiveB(float x) float : sin(x * 0.345 + sin(x))			\n\
		def main(float x) float: if(x < 0.5, expensiveA(x + 0.145), expensiveB(x + 0.2435))",
		0.2f, cos((0.2f + 0.145f) * 0.456f + cos((0.2f + 0.145f))));	



	// ===================================================================
	// Miscellaneous programs that caused crashes or other errors during fuzz testing
	// ===================================================================

	// max() with vector args with different width
 	testMainFloatArgInvalidProgram("def clamp(vector<float, 46> x, vector<float, 4> lowerbound, vector<float, 4> upperbound) vector<float, 4> : max(lowerbound, min(upperbound, x))    def main(float x) float : x");


	// Test invalidity of repeated struct definition
	testMainFloatArgInvalidProgram("struct Complex { float re, float im }  struct Complex { float rm }   def main(float x) float : x");
	testMainFloatArgInvalidProgram("struct Complex { float re, float im }  struct Complex { float re, float im }   def main(float x) float : x");
	testMainFloatArgInvalidProgram("struct Complex { float re, float im }  struct Complex { float rm }    def f() Complex : Complex(1.0, 2.0)    def main() float :   f().im");

	testMainFloatArgInvalidProgram("struct PolarisationVec { vector<float, 8> e }  		struct PolarisationVec {  string ve }");

//	testMainFloatArg("def main(float x)  : if(x < 10.0, 3, 4)", 1.0f, 3.0f);

	testMainFloatArg("def main(float x) float : let v = [x, x, x, x, x, x, x, x]v in dot(v, v)", 1.f, 8.f, INVALID_OPENCL); // dot() in OpenCL doesn't work with float8s.

	testMainFloatArgInvalidProgram("def g(function<float, float> f, float x) : f(x)");

	testMainFloatArgInvalidProgram("def overload(float x) float : 5.0 				  def overloadedFunc(float x) float : 5.0 	 def f<T>(T x) float: overloadedFunc       def main() float : f(1)");

	testMainFloatArgInvalidProgram("def expensiveA(float x) float : cos(x * 2.0)			 def expensiveA(float x) float : cos(x * 2.0)			 		def main(float x) float: e xpensiveA(x) 		def expensiveA(float x) float : cos(x * 2.0)			 		def main(float x) float: x + expensiveA(x) 		def expensiveA(float x) float : cos(x * 0.456 + cos(x))			 		def expensiveB(float x) float : sin(x * 0.345 + sin(x)).			 		def main(float x) float: if(x < 0.5, expensiveA(x + 0.145), expensiveB(x + 0.2435)) 	def g(float x) float : 8.f             def main(float x) float :  pow(g(x), 2.0) 	def main(float x) float :  let y = (1.0 + 1.0) in pow(y, 3.0) 	def g(float x) float :  pow(2 + x, -(1.0 / 8.0))         def main(float x) float : g(0.5)");

	// Disallow definition of same function (with same signature) twice.
	testMainFloatArgInvalidProgram("def f(float x) : x   def f(float x) : x     def main(float x) float : f(2.0)");

	testMainFloatArgInvalidProgram("def f<T>(T x) : x ()        def main() float : f(2.0)");

	testMainFloatArgInvalidProgram("struct s { float x, float y }						\n\
				  def f<T>(T a, T b) : a + b							\n\
				  def main() float : x(f(s(1, 2), s(3, 4)))");

	//testMainFloatArgInvalidProgram("struct s { float x, float y }	def op_fadd(s a, s b) : s(a.x + b.x, a.y + b.y)		 def f<T>(T a, T b) : a + b		 def main() float : x(f(s(1, 2), s(3, 4)))");

//	testMainFloatArgInvalidProgram("struct s { float x, float y }						 	struct s { float x, float y }						 				  def op_fadd(s a, s b) : s(a.x + b.x, a.y + b.y)		 				  def f<T>(T a, T b) : a + b							 				  def main() float : x(f(s(1, 2), s(3, 4)))");

	testMainFloatArgInvalidProgram("struct s { float x, float y }  	struct s { float x, float y }  				  def op_mul(s a, s b) : s(a.x * b.x, a().y * b.y)  				  def main() float : x(s(2, 3) * s(3, 4))");
	testMainFloatArgInvalidProgram("struct s { float x, float y }   def fop_add(s a, s b) : s(a.x + b.x, a.y + b.y)	 ");

	testMainFloatArgInvalidProgram("#e71 def main(float x) float : x");
	testMainFloatArgInvalidProgram("     n=\\():\"\"     ");
	//testMainFloatArgInvalidProgram("E=\\():4.    def main(float x) float : x");

	// struct s { float x, float y }  	struct s { float x, float y }  				  def op_mul(s a, s b) : s(a.x * b.x, a().y * b.y)  				  def main() float : x(s(2, 3) * s(3, 4))

	testMainFloatArgInvalidProgram("struct s { float x, float y }   def fop_add(s a, s b) : s(a.x + b.x, a.y + b.y)	 ");
	
	testMainFloatArgInvalidProgram(" def f<T>(T a, T b) : a + b	def main() float : x(f(s(1, 2), s(3, 4)))");

	testMainFloatArgInvalidProgram("def main(float x) float : elem(  elem([1.0, 2.0, 3.0, 4.0]a, [2, 3.]v)   , 0)");

	testMainFloatArgInvalidProgram("struct Float4Struct { vector<float, 4> v }  			def sin(Float4Struct f) : Float4Struct(sin < (f.v))		");

	testMainFloatArgInvalidProgram("def f<T>(T x) T : x  ( )   def main() float : f(2.0)");

	testMainFloatArgInvalidProgram("def main() float : let f = makeFunc(2.0, 3.0) in f()");

	testMainFloatArgInvalidProgram("\t\t\t\t\tdef main() float :                            0 \t\t\t\t\tdef main() float :                           \t\t\t\t\tlet f = makeFunc(2.0, 3.0) in                     \t\t\t\t\tf()");

	testMainFloatArgInvalidProgram("\t\t\t\t  def main() float : x(s(2, 3) / s(3, 4)) \t\t\t\t  def main() float : x(s(2, 3) / s(3, 4))");

	testMainFloatArgInvalidProgram("def main(float x) float : b(elem([Pair(1.0, 2.0), Pair(3.0, 4.0)]a, 1))  ");
	
	testMainFloatArgInvalidProgram("def main(float x) float : b(elem([Pair(1.0, 2.0), Pair(3.0, 4.0)]a, 1))  		def main(float x) float : b(elem([Pair(1.0, 2.0), Pair(3.0, 4.0)]a, 1)) ");

	testMainFloatArgInvalidProgram("\t\t\tin\t\t\t\t\t\t\t\t\t\t \t\t\tin\t\t\t\t\t\t\t\t\t\t \t\t\t\telem(a, -1)\t\t\t\t\t\t\t\" \t ");
	



	// ===================================================================
	// Test that recursion is disallowed.
	// ===================================================================
	testMainFloatArgInvalidProgram("def main(float x) float :  main(x)  ");
	testMainFloatArgInvalidProgram("def main(float x) float :  1  def f(int x) int : f(0)  ");

	// Mutual recursion
	testMainFloatArgInvalidProgram("def g(float x) float : f(x)      def f(float x) float : g(x)              def main(float x) float : f(x)");
	
	
	// ===================================================================
	// Test that some programs with invalid syntax fail to compile.
	// ===================================================================
	testMainFloatArgInvalidProgram("def main(float x) float :  x [bleh");


	testMainIntegerArg("def main(int x) int : 10 + (if x < 10 then 1 else 2)", 5, 11);

	testMainIntegerArg("def main(int x) int : if x < 10 then 1 else 2", 5, 1);

	testMainIntegerArg("def main(int x) int : if x < 10 then (if x < 5 then 1 else 2) else (if x < 15 then 3 else 4)", 5, 2);



	// ===================================================================
	// Test named constants
	// ===================================================================
	testMainIntegerArg("TEN = 10			\n\
					   def main(int x) int : TEN + x", 3, 13);

	// Test an expression
	testMainIntegerArg("TEN = 5 * 2			\n\
					   def main(int x) int : TEN + x", 3, 13);

	// Test an expression involving another constant
	testMainIntegerArg("FIVE = 5		TEN = FIVE * 2			\n\
					   def main(int x) int : TEN + x", 3, 13);

	// Make sure constant folding works with named constants
	testMainFloatArgCheckConstantFolded("FIVE = 5.0		TEN = FIVE * 2.0			\n\
					   def main(float x) float : TEN", 3.0f, 10.0f);

	// Test an expression involving a function call
	testMainIntegerArg("def five() int : 5		TEN = five() * 2			\n\
					   def main(int x) int : TEN + x", 3, 13);

	// Test named constants with optional declared type.
	//testMainIntegerArg("int TEN = 10			\n\
	//				   def main(int x) int : TEN + x", 3, 13);
	
	// Test int->float type coercion to match declared type for named constants with optional declared type.
	testMainFloatArg("float TEN = 10			\n\
					   def main(float x) float : TEN + x", 1.f, 11.f);


	// Test with a function call on a structure
	// TODO: make this work
	//testMainFloatArgCheckConstantFolded("struct S { float x }		\n\
	//				 def f(S s) S : S(s.x + 1.0)		\n\
	//				 float X = f(S(1)).x			\n\
	//				 def main(float x) float : X", 1.f, 2.f);

	// test invalidity of two named constants with same name.
	testMainFloatArgInvalidProgram("z = 1     z = 2               def main(float x) float : x");


	// Test named constants that aren't constant
	testMainIntegerArgInvalidProgram("TEN = x			\n\
					   def main(int x) int : TEN + x");

	testMainIntegerArgInvalidProgram("TEN = main			\n\
					   def main(int x) int : TEN + x");
					   
	testMainIntegerArgInvalidProgram("TEN = main()			\n\
					   def main(int x) int : TEN + x");

	// self-reference
	testMainIntegerArgInvalidProgram("TEN = TEN			\n\
					   def main(int x) int : TEN + x");

	// Test invalidity of mutual references between named contants.
	testMainFloatArgInvalidProgram("z = y	y = z      def main(float x) float : x");


	// NOTE: if 'then' token is removed, we get a parse error below.

	testMainIntegerArg("def f(int x) tuple<int> : if x < 0 [1]t else [3]t			\n\
					   def main(int x) int : f(x)[0]", 10, 3);
	// ===================================================================
	// Test array subscript (indexing) operator []
	// ===================================================================

	// NOTE: if 'then' token is removed, we get a parse error below.

	testMainIntegerArg("def f(int x) tuple<int> : if x < 0 [1]t else [3]t			\n\
					   def main(int x) int : f(x)[0]", 10, 3);

	testMainIntegerArg("def f(int x) tuple<int, int> : if x < 0 [1, 2]t else [3, 4]t			\n\
					   def main(int x) int : f(x)[0]", 10, 3);

	// OpenCL doesn't support new array values at runtime, nor fold() currently.
	
	testMainIntegerArg("def main(int x) int : [x]a[0]", 10, 10, INVALID_OPENCL);
	testMainIntegerArg("def main(int x) int : [x, x + 1, x + 2]a[1]", 10, 11, INVALID_OPENCL);
	testMainIntegerArg("def main(int x) int : [x, x + 1, x + 2]a[1 + 1]", 10, 12, INVALID_OPENCL);

	// Test index out of bounds
	testMainIntegerArgInvalidProgram("def main(int x) int :  [x, x + 1, x + 2]a[-1])");
	testMainIntegerArgInvalidProgram("def main(int x) int :  [x, x + 1, x + 2]a[3])");
	
	// ===================================================================
	// Test update()
	// update(CollectionType c, int index, T newval) CollectionType
	// ===================================================================

	testMainIntegerArg("def main(int x) int :  elem(update([0]a, 0, x), 0)", 10, 10, INVALID_OPENCL);

	testMainIntegerArg("def main(int x) int :  elem(update([0, 0]a, 0, x), 0)", 10, 10, INVALID_OPENCL);
	testMainIntegerArg("def main(int x) int :  elem(update([0, 0]a, 0, x), 1)", 10, 0, INVALID_OPENCL);
	testMainIntegerArg("def main(int x) int :  elem(update([0, 0]a, 1, x), 0)", 10, 0, INVALID_OPENCL);
	testMainIntegerArg("def main(int x) int :  elem(update([0, 0]a, 1, x), 1)", 10, 10, INVALID_OPENCL);

	// Test update arg out of bounds
	testMainIntegerArgInvalidProgram("def main(int x) int :  elem(update([]a, 0, x), 0)");
	testMainIntegerArgInvalidProgram("def main(int x) int :  elem(update([0]a, -1, x), 0)");
	testMainIntegerArgInvalidProgram("def main(int x) int :  elem(update([0]a, 1, x), 0)");

	// Test failure to prove valid, since index arg cannot be proven in bounds:
	testMainIntegerArgInvalidProgram("def main(int x) int :  elem(update([0]a, x, x), 0)");


	// ===================================================================
	// Test fold built-in function
	// fold(function<State, T, State> f, array<T> array, State initial_state) State
	// ===================================================================

	testMainIntegerArg("															\n\
		def f(int current_state, int elem) int :									\n\
			current_state + elem													\n\
		def main(int x) int :  fold(f, [0, 1, 2, 3, 4, 5]a, x)", 10, 25, INVALID_OPENCL);
		

	// Test fold built-in function with update
	testMainIntegerArg("															\n\
		def f(array<int, 16> current_state, int elem) array<int, 16> :				\n\
			let																		\n\
				old_count = elem(current_state, elem)								\n\
				new_count = old_count + 1											\n\
			in																		\n\
				update(current_state, elem, new_count)								\n\
		def main(int x) int :  elem(fold(f, [0, 0, 1, 2]a, [0]a16), 1)", 10, 1,
		ALLOW_UNSAFE | INVALID_OPENCL // allow_unsafe_operations
	);


	// If first arg to fold() is bound to global def (f), and bound function f has update() as 'last' function call,
	// and fist arg to update() is first arg to f, then can transform to just setting element on running state.

	// Test fold built-in function with update
	{
		const int len = 256;
		js::Vector<int, 32> vals(len, 0);
		js::Vector<int, 32> b(len, 0);
		js::Vector<int, 32> target_results(len, 0);
		target_results[0] = len;

		testIntArray("																\n\
		def f(array<int, 256> counts, int x) array<int, 256> :			\n\
				update(counts, x, elem(counts, x) + 1)			\n\
		def main(array<int, 256> vals, array<int, 256> initial_counts) array<int, 256>:  fold(f, vals, initial_counts)",
			&vals[0], &b[0], &target_results[0], vals.size(),
			ALLOW_UNSAFE | INVALID_OPENCL // allow_unsafe_operations
		);
	}

	
	// Test fold built-in function with update
	{
		const int len = 256;
		js::Vector<int, 32> vals(len, 0);
		js::Vector<int, 32> b(len, 0);
		js::Vector<int, 32> target_results(len, 0);
		target_results[0] = len;

		testIntArray("																\n\
		def f(array<int, 256> current_state, int elem) array<int, 256> :			\n\
			let																		\n\
				old_count = elem(current_state, elem)								\n\
				new_count = old_count + 1											\n\
			in																		\n\
				update(current_state, elem, new_count)								\n\
		def main(array<int, 256> vals, array<int, 256> b) array<int, 256>:  fold(f, vals, b)",
			&vals[0], &b[0], &target_results[0], vals.size(),
			ALLOW_UNSAFE | INVALID_OPENCL // allow_unsafe_operations
		);
	}

	// ===================================================================
	// Test iterate built-in function
	// ===================================================================

	testMainIntegerArg("															\n\
		def f(int current_state, int iteration) tuple<int, bool> :					\n\
			if iteration >= 100														\n\
				[current_state, false]t # break										\n\
			else																	\n\
				[current_state + 1, true]t											\n\
		def main(int x) int :  iterate(f, 0)", 17, 100, INVALID_OPENCL);

	testMainIntegerArg("struct State { int bound, int i }							\n\
		def f(State current_state, int iteration) tuple<State, bool> :				\n\
			if iteration >= current_state.bound 									\n\
				[State(current_state.bound, current_state.i), false]t # break		\n\
			else																	\n\
				[State(current_state.bound, current_state.i + 1), true]t			\n\
		def main(int x) int :  iterate(f, State(x, 0)).i", 17, 17, INVALID_OPENCL);

	testMainFloatArg("struct State { float i }					\n\
		def f(State current_state, int iteration) tuple<State, bool> :	\n\
			if iteration >= 100									\n\
				[State(current_state.i), false]t # break		\n\
			else												\n\
				[State(current_state.i + 1.0), true]t			\n\
		def main(float x) float :  iterate(f, State(0.0)).i", 1.0f, 100.0f, INVALID_OPENCL);// NOTE: this was actually working with OpenCL until struct pass by ptr.

	// Test iterate with optional invariant data:

	// Test with pass-by-value data (integer 2)
	testMainIntegerArg("															\n\
		def f(int current_state, int iteration, int invariant_data) tuple<int, bool> :					\n\
			if iteration >= 100														\n\
				[current_state, false]t # break										\n\
			else																	\n\
				[current_state + invariant_data, true]t											\n\
		def main(int x) int :  iterate(f, 0, 2)", 17, 200, INVALID_OPENCL);

	// Test with pass-by-reference data (struct)
	testMainIntegerArg("															\n\
		struct s { int x, int y }													\n\
		def f(int current_state, int iteration, s invariant_data) tuple<int, bool> :					\n\
			if iteration >= 100														\n\
				[current_state, false]t # break										\n\
			else																	\n\
				[current_state + invariant_data.x, true]t											\n\
		def main(int x) int :  iterate(f, 0, s(3, 4))", 17, 300, INVALID_OPENCL);

	// Test with two invariant data args pass-by-reference data (struct)
	testMainIntegerArg("															\n\
		struct s { int x, int y }													\n\
		def f(int current_state, int iteration, s invariant_data, int m) tuple<int, bool> :					\n\
			if iteration >= m														\n\
				[current_state, false]t # break										\n\
			else																	\n\
				[current_state + invariant_data.x, true]t											\n\
		def main(int x) int :  iterate(f, 0, s(3, 4), x)", 17, 3 * 17, INVALID_OPENCL);


	// ===================================================================
	// Test tuples
	// ===================================================================
	// Test tuple literals being used immediately with subscript operator.
	testMainFloatArg("def main(float x) float :  [x]t[0]", 1.0f, 1.0f);
	testMainFloatArg("def main(float x) float :  [x + 1.0, x + 2.0]t[1]", 1.0f, 3.0f);

	// Test tuples with a mix of types, and elem() calls on each type
	testMainFloatArg("def main(float x) float :  let t = [x + 1.0, 1]t in t[0] + toFloat(t[1])", 1.0f, 3.0f);

	// Test tuples being returned from a function, with subscript operator.
	testMainFloatArg("def f(float x) tuple<float> : [x]t   \n\
		def main(float x) float :  f(x)[0]", 1.0f, 1.0f);


	// Test tuple literals being used immediately
	testMainFloatArg("def main(float x) float :  elem([x]t, 0)", 1.0f, 1.0f);
	testMainFloatArg("def main(float x) float :  elem([x + 1.0, x + 2.0]t, 1)", 1.0f, 3.0f);

	// Test tuples being returned from a function
	testMainFloatArg("def f(float x) tuple<float> : [x]t   \n\
		def main(float x) float :  elem(f(x), 0)", 1.0f, 1.0f);
	testMainFloatArg("def f(float x) tuple<float, float> : [x, x]t   \n\
		def main(float x) float :  elem(f(x), 0)", 1.0f, 1.0f);
	testMainFloatArg("def f(float x) tuple<float, float> : [x, x + 1.0]t   \n\
		def main(float x) float :  elem(f(x), 1)", 1.0f, 2.0f);

	// Test tuples being passed as a function argument
	testMainFloatArg("def f(tuple<float, float> t) float : elem(t, 1)   \n\
		def main(float x) float :  f([x + 1.0, x + 2.0]t)", 1.0f, 3.0f);


	// Test tuples being passed as a function argument and returned
	testMainFloatArg("def f(tuple<float, float> t) tuple<float, float> : t   \n\
		def main(float x) float :  elem(f([x + 1.0, x + 2.0]t), 1)", 1.0f, 3.0f);

	// Test a tuple with a mixture of types
	testMainFloatArg("def f(float x) tuple<float, int> : [x, 2]t   \n\
		def main(float x) float :  elem(f(x), 0)", 1.0f, 1.0f);

	testMainFloatArg("def f(float x) tuple<float, int, bool> : [x, 2, true]t   \n\
		def main(float x) float :  elem(f(x), 0)", 1.0f, 1.0f);

	// Test nested tuples
	testMainFloatArg("def f(float x) tuple<tuple<float, float>, tuple<float, float>> : [[x, x + 1.0]t, [x + 2.0, x + 3.0]t]t   \n\
		def main(float x) float :  elem(elem(f(x), 1), 0)", 1.0f, 3.0f);

	// Test a structure in a tuple
	testMainFloatArg("struct S { float a, int b }		\n\
		def f(float x) tuple<S, float> : [S(x + 2.0, 1), x]t   \n\
		def main(float x) float :  elem(f(x), 0).a", 1.0f, 3.0f);

	// Test a tuple in a stucture
	testMainFloatArg("struct S { tuple<float, float> a, int b }		\n\
		def f(float x) S : S([x + 2.0, x]t, 1)   \n\
		def main(float x) float :  elem(f(x).a, 0)", 1.0f, 3.0f);


	// Test empty tumple - not allowed.
	testMainFloatArgInvalidProgram("def f(float x) tuple<> : []t   \n\
		def main(float x) float :  elem(f(x), 0)");

	// Test tuple index out of bounds
	testMainFloatArgInvalidProgram("def f(float x) tuple<float, float> : [x, x]t   \n\
		def main(float x) float :  elem(f(x), -1)");
	testMainFloatArgInvalidProgram("def f(float x) tuple<float, float> : [x, x]t   \n\
		def main(float x) float :  elem(f(x), 2)");

	// Test varying index (invalid)
	testMainFloatArgInvalidProgram("def f(float x) tuple<float, float> : [x, x]t   \n\
		def main(float x) float :  elem(f(x), truncateToInt(x))");

	// ===================================================================
	// Test tuples with new parenthesis syntax, e.g. (1, 2, 3)
	// ===================================================================
	// Test tuple literals being used immediately with subscript operator.
	//testMainFloatArg("def main(float x) float :  (x)t[0]", 1.0f, 1.0f);
	testMainFloatArg("def main(float x) float :  (x + 1.0, x + 2.0)[1]", 1.0f, 3.0f);

	// Test tuples with a mix of types, and elem() calls on each type
	testMainFloatArg("def main(float x) float :  let t = (x + 1.0, 1) in t[0] + toFloat(t[1])", 1.0f, 3.0f);

	// Test tuples being returned from a function, with subscript operator.
	//testMainFloatArg("def f(float x) tuple<float> : [x]t   \n\
	//	def main(float x) float :  f(x)[0]", 1.0f, 1.0f);


	// Test tuple literals being used immediately
	//testMainFloatArg("def main(float x) float :  elem([x]t, 0)", 1.0f, 1.0f);
	testMainFloatArg("def main(float x) float :  elem((x + 1.0, x + 2.0), 1)", 1.0f, 3.0f);

	// Test tuples being returned from a function
//	testMainFloatArg("def f(float x) tuple<float> : [x]t   \n\
//		def main(float x) float :  elem(f(x), 0)", 1.0f, 1.0f);
	testMainFloatArg("def f(float x) tuple<float, float> : (x, x)   \n\
		def main(float x) float :  elem(f(x), 0)", 1.0f, 1.0f);
	testMainFloatArg("def f(float x) tuple<float, float> : (x, x + 1.0)   \n\
		def main(float x) float :  elem(f(x), 1)", 1.0f, 2.0f);

	// Test tuples being passed as a function argument
	testMainFloatArg("def f(tuple<float, float> t) float : elem(t, 1)   \n\
		def main(float x) float :  f((x + 1.0, x + 2.0))", 1.0f, 3.0f);

	// Test tuples being passed as a function argument and returned
	testMainFloatArg("def f(tuple<float, float> t) tuple<float, float> : t   \n\
		def main(float x) float :  elem(f((x + 1.0, x + 2.0)), 1)", 1.0f, 3.0f);

	// Test a tuple with a mixture of types
	testMainFloatArg("def f(float x) tuple<float, int> : (x, 2)   \n\
		def main(float x) float :  elem(f(x), 0)", 1.0f, 1.0f);

	testMainFloatArg("def f(float x) tuple<float, int, bool> : (x, 2, true)   \n\
		def main(float x) float :  elem(f(x), 0)", 1.0f, 1.0f);

	// Test nested tuples
	testMainFloatArg("def f(float x) tuple<tuple<float, float>, tuple<float, float>> : ((x, x + 1.0), (x + 2.0, x + 3.0))   \n\
		def main(float x) float :  elem(elem(f(x), 1), 0)", 1.0f, 3.0f);

	// Test a structure in a tuple
	testMainFloatArg("struct S { float a, int b }		\n\
		def f(float x) tuple<S, float> : (S(x + 2.0, 1), x)   \n\
		def main(float x) float :  elem(f(x), 0).a", 1.0f, 3.0f);

	// Test a tuple in a stucture
	testMainFloatArg("struct S { tuple<float, float> a, int b }		\n\
		def f(float x) S : S((x + 2.0, x), 1)   \n\
		def main(float x) float :  elem(f(x).a, 0)", 1.0f, 3.0f);


	// Test empty tumple - not allowed.
	testMainFloatArgInvalidProgram("def f(float x) tuple<> : ()   \n\
		def main(float x) float :  elem(f(x), 0)");

	// Test tuple index out of bounds
	testMainFloatArgInvalidProgram("def f(float x) tuple<float, float> : (x, x)   \n\
		def main(float x) float :  elem(f(x), -1)");
	testMainFloatArgInvalidProgram("def f(float x) tuple<float, float> : (x, x)   \n\
		def main(float x) float :  elem(f(x), 2)");

	// Test varying index (invalid)
	testMainFloatArgInvalidProgram("def f(float x) tuple<float, float> : (x, x)   \n\
		def main(float x) float :  elem(f(x), truncateToInt(x))");







	testMainFloatArg("def main(float x) float :  elem([x, x, x, x]v, 0)", 1.0f, 1.0f);

	// Test int->float type coercion in various ways	

	// Test int->float coercion in an if statement as required for an argument to another function. (truncateToInt in this case).
	// NOTE: this seems to be too hard to do.
	
	// testMainIntegerArg("def main(int x) int : truncateToInt(if(true, 3, 4))", 2, 3);

	// Test int->float coercion in an if statement as required for an argument to another function. ('if' in this case).
	// testMainFloatArg("def main(float x) float : if(false, if(false, 1, 2), 3)", 2.0f, 3.0f);


	// Test int->float coercion for an argument to a built-in function like sqrt
	testMainFloatArg("def main(float x) float : sqrt(4)", 2.0f, 2.0f);
	testMainFloatArg("def main(float x) float : cos(4)", 2.0f, std::cos(4.f));
	testMainFloatArg("def main(float x) float : pow(2, 3)", 2.0f, 8.f);
	testMainFloatArg("def main(float x) float : pow(x, 3)", 2.0f, 8.f);
	testMainFloatArg("def main(float x) float : pow(2, x)", 2.0f, 4.f);

	// Test int->float coercion for an argument to a function
	testMainFloatArg("def f(float x) float : x*x                   def main(float x) float : f(3)", 2.0f, 9.f);
	testMainFloatArg("def f(float x) float : x*x                   def main(float x) float : f(x + 1)", 2.0f, 9.f);
	testMainFloatArg("def f(float x) float : x*x                   def main(float x) float : f(1 + x)", 2.0f, 9.f);
	testMainFloatArg("def f(float x) float : x*x                   def main(float x) float : f(2 * x)", 2.0f, 16.f);
	testMainFloatArg("def f(float x) float : x*x                   def main(float x) float : f(x * 2)", 2.0f, 16.f);
	testMainFloatArg("def f(float x) float : x*x                   def main(float x) float : f(1 / x)", 2.0f, 0.25f);
	testMainFloatArg("def f(float x) float : x + 2.0               def main(float x) float : f(1)", 2.0f, 3.f);
	testMainFloatArg("def f(float x, float y) float : x + y        def main(float x) float : f(1, x)", 2.0f, 3.f);
	testMainFloatArg("def f(float x, float y) float : x + y        def main(float x) float : f(x, 1)", 2.0f, 3.f);

	testMainFloatArg("def main(float x) float : sqrt(2 + x)", 2.0f, 2.0f);

	// Test int->float coercion in an if statement as the function body.
	testMainFloatArg("def main(float x) float : if(true, 3, 4)", 2.0f, 3.0f);
	testMainFloatArg("def main(float x) float : if(x < 10.0, 3, 4)", 2.0f, 3.0f);
	
	testMainFloatArg("def main(float x) float : 3", 2.0f, 3.0f);
	testMainFloatArg("def main(float x) float : 3", 2.0f, 3.0f);

	testMainFloatArg("def main(float x) float : x + 1", 2.0f, 3.0f);
	testMainFloatArg("def main(float x) float : 1 + x", 2.0f, 3.0f);
	testMainFloatArg("def main(float x) float : 2 * (x + 1)", 2.0f, 6.0f);
	testMainFloatArg("def main(float x) float : 2 * (1 + x)", 2.0f, 6.0f);

	testMainFloatArg("def main(float x) float : (1 + x) + (2 + x) * 3", 2.0f, 15.0f);

	// Test type checking for if() statements:
	testMainFloatArgInvalidProgram("def main(float x) float : if(x < 1.0, 3.0, true)");
	testMainFloatArgInvalidProgram("def main(float x) float : if(x < 1.0, true, 3.0)");
	testMainFloatArgInvalidProgram("def main(float x) float : if(3.0, 2.0, 3.0)");

	// Test wrong number of args to if
	testMainFloatArgInvalidProgram("def main(float x) float : if(x < 1.0)");
	testMainFloatArgInvalidProgram("def main(float x) float : if(x < 1.0, 2.0)");
	testMainFloatArgInvalidProgram("def main(float x) float : if(x < 1.0, 2.0, 3.0, 4.0)");

	// Test int->float type coercion for addition operands changing return type of tuple elem()
	testMainFloatArg("def main(float x) float :  elem([0  + 2.0]t, 0)", 1.0f, 2.0f);
	testMainFloatArg("def main(float x) float :  elem([x + 1.0, x, 0  + 2.0]t, 1)", 1.0f, 1.0f);
	testMainFloatArg("def main(float x) float :  elem([x + 1.0, x, 0  - 2.0]t, 1)", 1.0f, 1.0f);
	testMainFloatArg("def main(float x) float :  elem([x + 1.0, x, 0  * 2.0]t, 1)", 1.0f, 1.0f);
	testMainFloatArg("def main(float x) float :  elem([x + 1.0, x, 0  / 2.0]t, 1)", 1.0f, 1.0f);

	// Test function binding based on int->float type coercion
	testMainFloatArg("def f(int i) float : 10.0     def f(float x) float : 20.0     def main(float x) float : f(1 + 2.0)", 1.0f, 20.0f); // 1 op 2.0 should be coerced to float
	testMainFloatArg("def f(int i) float : 10.0     def f(float x) float : 20.0     def main(float x) float : f(1 - 2.0)", 1.0f, 20.0f); // 1 op 2.0 should be coerced to float
	testMainFloatArg("def f(int i) float : 10.0     def f(float x) float : 20.0     def main(float x) float : f(1 * 2.0)", 1.0f, 20.0f); // 1 op 2.0 should be coerced to float
	testMainFloatArg("def f(int i) float : 10.0     def f(float x) float : 20.0     def main(float x) float : f(1 / 2.0)", 1.0f, 20.0f); // 1 op 2.0 should be coerced to float
	testMainFloatArg("def f(int i) float : 10.0     def f(float x) float : 20.0     def main(float x) float : f(1.0 + 2)", 1.0f, 20.0f); // 1.0 op 2 should be coerced to float
	testMainFloatArg("def f(int i) float : 10.0     def f(float x) float : 20.0     def main(float x) float : f(1.0 - 2)", 1.0f, 20.0f); // 1.0 op 2 should be coerced to float
	testMainFloatArg("def f(int i) float : 10.0     def f(float x) float : 20.0     def main(float x) float : f(1.0 * 2)", 1.0f, 20.0f); // 1.0 op 2 should be coerced to float
	testMainFloatArg("def f(int i) float : 10.0     def f(float x) float : 20.0     def main(float x) float : f(1.0 / 2)", 1.0f, 20.0f); // 1.0 op 2 should be coerced to float

	testMainFloatArg("def f(int i) float : 10.0     def f(float x) float : 20.0     def main(float x) float : f(1 + x)", 1.0f, 20.0f); // 1 op x should be coerced to float





	// Test if LLVM combined multiple sqrts into a sqrtps instruction (doesn't do this as of LLVM 3.4)
	testMainFloatArg("def main(float x) float : sqrt(x) + sqrt(x + 1.0) + sqrt(x + 2.0) + sqrt(x + 3.0)", 1.0f, sqrt(1.0f) + sqrt(1.0f + 1.0f) + sqrt(1.0f + 2.0f) + sqrt(1.0f + 3.0f));

	{
		Float4Struct a(1.0f, 2.0, 3.0, 4.0);
		Float4Struct target_result(3.f, 4.f, 5.f, 6.f);
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				Float4Struct(a.v + [2.0]v4)", 
			a, a, target_result
		);
	}

	{
		Float4Struct a(1.0f, 2.0, 3.0, 4.0);
		Float4Struct target_result(2.f, 3.f, 4.f, 5.f);
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				Float4Struct(a.v + [elem(b.v, 0)]v4)", 
			a, a, target_result
		);
	}

	// Check scalar initialisation of vector
	testMainFloatArg("def main(float x) float :  elem(    [2.0]v8    , 5)", 1.0f, 2.0f);

	/*testMainFloatArg(
		"def expensiveA(float x) float : cos(x * 2.0)			\n\
		def main(float x) float: expensiveA(x)",
		0.2f, cos(0.2 * 2.0f));

	testMainFloatArg(
		"def expensiveA(float x) float : cos(x * 2.0)			\n\
		def main(float x) float: x + expensiveA(x)",
		0.2f, 0.2f + cos(0.2 * 2.0f));
*/
	testMainFloatArg(
		//"def expensiveA(float x) float : pow(x, 0.1 + pow(0.2, x))			\n
		"def expensiveA(float x) float : cos(x * 0.456 + cos(x))			\n\
		def expensiveB(float x) float : sin(x * 0.345 + sin(x))			\n\
		def main(float x) float: if(x < 0.5, expensiveA(x + 0.145), expensiveB(x + 0.2435))",
		0.2f, cos((0.2f + 0.145f) * 0.456f + cos((0.2f + 0.145f))));	


	// Check constant folding for a function that is ostensibly a function of several arguments but does not actually depend on them.
	//testMainFloatArg("def g(float x) float : pow(2.0, 3.0)             def main(float x) float :  g(x)",    1.f, 8.f);

	//testMainFloatArg("def g(float x) float : pow(2.0, 3.0)             def main(float x) float :  pow(g(x), 2.0)",    1.f, 64.f);
	testMainFloatArg("def g(float x) float : 8.f             def main(float x) float :  pow(g(x), 2.0)",    1.f, 64.f);

	// Check constant folding for a let variable
	//testMainFloatArg("def main(float x) float :  let y = pow(2.0, 3.0) in y", 1.f, 8.f);

	// Check constant folding for expression involving a let variable
	testMainFloatArgCheckConstantFolded("def main(float x) float :  let y = 2.0 in y", 1.f, 2.f);
	testMainFloatArgCheckConstantFolded("def main(float x) float :  let y = 1.0 + 1.0 in y", 1.f, 2.f);
	testMainFloatArgCheckConstantFolded("def main(float x) float :  let y = (1.0 + 1.0) in pow(y, 3.0)", 1.f, 8.f);
	

	// Check constant folding of a pow function that is inside another function
	testMainFloatArgCheckConstantFolded("def g(float x) float :  pow(2 + x, -(1.0 / 8.0))         def main(float x) float : g(0.5)", 1.f, std::pow(2.f + 0.5f, -(1.0f / 8.0f)));
	
	testMainFloatArgCheckConstantFolded("def g(float x, float y) float : pow(x, y)         def main(float x) float : g(2.0, 3.0)", 1.f, 8.0f);

	// Test promotion to match function return type:  
	// Test in if statement
	// TODO: Get this working testMainFloatArg("def g(float x) float : if x > 1.0 then 2 else 3         def main(float x) float : g(x)", 1.f, 2.f);

	//testMainFloatArg("def g(float x) float : 2         def main(float x) float : g(2)", 1.f, 2.f);


	// Test calling a function that will only be finished / correct when type promotion is done, but will be called during constant folding phase.
	testMainFloatArgCheckConstantFolded("def g(float x) float : 1 / x         def main(float x) float : g(2)", 1.f, 0.5f);
	testMainFloatArg("def g(float x) float : 1 / x         def main(float x) float : g(x)", 4.f, 0.25f);


	// Test calling a function that will only be finished / correct when type promotion is done, but will be called during constant folding phase.
	testMainFloatArgCheckConstantFolded("def g(float x) float : 10 + x         def main(float x) float : g(1)", 2.f, 11.f);

	// Test promotion from int to float
	testMainFloatArg("def main(float x) float : 1 + x", 2.f, 3.f);

	testMainFloatArg("def g(float x) float : x*x         def main(float x) float : g(1 + x)", 2.f, 9.f);


	// Test FMA codegen.
	testMainFloatArg("def main(float x) float : sin(x) + sin(x + 0.02) * sin(x + 0.03)", 0.f, sin(0.f) + sin(0.02f) * sin(0.03f));

	// Unary minus applied to vector:
	// Test with no runtime values
	testMainFloatArg("def main(float x) float : elem(-[1.0, 2.0, 3.0, 4.0]v, 2)", 0.1f, -3.0f);
	testMainIntegerArg("def main(int x) int : elem(-[1, 2, 3, 4]v, 2)", 1, -3);

	// Test with runtime values
	testMainFloatArg("def main(float x) float : elem(-[x + 1.0, x + 2.0, x + 3.0, x + 4.0]v, 2)", 0.4f, -3.4f);
	testMainIntegerArg("def main(int x) int : elem(-[x + 1, x + 2, x + 3, x + 4]v, 2)", 1, -4);

	// Test runtime unary minus of 4-vector
	{
		Float4Struct a(1.0f, 2.0, 3.0, 4.0);
		Float4Struct target_result(-1.0f, -2.0f, -3.0f, -4.0f);
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				Float4Struct(-v(a))", 
			a, a, target_result
		);
	}


	// Vector divide (not supported currently)
	testMainIntegerArgInvalidProgram("def main() float : 					let x = [1.0, 2.0, 3.0, 4.0]v 					y = [10.0, 20.0, 30.0, 40.0]v in 					e1(x/ - y)");


	// Gather load:
	testMainFloatArg("def main(float x) float : elem(  elem([1.0, 2.0, 3.0, 4.0]a, [2, 3]v)   , 0)", 0.1f, 3.0f);

	// Shuffle
	testMainFloatArg("def main(float x) float : elem(   shuffle([1.0, 2.0, 3.0, 4.0]v, [2, 3]v)   , 1)", 0.1f, 4.0f);

	testMainFloatArg("def main(float x) float : elem(   shuffle([x + 1.0, x + 2.0, x + 3.0, x + 4.0]v, [2, 3]v)   , 1)", 0.1f, 4.1f);

	// Test shuffle mask index out of bounds.
	testMainFloatArgInvalidProgram("def main(float x) float : elem(   shuffle([x + 1.0, x + 2.0, x + 3.0, x + 4.0]v, [2, 33]v)   , 1)     def main(float x) float : x");
 

	// Test a shuffle where the mask is invalid - a float
	testMainFloatArgInvalidProgram("def main(float x) float : elem(   shuffle([1.0, 2.0, 3.0, 4.0]v, [2, 3.0]v)   , 1)");

	// Test a shuffle where the mask is invalid - not a constant
	testMainIntegerArgInvalidProgram("def main(int x) int : elem(   shuffle([1.0, 2.0, 3.0, 4.0]v, [2, x]v)   , 1)");

	

	// Test returning a structure from a function that is called inside an if expression
	testMainIntegerArg(
		"struct teststruct { int y }										\n\
		def f() teststruct : teststruct(1)						\n\
		def g() teststruct : teststruct(2)						\n\
		def main(int x) int : y( if x < 5 then f() else g() ) ",
		2, 1);

	// Test returning a structure from a function that takes a structure and that is called inside an if expression
	testMainIntegerArg(
		"struct teststruct { int y }										\n\
		def f(teststruct s) teststruct : teststruct(1 + y(s))						\n\
		def g(teststruct s) teststruct : teststruct(2 + y(s))						\n\
		def main(int x) int : y( if x < 5 then f(teststruct(1)) else g(teststruct(2)) ) ",
		2, 2);



	// Test a function (f) that just returns an arg directly
	testMainIntegerArg(
		"struct teststruct { int y }										\n\
		def f(teststruct a, teststruct b, bool condition) teststruct : a      \n\
		def main(int x) int : y( f(teststruct(1), teststruct(2), x < 5) ) ",
		2, 1);

	// Test a function (f) that just returns a new struct
	testMainIntegerArg(
		"struct teststruct { int y }										\n\
		def f(teststruct a, teststruct b, bool condition) teststruct : teststruct(1)      \n\
		def main(int x) int : y( f(teststruct(1), teststruct(2), x < 5) ) ",
		2, 1);

	// Test a function (f) that is just an if expression that returns pass-by-reference arguments directly.
	testMainIntegerArg(
		"struct teststruct { int y }										\n\
		def f(teststruct a, teststruct b, bool condition) teststruct : if(condition, a, b)      \n\
		def main(int x) int : y( f(teststruct(1), teststruct(2), x < 5) ) ",
		2, 1);


	// Test a function (f) that is just an if expression that returns pass-by-reference arguments directly, in a let block
	testMainIntegerArg(
		"struct teststruct { int y }										\n\
		def f(teststruct a, teststruct b, bool condition) teststruct :      \n\
			let																\n\
				x = if(condition, a, b)										\n\
			in																\n\
				x															\n\
		def main(int x) int : y( f(teststruct(1), teststruct(2), x < 5) ) ",
		2, 1);

	// Test a function (f) that is just an if expression that returns pass-by-reference arguments directly, in a let block
	testMainIntegerArg(
		"struct teststruct { int y }										\n\
		def f(teststruct a, teststruct b, bool condition) teststruct :      \n\
			let																\n\
				x = teststruct( y(if(condition, a, b))	)									\n\
			in																\n\
				x															\n\
		def main(int x) int : y( f(teststruct(1), teststruct(2), x < 5) ) ",
		2, 1);


	testMainIntegerArg(
		"struct teststruct { int y }										\n\
		def g(teststruct a, teststruct b, bool condition) teststruct : if(condition, a, b)      \n\
		def f(teststruct a, teststruct b, bool condition) teststruct : if(condition, g(a, b, condition), g(a, b, condition))      \n\
		def main(int x) int : y( f(teststruct(1), teststruct(2), x < 5) ) ",
		2, 1);

	// truncateToInt with runtime args, with bounds checking
	testMainFloatArg("def main(float x) float : toFloat(if x >= -2147483648.0 && x < 2147483647.0 then truncateToInt(x) else 0)", 3.1f, 3.0f);

	// truncateToInt with constant value
	testMainFloatArg("def main(float x) float : toFloat(truncateToInt(3.1))", 3.1f, 3.0f);

	// Test truncateToInt where we can't prove the arg is in-bounds.
//TEMP	testMainFloatArgInvalidProgram("def main(float x) float : toFloat(truncateToInt(x))", 3.9f, 3.0f);



	

	// Test division by -1 where we prove the numerator is not INT_MIN
	/*testMainIntegerArg(
		"def main(int i) int : if i > 1 then 2 else 0", 
		8, -8);*/


	testMainIntegerArg("def div(int x, int y) int : if(y != 0 && x != -2147483648, x / y, 0)	\n\
					   def main(int i) int : div(i, i)",    
		5, 1);
	testMainIntegerArg("def main(int i) int : if i != 0 && i != -1 then i / i else 0",    
		5, 1);


	// Do a test where a division by zero would be done while constant folding.
	testMainFloatArgInvalidProgram("def f(int x) int : x*x	      def main(float x) float : 14 / (f(2) - 4)");

	testMainFloatArg("def f(int x) int : x*x	      def main(float x) float : 14 / (f(2) + 2)", 2.0f, 2.0f);

	//testMainFloatArg("def f(int x) int : x*x	      def main(float x) float : f(2) + 3", 1.0f, 7.0f);
	testMainFloatArg("def f(int x) int : x*x	      def main(float x) float : 14 / (f(2) + 3)", 2.0f, 2.0f);

	// Test division by -1 where we prove the numerator is not INT_MIN
	testMainIntegerArg(
		"def main(int i) int : if i > -10000 then i / -1 else 0", 
		8, -8);

	// Test division where numerator = INT_MIN where we prove the denominator is not -1
	testMainIntegerArg(
		"def main(int i) int : if i >= 1 then -2147483648 / i else 0", 
		2, -1073741824);

	// Test division by -1 where we can't prove the numerator is not INT_MIN
	testMainIntegerArgInvalidProgram(
		"def main(int i) int : i / -1"
	);


	// Test division by a constant
	testMainIntegerArg(
		"def main(int i) int : i / 4", 
		8, 2);

	// Test division by zero
	testMainIntegerArgInvalidProgram(
		"def main(int i) int : i / 0"
	);


	// Test division by a runtime value
	testMainIntegerArg(
		"def main(int i) int : if i != 0 then 8 / i else 0", 
		4, 2);



	// Test array in array
/*	
	TEMP NOT SUPPORTED IN OPENCL YET
	testMainIntegerArg(
		"def main(int i) int : if i >= 0 && i < 2 then elem(elem([[1, 2]a, [3, 4]a]a, i), i) else 0", 
		1, 4);
		*/

	// Test integer in-bounds runtime index access to array
	testMainIntegerArg(
		"def main(int i) int : if i >= 0 && i < 10 then elem([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]a, i) else 0", 
		2, 3);


	// Test integer in-bounds runtime index access to vector
	/*	
	TEMP NOT SUPPORTED IN OPENCL YET
	testMainIntegerArg(
		"def main(int i) int : if i >= 0 && i < 10 then elem([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]v, i) else 0", 
		2, 3);
		*/
	// ===================================================================
	// Test array access with elem()
	// ===================================================================
	// Test integer in-bounds constant index access to array
	testMainIntegerArg(
		"def main(int i) int :						\n\
			let										\n\
				a = [1, 2, 3, 4]a					\n\
			in										\n\
				elem(a, 1)							",
		1, 2);

	// Test integer out-of-bounds constant index access to array
	testMainIntegerArgInvalidProgram(
		"def main(int i) int :						\n\
			let										\n\
				a = [1, 2, 3, 4]a					\n\
			in										\n\
				elem(a, -1)							"
	);

	// Test integer in-bounds runtime index access to array  (let clause)
	testMainIntegerArg(
		"def main(int i) int :						\n\
			let										\n\
				a = [1, 2, 3, 4]a					\n\
			in										\n\
				if inBounds(a, i)					\n\
					elem(a, i)						\n\
				else								\n\
					0								",
		1, 2);

	// Test integer in-bounds runtime index access to array (function arg var)
	testMainIntegerArg(
		"def f(array<int, 4> a, int i) int :		\n\
			if inBounds(a, i)						\n\
				elem(a, i)							\n\
			else									\n\
				0									\n\
		def main(int i) int :						\n\
			f([1, 2, 3, 4]a, i)",
		1, 2);

	// Test integer out-of-bounds runtime index access to array
	testMainIntegerArg(
		"def main(int i) int :						\n\
			let										\n\
				a = [1, 2, 3, 4]a					\n\
			in										\n\
				if inBounds(a, i)					\n\
					elem(a, i)						\n\
				else								\n\
					0								",
		-1, 0);

	// Test integer out-of-bounds runtime index access to array (function arg var)
	testMainIntegerArg(
		"def f(array<int, 4> a, int i) int :		\n\
			if inBounds(a, i)						\n\
				elem(a, i)							\n\
			else									\n\
				0									\n\
		def main(int i) int :						\n\
			f([1, 2, 3, 4]a, i)",
		-1, 0);


	// ===================================================================
	// Test vector access with elem()
	// ===================================================================
	// Test integer in-bounds constant index access to vector
	testMainIntegerArg(
		"def main(int i) int :						\n\
			let										\n\
				a = [1, 2, 3, 4]v					\n\
			in										\n\
				elem(a, 1)							",
		1, 2);

	// Test integer out-of-bounds constant index access to vector
	testMainIntegerArgInvalidProgram(
		"def main(int i) int :						\n\
			let										\n\
				a = [1, 2, 3, 4]v					\n\
			in										\n\
				elem(a, -1)							"
		);

/*	
	TEMP NOT SUPPORTED IN OPENCL YET
	// Test integer in-bounds runtime index access to vector
	testMainIntegerArg(
		"def main(int i) int :						\n\
			let										\n\
				a = [1, 2, 3, 4]v					\n\
			in										\n\
				if inBounds(a, i)					\n\
					elem(a, i)						\n\
				else								\n\
					0								",
		1, 2);
		
	// Test integer out-of-bounds runtime index access to vector
	testMainIntegerArg(
		"def main(int i) int :						\n\
			let										\n\
				a = [1, 2, 3, 4]v					\n\
			in										\n\
				if inBounds(a, i)					\n\
					elem(a, i)						\n\
				else								\n\
					0								",
		-1, 0);
*/
	/*testMainIntegerArg(
		"def main(int i) int :						\n\
			match x = elem([1, 2, 3, 4]a, i)		\n\
				int: x								\n\
				error: 0							",
		1, 2);*/

	// Test integer out-of-bounds runtime index access
	/*testMainIntegerArg(
		"def main(int i) int :						\n\
			match x = elem([1, 2, 3, 4]a, i)		\n\
				int: x								\n\
				error: 0							",
		100, 0);*/



	/*float x = 2.0f;
	float y = (x + x) -1.5;*/

	// Test divide-by-zero
	//testMainIntegerArg("def main(int x) int : 10 / x ", 0, 10);

	// ===================================================================
	// Test if-then-else
	// ===================================================================
	testMainIntegerArg("def main(int x) int : if x < 5 then 10 else 5 ", 2, 10);
	testMainIntegerArg("def main(int x) int : if x < 5 then 10 else 5 ", 6, 5);

	testMainIntegerArg("def main(int x) int : if (x < 5) then 10 else 5 ", 6, 5);
	testMainIntegerArg("def main(int x) int : if (x * 2) < 5 then 10 else 5 ", 6, 5);

	// Test without optional 'then'
	testMainIntegerArg("def main(int x) int : if x < 5 10 else 5 ", 2, 10);
	testMainIntegerArg("def main(int x) int : if x < 5 10 else 5 ", 6, 5);
	testMainIntegerArg("def main(int x) int : if (x < 5) 10 else 5 ", 6, 5);
	testMainIntegerArg("def main(int x) int : if (x * 2) < 5 10 else 5 ", 6, 5);

	// Test nested if-then-else
	testMainIntegerArg("def main(int x) int : if x < 5 then if x < 2 then 1 else 2 else 5 ", 1, 1);
	testMainIntegerArg("def main(int x) int : if x < 5 then if x < 2 then 1 else 2 else 5 ", 2, 2);
	testMainIntegerArg("def main(int x) int : if x < 5 then if x < 2 then 1 else 2 else 5 ", 10, 5);
	testMainIntegerArg("def main(int x) int : if (x < 5) then if x < 2 then 1 else 2 else 5 ", 10, 5); // Test with parens
	testMainIntegerArg("def main(int x) int : if x < 5 then if (x < 2) then 1 else 2 else 5 ", 10, 5); // Test with parens

	// Test nested if-then-else without the 'then'
	testMainIntegerArg("def main(int x) int : if x < 5 if x < 2 1 else 2 else 5 ", 1, 1);
	testMainIntegerArg("def main(int x) int : if x < 5 if x < 2 1 else 2 else 5 ", 2, 2);
	testMainIntegerArg("def main(int x) int : if x < 5 if x < 2 1 else 2 else 5 ", 10, 5);

	testMainIntegerArg("def main(int x) int :			\n\
								if x < 5				\n\
									if x < 3			\n\
										1				\n\
									else				\n\
										2				\n\
								else					\n\
									if x < 7			\n\
										6				\n\
									else				\n\
										7				\n\
		", 10, 7);

	// Test nested if-then-else with parentheses
	testMainIntegerArg("def main(int x) int : if x < 5 then (if x < 2 then 1 else 2) else 5 ", 1, 1);
	testMainIntegerArg("def main(int x) int : if x < 5 then (if x < 2 then 1 else 2) else 5 ", 2, 2);
	testMainIntegerArg("def main(int x) int : if x < 5 then (if x < 2 then 1 else 2) else 5 ", 10, 5);



	// Test if expression with a structure
	testMainIntegerArg("struct S { int a }     def main(int x) int : (if x < 4 then S(x + 1) else S(x + 2)).a ", 10, 12);

	// Test if expression with a structure passed as an argument
	testMainIntegerArg("struct S { int a }     def f(int x, S a, S b) S : if x < 4 then a else b      def main(int x) int : f(x, S(x + 1), S(x + 2)).a ", 10, 12);


	// ===================================================================
	// Ref counting tests
	// ===================================================================
	// Test putting a string in a structure, then returning it.
	testMainIntegerArg(
		"struct teststruct { string str }										\n\
		def f() teststruct : teststruct(\"hello world\")						\n\
		def main(int x) int : stringLength(str(f())) ",
		2, 11, INVALID_OPENCL);

	// Test a string in a structure
	testMainIntegerArg(
		"struct teststruct { string str }										\n\
		def main(int x) int : stringLength(teststruct(\"hello world\").str) ",
		2, 11, INVALID_OPENCL);

	
	// ===================================================================
	// String tests
	// ===================================================================

	// String test - string literal in let statement, with assignment.
	testMainIntegerArg(
		"def main(int x) int : stringLength(concatStrings(\"hello\", \"world\"))",
		2, 10, INVALID_OPENCL);

	// Double return of a string
	testMainIntegerArg(
		"def f() string : \"hello world\"	\n\
		def g() string : f()				\n\
		def main(int x) int : stringLength(g())",
		2, 11, INVALID_OPENCL);
	

	

	// String test - string literal in let statement, with assignment.
	testMainIntegerArg(
		"def main(int x) int :				\n\
			let								\n\
				s = \"hello world\"			\n\
				s2 = s						\n\
			in								\n\
				stringLength(s) + stringLength(s2)",
		2, 22, INVALID_OPENCL);

	// String test - string literal in let statement, with assignment.
	testMainIntegerArg(
		"def main(int x) int :				\n\
			let								\n\
				s = \"hello world\"			\n\
				s2 = \"hallo thar\"			\n\
			in								\n\
				stringLength(s) + stringLength(s2)",
		2, 21, INVALID_OPENCL);

	// a function returning a string
	testMainIntegerArg(
		"def f() string : \"hello world\"	\n\
		def main(int x) int : stringLength(f())",
		2, 11, INVALID_OPENCL);

	// a function returning a string in a let block
	testMainIntegerArg(
		"def f() string : \"hello world\"	\n\
		def main(int x) int :				\n\
			let								\n\
				s = f()						\n\
			in								\n\
				stringLength(s)",
		2, 11, INVALID_OPENCL);

	// String test - string literal in let statement
	testMainIntegerArg(
		"def main(int x) int :				\n\
			let								\n\
				s = \"hello world\"			\n\
			in								\n\
				stringLength(s)",
		2, 11, INVALID_OPENCL);

	// String test - string literal as argument
	testMainIntegerArg(
		"def main(int x) int :				\n\
				stringLength(\"hello world\")",
		2, 11, INVALID_OPENCL);

	// String test - string literal in let statement, with assignment.
	testMainIntegerArg(
		"def main(int x) int :				\n\
			let								\n\
				s = \"hello world\"			\n\
				s2 = s						\n\
			in								\n\
				stringLength(s2)",
		2, 11, INVALID_OPENCL);

	// Char test
	/*testMainIntegerArg(
		"def main(int x) int :				\n\
			let								\n\
				c = 'a'						\n\
			in								\n\
				10",
		2, 10);*/


	// test type coercion on vectors: vector<float> initialisation with some int elems
	testMainFloatArg(
		"def main(float x) float: elem(   2.0 * [1.0, 2.0, 3, 4]v, 1)",
		1.0f, 4.0f);

	// float * Vector<float> multiplication
	testMainFloatArg(
		"def main(float x) float: elem(   2.0 * [1.0, 2.0, 3.0, 4.0]v, 1)",
		1.0f, 4.0f);

	// Vector<float> * float multiplication
	testMainFloatArg(
		"def main(float x) float: elem(   [1.0, 2.0, 3.0, 4.0]v * 2.0, 1)",
		1.0f, 4.0f);

	// int * Vector<int> multiplication
	testMainIntegerArg(
		"def main(int x) int: elem(   2 * [1, 2, 3, 4]v, 1)",
		1, 4);

	// Vector<int> * int multiplication
	testMainIntegerArg(
		"def main(int x) int: elem(   [1, 2, 3, 4]v * 2, 1)",
		1, 4);


	// float * Vector<float> multiplication
	testMainFloatArg(
		"def main(float x) float: elem(   x * [x, 2.0, 3.0, 4.0]v, 1)",
		2.0f, 4.0f);

	// Vector<float> * float multiplication
	testMainFloatArg(
		"def main(float x) float: elem(   [1.0, 2.0, 3.0, 4.0]v * x, 1)",
		2.0f, 4.0f);

	// int * Vector<int> multiplication
	testMainIntegerArg(
		"def main(int x) int: elem(   x * [1, 2, 3, 4]v, 1)",
		2, 4);

	// Vector<int> * int multiplication
	testMainIntegerArg(
		"def main(int x) int: elem(   [1, 2, 3, 4]v * x, 1)",
		2, 4);

	


	// Test integer in-bounds runtime index access to vector
	/*testMainIntegerArg(
		"def main(int i) int :								\n\
			let												\n\
				a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]v		\n\
				b = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]v		\n\
			in												\n\
				elem(a + b, i)",
		2, 4);

	

	// Test integer in-bounds runtime index access to vector
	testMainIntegerArg(
		"def main(int i) int :								\n\
			let												\n\
				a = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]v		\n\
				b = [1.0, 1.6, 1.0, 1.0, 1.3, 1.6, 1.8, 1.6]v		\n\
				c = [1.7, 2.8, 3.0, 4.7, 5.5, 6.7, 7.0, 8.4]v		\n\
			in												\n\
				truncateToInt(elem(a + if(i < 1, b, c), i))",
		2, 6);

	//exit(1);//TEMP

	// Test integer in-bounds runtime index access to vector
	testMainIntegerArg(
		"def main(int i) int :								\n\
			let												\n\
				a = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]v		\n\
				b = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ]v		\n\
				c = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]v		\n\
			in												\n\
				truncateToInt(elem(a + if(i < 1, b, c), i))",
		2, 6);
		*/
	

	// Test integer in-bounds runtime index access to vector
/*TEMP NO OPENCL
	testMainIntegerArg(
		"def main(int i) int : if i >= 0 && i < 10 then elem([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]v, i) else 0", 
		2, 3);
		*/

	testMainFloatArg(
		"def main(float x) float: elem( if(x < 0.5, [1.0, 2.0]a, [3.0, 4.0]a), 0)",
		1.0f, 3.0f, INVALID_OPENCL);
	
	// Test a structure composed of another structure, and taking the dot product of two vectors in the child structures, in an if statement
	{
		Float4StructPair a(
			Float4Struct(1, 1, 1, 1),
			Float4Struct(2, 2, 2, 2)
		);
		
		testFloat4StructPairRetFloat(
			"struct Float4Struct { vector<float, 4> v }			\n\
			struct Float4StructPair { Float4Struct a, Float4Struct b }			\n\
			def main(Float4StructPair pair1, Float4StructPair pair2) float :			\n\
				if(e0(pair1.a.v) < 0.5, dot(pair1.a.v, pair2.b.v), dot(pair1.b.v, pair2.a.v))",
			a, a, 8.0f);
	}

	// Test a structure composed of another structure, and taking the dot product of two vectors in the child structures.
	{
		Float4StructPair a(
			Float4Struct(1, 1, 1, 1),
			Float4Struct(2, 2, 2, 2)
		);
		
		testFloat4StructPairRetFloat(
			"struct Float4Struct { vector<float, 4> v }			\n\
			struct Float4StructPair { Float4Struct a, Float4Struct b }			\n\
			def main(Float4StructPair pair1, Float4StructPair pair2) float :			\n\
				dot(pair1.a.v, pair2.b.v)",
			a, a, 8.0f);
	}


	

	// Test if with expensive-to-eval args
	testMainFloatArg(
		//"def expensiveA(float x) float : pow(x, 0.1 + pow(0.2, x))			\n
		"def expensiveA(float x) float : cos(x * 0.456 + cos(x))			\n\
		def expensiveB(float x) float : sin(x * 0.345 + sin(x))			\n\
		def main(float x) float: if(x < 0.5, expensiveA(x + 0.145), expensiveB(x + 0.2435))",
		0.2f, cos((0.2f + 0.145f) * 0.456f + cos((0.2f + 0.145f))));	


/*
TEMP OPENCL
	// Test operator overloading (op_add) for an array
	testMainFloatArg(
		"def op_add(array<float, 2> a, array<float, 2> b) array<float, 2> : [elem(a, 0) + elem(b, 0), elem(a, 1) + elem(b, 1)]a		\n\
		def main(float x) float: elem([1.0, 2.0]a  + [3.0, 4.0]a, 1)",
		1.0f, 6.0f);	

	// Test operator overloading (op_mul) for an array
	testMainFloatArg(
		"def op_mul(array<float, 2> a, float x) array<float, 2> : [elem(a, 0) * x, elem(a, 1) * x]a		\n\
		def main(float x) float: elem([1.0, 2.0]a * 2.0, 1)",
		1.0f, 4.0f);	

	
	// Test array in array
	testMainIntegerArg(
		"def main(int i) int : if i >= 0 && i < 2 then elem(elem([[1, 2]a, [3, 4]a]a, i), i) else 0", 
		1, 4);

	// Test struct in array
	testMainIntegerArg(
		"struct Pair { int a, int b }		\n\
		def main(int i) int : if i >= 0 && i < 2 then b(elem([Pair(1, 2), Pair(3, 4)]a, i)) else 0 ", 
		1, 4);
*/

	testMainIntegerArg(
		"def main(int i) int : if i >= 0 && i < 5 then elem([1, 2, 3, 4, 5]a, i) else 0", 
		1, 2);
		
	// Test integer in-bounds runtime index access
	testMainIntegerArg(
		"def main(int i) int : if i >= 0 && i < 20 then elem([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]a, i) else 0", 
		10, 11);

	// Test integer in-bounds runtime index access
	for(int i=0; i<5; ++i)
	{
		testMainIntegerArg(
			"def main(int i) int : if i >= 0 && i < 5 then elem([1, 2, 3, 4, 5]a, i) else 0", 
			i, i+1);
	}

	// Test integer in-bounds runtime index access
	testMainIntegerArg(
		"def main(int i) int : if i >= 0 && i < 4 then elem([1, 2, 3, 4]a, i) else 0", 
		1, 2);

	// Test runtime out of bounds access.  Should return 0.
	if(false)
	{
		testMainIntegerArg(
			"def main(int i) int : elem([1, 2, 3, 4]a, i)", 
			-1, 0);

		testMainIntegerArg(
			"def main(int i) int : elem([1, 2, 3, 4]a, i)", 
			4, 0);

		// Test out of bounds array access
		testMainFloatArg(
			"def main(float x) float : elem([1.0, 2.0, 3.0, 4.0]a, 4)", 
			10.0, std::numeric_limits<float>::quiet_NaN());

		testMainFloatArg(
			"def main(float x) float : elem([1.0, 2.0, 3.0, 4.0]a, -1)", 
			10.0, std::numeric_limits<float>::quiet_NaN());
	}

	



	

	// Test float arrays getting passed in to and returned from main function
	{
		const float a[] = {1.0f, 2.0f, 3.0f, 4.0f};
		const float b[] = {10.0f, 20.0f, 30.0f, 40.0f};
		float target_results[] = {1.0f, 2.0f, 3.0f, 4.0f};

		testFloatArray("def main(array<float, 4> a, array<float, 4> b) array<float, 4> : a",
			a, b, target_results, 4);
	}

	// Test map
	{
		const float a[] = {1.0f, 2.0f, 3.0f, 4.0f};
		const float b[] = {10.0f, 20.0f, 30.0f, 40.0f};
		float target_results[] = {1.0f, 4.0f, 9.0f, 16.0f};

		testFloatArray(
			"def square(float x) float : x*x			\n\
			def main(array<float, 4> a, array<float, 4> b) array<float, 4> : map(square, a)",
			a, b, target_results, 4);
	}

	// Test map from one element type to another
	{
		const float a[] = {1.0f, 2.0f, 3.0f, 4.0f};
		const float b[] = {10.0f, 20.0f, 30.0f, 40.0f};
		float target_results[] = {1.0f, 2.0f, 3.0f, 4.0f};

		testFloatArray(
			"def squareToInt(float x) int : truncateToInt(x*x + 0.000001)			\n\
			def sqrtToFloat(int i) float : sqrt(toFloat(i))							\n\
			def main(array<float, 4> a, array<float, 4> b) array<float, 4> : map(sqrtToFloat, map(squareToInt, a))",
			a, b, target_results, 4);
	}

	// Test map with more elems
	{
		const size_t N = 256;
		std::vector<float> input(N, 2.0f);
		std::vector<float> target_results(N, 4.0f);


		testFloatArray(
			"def square(float x) float : x*x			\n\
			def main(array<float, 256> a, array<float, 256> b) array<float, 256> : map(square, a)",
			&input[0], &input[0], &target_results[0], N);
	}


	// Test float arrays getting passed in to and returned from main function
	{
		const float a[] = {1.0f, 2.0f, 3.0f, 4.0f};
		const float b[] = {10.0f, 20.0f, 30.0f, 40.0f};
		float target_results[] = {11.f, 22.f, 33.f, 44.f};

		testFloatArray("def main(array<float, 4> a, array<float, 4> b) array<float, 4> : [elem(a,0) + elem(b,0), elem(a,1) + elem(b,1), elem(a,2) + elem(b,2), elem(a,3) + elem(b,3)]a",
			a, b, target_results, 4);
	}



	

	// Test structure getting returned directly.
	{
		Float4Struct a(1.0f, -2.0f, 3.0f, -4.0f);
		Float4Struct target_result(1.0f, -2.0f, 3.0f, -4.0f);
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				a", 
			a, a, target_result
		);
	}


	

	// Test Array of structs
	testMainFloatArg(
		"struct Pair { float a, float b }		\n\
		def main(float x) float : b(elem([Pair(1.0, 2.0), Pair(3.0, 4.0)]a, 1)) ", 
		10.0, 4.0f, INVALID_OPENCL);
	
	// Test mixing of int and float in an array - is invalid
	testMainFloatArgInvalidProgram("def main(float x) float : elem([1.0, 2, 3.0, 4.0]a, 1) + x");
	testMainFloatArgInvalidProgram("def main(float x) float : elem([1, 2.0, 3.0, 4.0]a, 1) + x");

	// Test Array Literal
	testMainFloatArg("def main(float x) float : elem([1.0, 2.0, 3.0, 4.0]a, 1) + x", 10.0, 12.f);

	// Test Array Literal with one element
	testMainFloatArg("def main(float x) float : elem([1.0]a, 0) + x", 10.0, 11.f);

	/*
TEMP OPENCL
	// Test Array Literal with non-const value
	testMainFloatArg("def main(float x) float : elem([x, x, x, x]a, 1) + x", 1.0, 2.f);
	testMainFloatArg("def main(float x) float : elem([x, x+1.0, x+2.0, x+3.0]a, 2)", 1.0, 3.f);
	*/
	
	// Test Array Literal of integers
	testMainIntegerArg("def main(int x) int : elem([1, 2, 3, 4]a, 1) + x", 10, 12);


	// Test array with let statement
	testMainFloatArg(
		"def main(float x) float :				\n\
			let									\n\
				a = [1.0, 2.0, 3.0, 4.0]a		\n\
			in									\n\
				elem(a, 0)",
		0.0f, 1.0f);

	// Passing array by argument
	testMainFloatArg(
		"def f(array<float, 4> a) float : elem(a, 1)		\n\
		def main(float x) float :						\n\
			f([1.0, 2.0, 3.0, 4.0]a) +  x",
		10.0f, 12.0f);


	// abs
	testMainFloatArg("def main(float x) float : abs(x)", 9.0f, 9.0f);
	testMainFloatArg("def main(float x) float : abs(x)", -9.0f, 9.0f);


	// Test abs on vector
	{
		Float4Struct a(1.0f, -2.0f, 3.0f, -4.0f);
		Float4Struct target_result(1.0f, 2.0f, 3.0f, 4.0f);
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def abs(Float4Struct f) : Float4Struct(abs(f.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				abs(a)", 
			a, a, target_result
		);
	}

	// TODO: abs for integers


	//testMainFloatArg("def main(float x) float : someFuncBleh(x)", 9.0f, 10.0f);

	// truncateToInt
	//testMainIntegerArg("def main(int x) int : truncateToInt(toFloat(x) + 0.2)", 3, 3);
	//testMainIntegerArg("def main(int x) int : truncateToInt(toFloat(x) + 0.2)", -3, -2);

	// Test truncateToInt on vector
/*	
TODO: FIXME: needs truncateToInt in bounds proof.
	{
		Float4Struct a(-2.2f, -1.2f, 0.2f, 1.2f);
		Float4Struct target_result(-2.f, -1.f, 0.f, 1.f);
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def sqrt(Float4Struct f) : Float4Struct(sqrt(f.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				let													\n\
					vec_int = truncateToInt(a.v)					\n\
				in													\n\
					Float4Struct(toFloat(vec_int))",
			a, a, target_result
		);
	}
*/

	// sqrt
	testMainFloatArg("def main(float x) float : sqrt(x)", 9.0f, std::sqrt(9.0f));
	testMainFloatArgCheckConstantFolded("def main(float x) float : sqrt(9)", 9.0f, std::sqrt(9.0f));
	testMainFloatArgCheckConstantFolded("def main(float x) float : sqrt(9.0)", 9.0f, std::sqrt(9.0f));

	// Test sqrt on vector
	{
		Float4Struct a(1.0f, 2.0f, 3.0f, 4.0f);
		Float4Struct target_result(std::sqrt(1.0f), std::sqrt(2.0f), std::sqrt(3.0f), std::sqrt(4.0f));
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def sqrt(Float4Struct f) : Float4Struct(sqrt(f.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				sqrt(a)", 
			a, a, target_result
		);
	}

	// pow
	testMainFloatArg("def main(float x) float : pow(2.4, x)", 3.0f, std::pow(2.4f, 3.0f));
	testMainFloatArg("def main(float x) float : pow(2.0, x)", 3.0f, std::pow(2.0f, 3.0f));
	testMainFloatArgCheckConstantFolded("def main(float x) float : pow(2.0, 3.0)", 3.0f, std::pow(2.0f, 3.0f));

	// Test pow on vector
	{
		Float4Struct a(1.0f, 2.0f, 3.0f, 4.0f);
		Float4Struct b(1.4f, 2.4f, 3.4f, 4.4f);
		Float4Struct target_result(std::pow(1.0f, 1.4f), std::pow(2.0f, 2.4f), std::pow(3.0f, 3.4f), std::pow(4.0f, 4.4f));
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def pow(Float4Struct a, Float4Struct b) : Float4Struct(pow(a.v, b.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				pow(a, b)", 
			a, b, target_result
		);
	}

	// sin
	testMainFloatArg("def main(float x) float : sin(x)", 1.0f, std::sin(1.0f));
	testMainFloatArgCheckConstantFolded("def main(float x) float : sin(1.0)", 1.0f, std::sin(1.0f));

	// Test sin on vector
	{
		Float4Struct a(1.0f, 2.0f, 3.0f, 4.0f);
		Float4Struct target_result(std::sin(1.0f), std::sin(2.0f), std::sin(3.0f), std::sin(4.0f));
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def sin(Float4Struct f) : Float4Struct(sin(f.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				sin(a)", 
			a, a, target_result
		);
	}

	// exp
	testMainFloatArg("def main(float x) float : exp(x)", 3.0f, std::exp(3.0f));
	testMainFloatArgCheckConstantFolded("def main(float x) float : exp(3.0)", 3.0f, std::exp(3.0f));

	// Test exp on vector
	{
		Float4Struct a(1.0f, 2.0f, 3.0f, 4.0f);
		Float4Struct target_result(std::exp(1.0f), std::exp(2.0f), std::exp(3.0f), std::exp(4.0f));
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def exp(Float4Struct f) : Float4Struct(exp(f.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				exp(a)", 
			a, a, target_result
		);
	}

	// log
	testMainFloatArg("def main(float x) float : log(x)", 3.0f, std::log(3.0f));
	testMainFloatArgCheckConstantFolded("def main(float x) float : log(3.0)", 3.0f, std::log(3.0f));

	// Test exp on vector
	{
		Float4Struct a(1.0f, 2.0f, 3.0f, 4.0f);
		Float4Struct target_result(std::log(1.0f), std::log(2.0f), std::log(3.0f), std::log(4.0f));
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def log(Float4Struct f) : Float4Struct(log(f.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				log(a)", 
			a, a, target_result
		);
	}

	// cos
	testMainFloatArg("def main(float x) float : cos(x)", 1.0f, std::cos(1.0f));
	testMainFloatArgCheckConstantFolded("def main(float x) float : cos(1.0)", 1.0f, std::cos(1.0f));

	// Test cos on vector
	{
		Float4Struct a(1.0f, 2.0f, 3.0f, 4.0f);
		Float4Struct target_result(std::cos(1.0f), std::cos(2.0f), std::cos(3.0f), std::cos(4.0f));
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def cos(Float4Struct f) : Float4Struct(cos(f.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				cos(a)", 
			a, a, target_result
		);
	}



	// Test floor
	testMainFloatArg("def main(float x) float : floor(x)", 2.3f, 2.0f);
	testMainFloatArg("def main(float x) float : floor(x)", -2.3f, -3.0f);
	testMainFloatArgCheckConstantFolded("def main(float x) float : floor(-2.3)", -2.3f, -3.0f);

	// Test floor on vector
	{
		Float4Struct a(-1.2, -0.2, 0.2, 1.2);
		Float4Struct target_result(-2, -1, 0, 1);
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def floor(Float4Struct f) : Float4Struct(floor(f.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				floor(a)", 
			a, a, target_result
		);
	}

	// Test ceil
	testMainFloatArg("def main(float x) float : ceil(x)", 2.3f, 3.0f);
	testMainFloatArg("def main(float x) float : ceil(x)", -2.3f, -2.0f);
	testMainFloatArgCheckConstantFolded("def main(float x) float : ceil(-2.3)", -2.3f, -2.0f);

	// Test ceil on vector
	{
		Float4Struct a(-1.2, -0.2, 0.2, 1.2);
		Float4Struct target_result(-1, 0, 1, 2);
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def ceil(Float4Struct f) : Float4Struct(ceil(f.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				ceil(a)", 
			a, a, target_result
		);
	}

	// Test using a let variable (y) before it is defined:
	testMainFloatArgInvalidProgram("									\n\
		def main(float x) float :		\n\
			let							\n\
				z = y					\n\
				y = x					\n\
			in							\n\
				z						"
	);

	// Test using a let variable (y) before it is defined, that would have created a cycle:
	testMainFloatArgInvalidProgram("									\n\
		def main(float x) float :		\n\
			let							\n\
				z = y					\n\
				y = z					\n\
			in							\n\
				z						"
	);

	// Test avoidance of circular let definition: 
	testMainFloatArgInvalidProgram("									\n\
		def main(float y) float :		\n\
			let							\n\
				x = x					\n\
			in							\n\
				x						"
	);

	// Test avoidance of circular let definition
	testMainFloatArgInvalidProgram("									\n\
		def main(float y) float :		\n\
			let							\n\
				x = 1.0 + x				\n\
			in							\n\
				x						"
	);

	// Test avoidance of circular let definition for functions
	testMainFloatArg("						\n\
		def f(float x) float : x		\n\
		def main(float y) float :		\n\
			let							\n\
				f1 = f(1.0) + 1.0				\n\
				f = f(1.0) + 1.0				\n\
			in							\n\
				f						",
		1.0f,
		2.0f
	);


	//COPIED:
	// Test two let clauses where one refers to the other.
	testMainFloat("def f() float : \
				  let	\
					z = 2.0 \
					y = z \
				  in \
					y \
				  def main() float : f()", 2.0);

	// Test vector in structure
	{
		Float4Struct a(1, 2, 3, 4);
		Float4Struct b(1, 2, 3, 4);
		Float4Struct target_result(1, 2, 3, 4);
		
		 //Float8Struct([min(e0(a.v), e0(b.v)), min(e1(a.v), e1(b.v)),	min(e2(a.v), e2(b.v)),	min(e3(a.v), e3(b.v)), min(e4(a.v), e4(b.v)), min(e5(a.v), e5(b.v)), min(e6(a.v), e6(b.v)), min(e7(a.v), e7(b.v))]v ) 
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def min(Float4Struct a, Float4Struct b) Float4Struct : Float4Struct(min(a.v, b.v)) \n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				min(a, b)", 
			a, b, target_result
		);
	}


	// Test vector in structure
	{
		Float8Struct a;
		a.v.e[0] = 10;
		a.v.e[1] = 2;
		a.v.e[2] = 30;
		a.v.e[3] = 4;
		a.v.e[4] = 4;
		a.v.e[5] = 5;
		a.v.e[6] = 6;
		a.v.e[7] = 7;

		Float8Struct b;
		b.v.e[0] = 1;
		b.v.e[1] = 20;
		b.v.e[2] = 3;
		b.v.e[3] = 40;
		b.v.e[4] = 4;
		b.v.e[5] = 5;
		b.v.e[6] = 6;
		b.v.e[7] = 7;

		Float8Struct target_result;
		target_result.v.e[0] = 1;
		target_result.v.e[1] = 2;
		target_result.v.e[2] = 3;
		target_result.v.e[3] = 4;
		target_result.v.e[4] = 4;
		target_result.v.e[5] = 5;
		target_result.v.e[6] = 6;
		target_result.v.e[7] = 7;
		
		 //Float8Struct([min(e0(a.v), e0(b.v)), min(e1(a.v), e1(b.v)),	min(e2(a.v), e2(b.v)),	min(e3(a.v), e3(b.v)), min(e4(a.v), e4(b.v)), min(e5(a.v), e5(b.v)), min(e6(a.v), e6(b.v)), min(e7(a.v), e7(b.v))]v ) 
		testFloat8Struct(
			"struct Float8Struct { vector<float, 8> v } \n\
			def min(Float8Struct a, Float8Struct b) Float8Struct : Float8Struct(min(a.v, b.v)) \n\
			def main(Float8Struct a, Float8Struct b) Float8Struct : \n\
				min(a, b)", 
			a, b, target_result
		);
	}


	// Test alignment of structure elements when they are vectors
	testMainFloatArg("struct vec4 { vector<float, 4> v }					\n\
				   struct vec16 { vector<float, 16> v }					\n\
				   struct large_struct { vec4 a, vec16 b }				\n\
				   def main(float x) float : large_struct(vec4([x, x, x, x]v), vec16([x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x]v)).a.v.e0",
				  3.0f, 3.0f);


	//TEMP:
	// Try dot product
	testMainFloatArg("	def main(float x) float : \
					 let v = [x, x, x, x]v in\
					 dot(v, v)", 4.0f, 64.0f);

	testMainFloatArg("	def main(float x) float : \
					 let v = [x, x, x, x]v in\
					 dot(v, v)", 2.0f, 16.0f);


	

	// Test avoidance of circular variable definition: 
	testMainFloatArg("									\n\
		def main(float x) float :		\n\
			let							\n\
				x = 2.0					\n\
			in							\n\
				x						",
		2.0f,
		2.0f
	);

	// Test avoidance of circular variable definition: the x(pos) expression was attempting to get the type of the 'x =' let node,
	// which was not known yet as was being computed.  The solution adopted is to not try to bind to let variables that are ancestors of the current variable.
	// Another solution could be to not try to bind to unbound variables.
	testMainFloatArg("									\n\
		struct vec3 { float x, float y, float z }		\n\
		def vec3(float v) vec3 : vec3(v, v, v)			\n\
		def eval(vec3 pos) vec3 :						\n\
			let											\n\
				x = sin(x(pos) * 1000.0)				\n\
			in											\n\
				vec3(0.1)								\n\
		def main(float t) float: x(eval(vec3(t, t, t)))",
		1.0f,
		0.1f
	);




	// Test operator overloading (op_add) in a let block.
	testMainFloatArg("								\n\
		struct vec3 { float x, float y, float z }	\n\
		def vec3(float v) vec3 : vec3(v, v, v)		\n\
		def op_add(vec3 a, vec3 b) vec3 : vec3(a.x+b.x, a.y+b.y, a.z+b.z)	\n\
		def eval(vec3 pos) vec3 :					\n\
			let											\n\
				scale = 20.0							\n\
			in											\n\
				vec3(scale) + vec3(0.2)					\n\
		def main(float x) float: x(eval(vec3(x, x, x)))",
		1.0f, 20.2f);	

	// Test operator overloading (op_mul) in a let block.
	testMainFloatArg("								\n\
		struct vec3 { float x, float y, float z }	\n\
		def vec3(float v) vec3 : vec3(v, v, v)		\n\
		def op_mul(vec3 a, float b) vec3 : vec3(a.x*b, a.y*b, a.z*b)	\n\
		def eval(vec3 pos) vec3 :					\n\
			let											\n\
				actualpos = vec3(pos.x, pos.y, pos.z + 10.0)				\n\
			in											\n\
				actualpos * 10000.0						\n\
		def main(float x) float: x(eval(vec3(x, x, x)))",
		1.0f, 10000.0f);	

	
	
	
	
	// Test comparison vs addition precedence: addition should have higher precedence.
	testMainFloatArg("def main(float x) float : if(x < 1.0 + 2.0, 5.0, 6.0)", 1.0f, 5.0f);




	// Test capture of let variable.
	
	//NOTE: Disabled, because these tests leak due to call to allocateRefCountedStructure().
	/*testMainFloat("	def main() float :                          \n\
				  let blerg = 3.0 in                     \n\
				  let f = \\() : blerg  in                    \n\
				  f()", 3.0);
	*/
	

	testMainFloatArg("def main(float x) float : sin(x)", 1.0f, std::sin(1.0f));


	// Test boolean logical expressions
	testMainFloat(" def main() float : if(true && true, 1.0, 2.0)", 1.0f);
	testMainFloat(" def main() float : if(true && false, 1.0, 2.0)", 2.0f);
	testMainFloat(" def main() float : if(true || false, 1.0, 2.0)", 1.0f);
	testMainFloat(" def main() float : if(false || false, 1.0, 2.0)", 2.0f);


	// =================================================================== 
	// Test Operator Overloading 
	// ===================================================================

	// test op_add
	testMainFloat("struct s { float x, float y } \n\
				  def op_add(s a, s b) : s(a.x + b.x, a.y + b.y) \n\
				  def main() float : x(s(1, 2) + s(3, 4))", 4.0f);

	// test op_mul
	testMainFloat("struct s { float x, float y } \n\
				  def op_mul(s a, s b) : s(a.x * b.x, a.y * b.y) \n\
				  def main() float : x(s(2, 3) * s(3, 4))", 6.0f);

	// Test op_sub
	testMainFloat("struct s { float x, float y } \n\
				  def op_sub(s a, s b) : s(a.x - b.x, a.y - b.y) \n\
				  def main() float : x(s(2, 3) - s(3, 4))", -1.0f);

	// Test op_div
	testMainFloat("struct s { float x, float y } \n\
				  def op_div(s a, s b) : s(a.x / b.x, a.y / b.y) \n\
				  def main() float : x(s(2, 3) / s(3, 4))", 2.0f / 3.0f);

	// Test op_unary_minus
	testMainFloat("struct s { float x, float y } \n\
				  def op_unary_minus(s a) : s(-a.x, -a.y) \n\
				  def main() float : x(-s(2, 3))", -2.0f);

	// ===================================================================
	// Test Operator Overloading with two different structures
	// ===================================================================
	
	// op_add returning S
	testMainFloat("struct S { float x, float y }					\n\
				  struct T { float z, float w }					\n\
				  def op_add(S a, T b) S : S(a.x + b.z, a.y + b.w)	\n\
				  def main() float : x(S(1, 2) + T(3, 4))", 4.0f);

	// op_add returning T
	testMainFloat("struct S { float x, float y }					\n\
				  struct T { float z, float w }					\n\
				  def op_add(S a, T b) T : T(a.x + b.z, a.y + b.w)	\n\
				  def main() float : z(S(1, 2) + T(3, 4))", 4.0f);

	// ===================================================================
	// Test Operator Overloading within a generic function
	// ===================================================================
	testMainFloat("struct s { float x, float y }						\n\
				  def op_add(s a, s b) : s(a.x + b.x, a.y + b.y)		\n\
				  def f<T>(T a, T b) : a + b							\n\
				  def main() float : x(f(s(1, 2), s(3, 4)))", 4.0f);

	// Test when op_add is not present

	testMainFloatArgInvalidProgram("struct s { float x, float y }						\n\
				  def f<T>(T a, T b) : a + b							\n\
				  def main() float : x(f(s(1, 2), s(3, 4)))");


	// ===================================================================
	// Test Operator Overloading in collection literals
	// ===================================================================

	// Without a collection
	testMainFloat("struct s { float x }									\n\
				  def op_add(s a, s b) : s(a.x + b.x)					\n\
				  def main() float : (s(1) + s(3)).x", 4.0f);

	// In Array literal
	testMainFloat("struct s { float x }									\n\
				  def op_add(s a, s b) : s(a.x + b.x)					\n\
				  def main() float : [s(1) + s(3)]a[0].x", 4.0f);

	// In VArray literal
	//TEMP CRASHES testMainFloatArgAllowUnsafe("struct s { float x }									\n\
	//			  def op_add(s a, s b) : s(a.x + b.x)					\n\
	//			  def main(float x) float : [s(1) + s(3)]va[0].x", 1.0f, 4.0f);

	// In Vector literal
	testMainFloat("struct s { float x }									\n\
				  def op_add(s a, s b) : s(a.x + b.x)					\n\
				  def main() float : [(s(1) + s(3)).x]v[0]", 4.0f);


	testMainFloat("def f(float x) float : x*x         def main() float : f(10)", 100.0);
	testMainFloat("def f(float x, float y) float : 1.0f   \n\
				  def f(float x, int y) float : 2.0f   \n\
				  def main() float : f(1.0, 2)", 2.0);

	// ===================================================================
	// Test implicit type conversions from int to float
	// ===================================================================

	// For numeric literals
	testMainFloat("def main() float : 3.0 + 4", 7.0);
	testMainFloat("def main() float : 3 + 4.0", 7.0);

	testMainFloat("def main() float : 3.0 - 4", -1.0);
	testMainFloat("def main() float : 3 - 4.0", -1.0);

	testMainFloat("def main() float : 3.0 * 4", 12.0);
	testMainFloat("def main() float : 3 * 4.0", 12.0);

	testMainFloat("def main() float : 12.0 / 4", 3.0);
	testMainFloat("def main() float : 12 / 4.0", 3.0);
	
	// Test with nodes that can't be constant-folded.
	// Addition
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : f(x) + 3", 2.0f, 7.0f);
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : 3 + f(x)", 2.0f, 7.0f);

	// Subtraction
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : f(x) - 3", 2.0f, 1.0f);
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : 3 - f(x)", 2.0f, -1.0f);

	// Multiplication
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : f(x) * 3", 2.0f, 12.0f);
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : 3 * f(x)", 2.0f, 12.0f);

	// Division
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : f(x) / 3", 3.0f, 3.0f);
	// Can't be done as f(x) might be zero:
	// testMainFloatArg("def f(float x) float : x*x      def main(float x) float : 3 / f(x)", 2.0f, 12.0f);

	// NOTE: this one can't convert because f(x) + 3 might be zero.
	//testMainFloatArg("def f(float x) float : x*x      def main(float x) float : 14 / (f(x) + 3)", 2.0f, 2.0f);
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : 14 / (f(2) + 3)", 2.0f, 2.0f);
	testMainFloatArg("def f(int x) int : x*x	      def main(float x) float : 14 / (f(2) + 3)", 2.0f, 2.0f);
	testMainFloatArg("def f<T>(T x) T : x*x           def main(float x) float : 14 / (f(2) + 3)", 2.0, 2.0f);

	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : f(x) * 2 + 1", 2.0f, 9.0f);
	
	testMainFloatArg("def main(float x) float : ( x + x) * (-0.4)", 2.0f, -1.6f);

	testMainFloatArg("def main(float x) float : (x + x) - 1.5", 2.0f, 2.5f);
	//testMainFloatArg("def main(float x) float : (x + x) -1.5", 2.0f, 2.0); // NOTE: this works in C++. (e.g. the -1.5 is interpreted as a binary subtraction)
	
	// Division
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : f(x) / 3", 3.0f, 3.0f);


	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : f(x) * (1.0 / 3.0)", 3.0f, 3.0f);
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : f(x) * (1 / 3.0)", 3.0f, 3.0f);
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : f(x) * (1.0 / 3)", 3.0f, 3.0f);

	// Division
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : 1.0 / 3.0", 3.0f, 1.0f / 3.0f);



	// Test promotion to match function return type:
	testMainFloat("def main() float : 3", 3.0);

	testMainFloat("def main() float : 1.0 + (2 + 3)", 6.0);
	
	testMainFloat("def main() float : 1.0 + 2 + 3", 6.0);
	
	// Test implicit conversion from int to float in addition operation with a function call
	//testMainFloat("def f(int x) : x*x    def main() float : 1.0 + f(2)", 5.0f);

	testMainFloat("def main() float : (1.0 + 2.0) + (3 + 4)", 10.0);
	testMainFloat("def main() float : (1.0 + 2) + (3 + 4)", 10.0);


	// Integer comparisons:
	// Test <=
	testMainInteger("def main() int : if(1 <= 2, 10, 20)", 10);
	testMainInteger("def main() int : if(1 <= 1, 10, 20)", 10);
	testMainInteger("def main() int : if(3 <= 1, 10, 20)", 20);

	// Test >=
	testMainInteger("def main() int : if(1 >= 2, 10, 20)", 20);
	testMainInteger("def main() int : if(1 >= 1, 10, 20)", 10);
	testMainInteger("def main() int : if(3 >= 1, 10, 20)", 10);

	// Test <
	testMainInteger("def main() int : if(1 < 2, 10, 20)", 10);
	testMainInteger("def main() int : if(3 < 1, 10, 20)", 20);

	// Test >
	testMainInteger("def main() int : if(1 > 2, 10, 20)", 20);
	testMainInteger("def main() int : if(3 > 1, 10, 20)", 10);

	// Test ==
	testMainInteger("def main() int : if(1 == 1, 10, 20)", 10);
	testMainInteger("def main() int : if(1 == 2, 10, 20)", 20);

	// Test !=
	testMainInteger("def main() int : if(1 != 1, 10, 20)", 20);
	testMainInteger("def main() int : if(1 != 2, 10, 20)", 10);


	// Float comparisons:
	// Test <=
	testMainFloat("def main() float : if(1.0 <= 2.0, 10.0, 20.0)", 10.0);
	testMainFloat("def main() float : if(1.0 <= 1.0, 10.0, 20.0)", 10.0);
	testMainFloat("def main() float : if(3.0 <= 1.0, 10.0, 20.0)", 20.0);

	// Test >=
	testMainFloat("def main() float : if(1.0 >= 2.0, 10.0, 20.0)", 20.0);
	testMainFloat("def main() float : if(1.0 >= 1.0, 10.0, 20.0)", 10.0);
	testMainFloat("def main() float : if(3.0 >= 1.0, 10.0, 20.0)", 10.0);

	// Test <
	testMainFloat("def main() float : if(1.0 < 2.0, 10.0, 20.0)", 10.0);
	testMainFloat("def main() float : if(3.0 < 1.0, 10.0, 20.0)", 20.0);

	// Test >
	testMainFloat("def main() float : if(1.0 > 2.0, 10.0, 20.0)", 20.0);
	testMainFloat("def main() float : if(3.0 > 1.0, 10.0, 20.0)", 10.0);

	// Test ==
	testMainFloat("def main() float : if(1.0 == 1.0, 10.0, 20.0)", 10.0);
	testMainFloat("def main() float : if(1.0 == 2.0, 10.0, 20.0)", 20.0);

	// Test !=
	testMainFloat("def main() float : if(1.0 != 1.0, 10.0, 20.0)", 20.0);
	testMainFloat("def main() float : if(1.0 != 2.0, 10.0, 20.0)", 10.0);


	// ===================================================================
	// Test implicit conversions from int to float in comparisons
	// ===================================================================
	// Comparison between two literals:

	// Test a comparison that returns true
	testMainFloat("def main() float : if(1.0 <= 2, 10.0, 20.0)", 10.0);
	testMainFloat("def main() float : if(1 <= 2.0, 10.0, 20.0)", 10.0);

	// Test a comparison that returns false
	testMainFloat("def main() float : if(3 <= 1.0, 10.0, 20.0)", 20.0);
	testMainFloat("def main() float : if(3.0 <= 1, 10.0, 20.0)", 20.0);

	// Comparison between a variable and a literal:
	testMainFloatArg("def main(float x) float : if(x <= 2, 10.0, 20.0)", 1.0, 10.0);
	testMainFloatArg("def main(float x) float : if(x <= 2, 10.0, 20.0)", 3.0, 20.0);

	testMainFloatArg("def main(float x) float : if(2 <= x, 10.0, 20.0)", 3.0, 10.0);
	testMainFloatArg("def main(float x) float : if(2 <= x, 10.0, 20.0)", 1.0, 20.0);




	// Test 'if'
	testMainInteger("def main() int : if(true, 2, 3)", 2);
	testMainInteger("def main() int : if(false, 2, 3)", 3);

	// Test 'if' with structures as the return type
	testMainInteger(
		"struct s { int a, int b }   \n\
		def main() int : a(if(true, s(1, 2), s(3, 4)))", 
		1);
	testMainInteger(
		"struct s { int a, int b }   \n\
		def main() int : a(if(false, s(1, 2), s(3, 4)))", 
		3);

	// Test 'if' with vectors as the return type
	testMainFloat(
		"def main() float : e0(if(true, [1.0, 2.0, 3.0, 4.0]v, [10.0, 20.0, 30.0, 40.0]v))", 
		1.0f);
	testMainFloat(
		"def main() float : e0(if(false, [1.0, 2.0, 3.0, 4.0]v, [10.0, 20.0, 30.0, 40.0]v))", 
		10.0f);


	// Test call to external function
	testMainFloat("def main() float : testExternalFunc(3.0)", 9.0f);
	testMainFloatArg("def main(float x) float : testExternalFunc(x)", 5.0f, 25.0f, INVALID_OPENCL);

	// Check that we can do constant folding even with an external expression
	testMainFloatArgCheckConstantFolded("def main(float x) float : testExternalFunc(3.0)", 5.0f, 9.0f, INVALID_OPENCL);
	
	// Simple test
	testMainFloat("def main() float : 1.0", 1.0);

	// Test addition expression
	testMainFloat("def main() float : 1.0 + 2.0", 3.0);

	// Test integer addition
	testMainInteger("def main() int : 1 + 2", 3);

	// Test multiple integer additions
	testMainInteger("def main() int : 1 + 2 + 3", 6);
	testMainInteger("def main() int : 1 + 2 + 3 + 4", 10);

	// Test multiple integer subtractions
	testMainInteger("def main() int : 1 - 2 - 3 - 4", 1 - 2 - 3 - 4);

	// Test left-to-right associativity
	// Note that right-to-left associativity here would give 2 - (3 + 4) = -5
	assert(2 - 3 + 4 == (2 - 3) + 4);
	assert(2 - 3 + 4 == 3);
	testMainInteger("def main() int : 2 - 3 + 4", 3);


	// Test multiplication expression
	testMainFloat("def main() float : 3.0 * 2.0", 6.0);




	// Test integer multiplication
	testMainInteger("def main() int : 2 * 3", 6);

	// Test multiple integer multiplication
	testMainInteger("def main() int : 2 * 3 * 4 * 5", 2 * 3 * 4 * 5);

	// Test left-to-right associativity of division
	// 12 / 4 / 3 = (12 / 4) / 3 = 1
	// whereas
	// 12 / (4 / 3) = 12 / 1 = 12
	testMainInteger("def main() int : 12 / 4 / 3", 1);


	// Test float subtraction
	testMainFloat("def main() float : 3.0 - 2.0", 1.0);

	// Test integer subtraction
	testMainInteger("def main() int : 2 - 3", -1);

	// Test precedence
	testMainInteger("def main() int : 2 + 3 * 4", 14);
	testMainInteger("def main() int : 2 * 3 + 4", 10);

	// Test parentheses controlling order of operation
	testMainInteger("def main() int : (2 + 3) * 4", 20);
	testMainInteger("def main() int : 2 * (3 + 4)", 14);


	// Test unary minus in front of parenthesis
	testMainInteger("def main() int : -(1 + 2)", -3);

	// Test floating point unary minus
	testMainFloat("def main() float : -(1.0 + 2.0)", -3.0);

	// Test unary minus in front of var
	testMainInteger("def f(int x) int : -x        def main() int : f(3)", -3);




	// Test simple function call
	testMainFloat("def f(float x) float : x        def main() float : f(3.0)", 3.0);

	// Test function call with two parameters
	testMainFloat("def f(float x, float y) float : x        def main() float : f(3.0, 4.0)", 3.0);
	testMainFloat("def f(float x, float y) float : y        def main() float : f(3.0, 4.0)", 4.0);

	// Test inferred return type (for f)
	testMainFloat("def f(float x) : x        def main() float : f(3.0)", 3.0);

	// Test two call levels of inferred return type (f, g)
	testMainFloat("def g(float x) : x    def f(float x) : g(x)       def main() float : f(3.0)", 3.0);
	testMainFloat("def f(float x) : x    def g(float x) : f(x)       def main() float : g(3.0)", 3.0);

	// Test generic function
	testMainFloat("def f<T>(T x) T : x        def main() float : f(2.0)", 2.0);

	// Test generic function with inferred return type (f)
	testMainFloat("def f<T>(T x) : x        def main() float : f(2.0)", 2.0);


	// Test function overloading - call with int param, should select 1st overload
	testMainFloat("def overloadedFunc(int x) float : 4.0 \
				  def overloadedFunc(float x) float : 5.0 \
				  def main() float: overloadedFunc(1)", 4.0f);

	// Call with float param, should select 2nd overload.
	testMainFloat("def overloadedFunc(int x) float : 4.0 \
				  def overloadedFunc(float x) float : 5.0 \
				  def main() float: overloadedFunc(1.0)", 5.0f);

	// Test binding to different overloaded functions based on type parameter to generic function
	testMainFloat("def overloadedFunc(int x) float : 4.0 \
				  def overloadedFunc(float x) float : 5.0 \
				  def f<T>(T x) float: overloadedFunc(x)\
				  def main() float : f(1)", 4.0f);


	// Test invalidity of recursive call in generic function.
	testMainFloatArgInvalidProgram("def f<T>(T x) f(x)   def main(float x) float : f(x)");
	testMainFloatArgInvalidProgram("def f<T>(T x) T : x*x / (f(2) + 3)   def main(float x) float : 1/ (f(2) + 3)");


	// Call f with float param
	testMainFloat("def overloadedFunc(int x) float : 4.0 \
				  def overloadedFunc(float x) float : 5.0 \
				  def f<T>(T x) float: overloadedFunc(x)\
				  def main() float : f(1.0)", 5.0f);

	// ===================================================================
	// Test let blocks
	// ===================================================================
	testMainFloat("def f(float x) float : \
				  let z = 2.0 \
				  in \
				  z \
				  def main() float : f(0.0)", 2.0);

	// Test two let clauses in a let block
	testMainFloat("def f(float x) float : \
				  let	\
					z = 2.0 \
					y = 3.0 \
				  in \
					y + z \
				  def main() float : f(0.0)", 5.0);

	// Test nested let blocks
	testMainFloat("	def f(float x) float : \
					let	\
						z = 2.0 \
					in \
						let		\
							y = 10.0  \
						in				\
							y + z			\
				  def main() float : f(0.0)", 12.0);

	// Test nested let blocks with multiple let clauses per block
	testMainFloat("	def f(float a) float : \
				  let	\
					x = 1.0  \
					y = 2.0 \
				  in \
					let		\
						z = 10.0  \
						w = 20.0  	\
					in				\
						x + y + z + w			\
				  def main() float : f(0.0)", 33.0);

	// Test two let clauses where one refers to the other.
	testMainFloat("def f() float : \
				  let	\
					z = 2.0 \
					y = z \
				  in \
					y \
				  def main() float : f()", 2.0);


	// Test optional types on let blocks
	testMainFloatArg("def f(float x) float :		\n\
				  let								\n\
					float z = 2.0					\n\
				  in								\n\
					x + z							\n\
				  def main(float x) float : f(x)", 2.0f, 4.0f);

	// Test optional types on let blocks
	testMainFloatArg("def f(float x) float :		\n\
				  let								\n\
					float y = 2.0					\n\
					float z = 3.0					\n\
				  in								\n\
					x + y + z							\n\
				  def main(float x) float : f(x)", 2.0f, 7.0f);

	// Test int->float type coercion with optional types on let blocks
	testMainFloatArg("def f(float x) float :		\n\
				  let								\n\
					float z = 2						\n\
				  in								\n\
					x + z							\n\
				  def main(float x) float : f(x)", 2.0f, 4.0f);


	// Test type mismatches between declared type and actual time.
	testMainFloatArgInvalidProgram("def f(float x) float :		\n\
				  let								\n\
					bool z = 2						\n\
				  in								\n\
					x + z							\n\
				  def main(float x) float : f(x)");

	testMainFloatArgInvalidProgram("def f(float x) float :		\n\
				  let								\n\
					int z = true					\n\
				  in								\n\
					x + z							\n\
				  def main(float x) float : f(x)");

	testMainFloatArgInvalidProgram("def f(float x) float :		\n\
				  let								\n\
					bool y = true					\n\
					int z = y						\n\
				  in								\n\
					x + z							\n\
				  def main(float x) float : f(x)");

	// Test two let clauses where one refers to the other (reverse order)
	/*testMainFloat("def f() float : \
				  let	\
					z = y \
					y = 2.0 \
				  in \
					y \
				  def main() float : f()", 2.0);

	//testMainFloat("def f() float : \
	//			  let	\
	//				z = y \
	//				y = 2.0 \
	//			  in \
	//				y \
	//			  def main() float : f()", 2.0);

	// Test nested let blocks
	//testMainFloat("def f() float : \n\
	//			let	\n\
	//				x = 2.0 \n\
	//			in \n\
	//				let           \n\
	//					y = x     \n\
	//				in               \n\
	//					y           \n\
	//			def main() float : f()", 2.0);

	// Test Lambda in let
	//testMainFloat("def main() float :           \n\
	//			  let f = \\(float x) : x*x  in   \n\
	//			  f(2.0)", 4.0f);

	//testMainFloat("	def f(float x) float : x+1.0    \n\
	//					def main() float :							\n\
	//						let g = f									\n\
	//						in									\n\
	//							g(1.0)", 2.0f);		

	// Test variable capture: the returned lambda needs to capture the value of x.
	testMainFloat("	def makeFunc(float x) function<float> : \\() : x      \n\
					def main() float :                          \n\
					let f = makeFunc(2.0) in                    \n\
					f()", 2.0);



	// Test return of a lambda from a function
	testMainFloat("def makeLambda() : \\(float x) : x*x    \n\
					def main() float :           \n\
					let f = makeLambda()  in   \n\
				  f(2.0)", 4.0f);

	// Test generic lambda!!!
	//testMainFloat("def makeLambda() : \\<T>(T x) : x*x    \n\
	//				def main() float :           \n\
	//				let f = makeLambda()  in   \n\
	//			  f(2.0)", 4.0f);

	// Test Lambda passed as a function arg
	testMainFloat("def g(function<float, float> f, float x) : f(x)       \n\
					def main() float :           \n\
					g(\\(float x) : x*x*x, 2.0f)", 8.0f);


	// Test passing a normal function as an argument
	//TEMP: Can't do this yet as need to add code to compile globals in a version that takes captured var struct.
	//testMainFloat("def g(function<float, float> f, float x) : f(x)       \n\
	//			  def square(float x) : x*x                              \n\
	//				def main() float :           \n\
	//				g(square, 2.0f)", 4.0f);

	// Test 'compose' function: returns the composition of two functions
	// NOTE: this requires lexical closures to work :)
	//TEMP: Can't do this yet as need to add code to compile globals in a version that takes captured var struct.
	//testMainFloat("def compose(function<float, float> f, function<float, float> g) : \\(float x) : f(g(x))       \n\
	//				def addOne(float x) : x + 1.0                \n\
	//				def mulByTwo(float x) : x * 2.0                \n\
	//				def main() float :                         \n\
	//					let z = compose(addOne, mulByTwo)  in \n\
	//					z(1.0)", 3.0f);


	// Test closures

	
	//// Test variable capture: the returned lambda needs to capture the value of x.
	testMainFloat("	def makeFunc(float x) function<float> : \\() : x      \n\
					def main() float :                          \n\
					let f = makeFunc(2.0) in                    \n\
					f()", 2.0);


	//// Test variable capture with two captured variables.
	testMainFloat("	def makeFunc(float x, float y) function<float> : \\() : x + y     \n\
					def main() float :                          \n\
					let f = makeFunc(2.0, 3.0) in                    \n\
					f()", 5.0);
	
	// Test capture of one variable and one usual argument
	testMainFloat("	def makeFunc(float x) function<float, float> : \\(float y) : x + y     \n\
					def main() float :                          \n\
					let f = makeFunc(2.0) in                    \n\
					f(3.0)", 5.0);

	// Test capture of let variable.

	//NOTE: Disabled, because these tests leak due to call to allocateRefCountedStructure().
	//testMainFloat("	def main() float :                          \n\
	//				let z = 3.0 in                     \n\
	//				let f = \\() : z  in                    \n\
	//				f()", 3.0);
	

	// TODO: test two lets varables at same level

	// Test capture of let variable up one level.
	
	NOTE: Disabled, because these tests leak due to call to allocateRefCountedStructure().
	testMainFloat("	def main() float :                          \n\
					let x = 3.0 in                         \n\
					let z = 4.0 in                         \n\
					let f = \\() : x  in                    \n\
					f()", 3.0);

	testMainFloat("	def main() float :                          \n\
					let x = 3.0 in                         \n\
					let z = 4.0 in                         \n\
					let f = \\() : z  in                    \n\
					f()", 4.0);
	*/



	// Test addition expression in let
	testMainFloat("def f(float x) float : \
				  let z = 2.0 + 3.0 in\
				  z \
				  def main() float : f(0.0)", 5.0);

	// Test function expression in let
	testMainFloat("	def g(float x) float : x + 1.0 \
					def f(float x) float : \
					let z = g(1.0) in \
					z \
					def main() float : f(0.0)", 2.0);

	// Test function argument in let
	testMainFloat("	def f(float x) float : \
					let z = x + 1.0 in\
					z \
					def main() float : f(2.0)", 3.0);


	// Test use of let variable twice
	testMainFloat("	def f(float x) float : \
				  let z = x + 1.0 in\
				  z + z\
				  def main() float : f(2.0)", 6.0);

	// test multiple lets with the same name in the same let block aren't allowed
	testMainFloatArgInvalidProgram("def f(float x) float :		\n\
			  let								\n\
				float y = 2.0					\n\
				float y = 3.0					\n\
			  in								\n\
				x + y							\n\
			  def main(float x) float : f(x)");


	// Test a let var with structure type.
	testMainFloatArg("struct S { float a }							\n\
				def f(float x) float :			\n\
					let							\n\
						z = S(x)				\n\
					in								\n\
						z.a + 1.0						\n\
				def main(float x) float : f(x)", 4.0, 5.0);


	// Test a let var set to a structure passed as an argument.
	testMainFloatArg("struct S { float a }							\n\
				def f(float x, S s) float :			\n\
					let							\n\
						z = s				\n\
					in								\n\
						z.a + 1.0						\n\
				def main(float x) float : f(x, S(x))", 4.0, 5.0);



	// Test creation of struct
	{
		Float4Struct a(1.0f, -2.0f, 3.0f, -4.0f);
		Float4Struct target_result(std::sqrt(1.0f), std::sqrt(2.0f), std::sqrt(3.0f), std::sqrt(4.0f));
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def sqrt(Float4Struct f) : Float4Struct(sqrt(f.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				let													\n\
					a = Float4Struct([1.0, 2.0, 3.0, 4.0]v)			\n\
				in													\n\
					sqrt(a)",
			a, a, target_result
		);
	}


	// Test struct
	testMainFloat("struct Complex { float re, float im } \
				  def main() float : re(Complex(2.0, 3.0))", 2.0f);
	
	testMainFloat("struct Complex { float re, float im } \
 				  def main() float : im(Complex(2.0, 3.0))", 3.0f);

	// Test struct in struct
	testMainFloat("struct Complex { float re, float im } \
				  struct ComplexPair { Complex a, Complex b } \
				  def main() float : im(a(ComplexPair(Complex(2.0, 3.0), Complex(4.0, 5.0))))",
				  3.0f);

	// Test field access with '.' applied to a variable.
	testMainFloat("struct Complex { float re, float im } \n\
 				  def main() float : \n\
					let z = Complex(2.0, 3.0) in \n\
					z.im", 3.0f);

	// Test field access with '.' applied to a structure literal.
	testMainFloat("struct Complex { float re, float im } \n\
 				  def main() float : \n\
					Complex(2.0, 3.0).im", 3.0f);

	// Test field access with '.' applied to a function call expression.
	testMainFloat("struct Complex { float re, float im } \n\
				  def f() Complex : Complex(1.0, 2.0) \n\
 				  def main() float : \n\
					f().im", 2.0f);


	// Test field access for nested structures.
	testMainFloat("struct Complex { float re, float im } \n\
				  struct ComplexPair { Complex a, Complex b } \n\
				  def main() float : ComplexPair(Complex(2.0, 3.0), Complex(4.0, 5.0)).a.im",
				  3.0f);


	// Test vector
	testMainFloat("	def main() float : \
					let x = [1.0, 2.0, 3.0, 4.0]v in\
					e0(x)", 1.0f);
	testMainFloat("	def main() float : \
					let x = [1.0, 2.0, 3.0, 4.0]v in \
					e1(x)", 2.0f);

	// Test vector being returned from a function
	testMainFloat("	def f() vector<float, 4> : [1.0, 2.0, 3.0, 4.0]v \
					def main() float : e2(f())", 3.0f);

	// Test vector addition
	testMainFloat("	def main() float : \
					let x = [1.0, 2.0, 3.0, 4.0]v \
					y = [10.0, 20.0, 30.0, 40.0]v in\
					e1(x + y)", 22.0f);

	// Test vector subtraction
	testMainFloat("	def main() float : \
					let x = [1.0, 2.0, 3.0, 4.0]v \
					y = [10.0, 20.0, 30.0, 40.0]v in \
					e1(x - y)", -18.0f);

	// Test vector * float multiplication
	testMainFloat("	def main() float : \
				  let x = [1.0, 2.0, 3.0, 4.0]v in \
			  e1(x * 10.0)", 2.0f * 10.0f);

	// Test vector * vector multiplication
	testMainFloat("	def main() float : \
				  let x = [1.0, 2.0, 3.0, 4.0]v \
				  y = [10.0, 20.0, 30.0, 40.0]v in\
				e1(x * y)", 2.0f * 20.0f);

	// Test vector<int> * vector<int> multiplication
	testMainInteger("	def main() int : \
				  let x = [1, 2, 3, 4]v \
				  y = [10, 20, 30, 40]v in\
				e1(x * y)", 2 * 20);

	// Test vector * scalar multiplication
	testMainFloat("	def mul(vector<float, 4> v, float x) vector<float, 4> : v * [x, x, x, x]v \n\
					def main() float : \
						let x = [1.0, 2.0, 3.0, 4.0]v \
						y = 10.0 in \
						mul(x, y).e1", 2.0f * 10.0f);

	testMainFloatArg("	def mul(vector<float, 4> v, float x) vector<float, 4> : v * [x, x, x, x]v \n\
				  def main(float x) float : \
				  let v = [1.0, 2.0, 3.0, 4.0]v in\
				  e1(mul(v, x))", 10.0f, 2.0f * 10.0f);

	// Try dot product
	testMainFloatArg("	def main(float x) float : \
					 let v = [x, x, x, x]v in\
					 dot(v, v)", 2.0f, 16.0f);

	// OpenCl dot not supported for > 4 elems in vector
	testMainFloatArg("	def main(float x) float : \
					 let v = [x, x, x, x, x, x, x, x]v in\
					 dot(v, v)", 4.0f, 128.0f, INVALID_OPENCL);
					 

	// Test vector min
	testMainFloat("	def main() float : \
					 let a = [1.0, 2.0, 3.0, 4.0]v \
					 b = [11.0, 12.0, 13.0, 14.0]v in\
					 e2(min(a, b))", 3.0);
	testMainFloat("	def main() float : \
				  let a = [1.0, 2.0, 3.0, 4.0]v \
				  b = [11.0, 12.0, 13.0, 14.0]v in \
				  e2(min(b, a))", 3.0);

	// Test vector max
	testMainFloat("	def main() float : \
				  let a = [1.0, 2.0, 3.0, 4.0]v \
				  b = [11.0, 12.0, 13.0, 14.0]v in \
				  e2(max(a, b))", 13.0);
	testMainFloat("	def main() float : \
				  let a = [1.0, 2.0, 3.0, 4.0]v \
				  b = [11.0, 12.0, 13.0, 14.0]v in \
				  e2(max(b, a))", 13.0);
				  

	testMainFloat("	def clamp(vector<float, 4> x, vector<float, 4> lowerbound, vector<float, 4> upperbound) vector<float, 4> : max(lowerbound, min(upperbound, x))  \n\
					def make_v4f(float x) vector<float, 4> : [x, x, x, x]v  \n\
					def main() float : \
					let a = [1.0, 2.0, 3.0, 4.0]v in\
					e2(clamp(a, make_v4f(2.0), make_v4f(2.5)))", 2.5);

	testMainFloat("	struct PolarisationVec { vector<float, 8> e } \n\
																	\n\
								def make_v4f(float x) vector<float, 4> : [x, x, x, x]v  \n\
																		\n\
					def clamp(vector<float, 4> x, vector<float, 4> lowerbound, vector<float, 4> upperbound) vector<float, 4> : max(lowerbound, min(upperbound, x))  \n\
																																					\n\
					def clamp(PolarisationVec x, float lowerbound, float upperbound) PolarisationVec : \n\
						let lo = [e0(e(x)), e1(e(x)), e2(e(x)), e3(e(x))]v   \n\
						hi = [e4(e(x)), e5(e(x)), e6(e(x)), e7(e(x))]v   \n\
						clamped_lo = clamp(lo, make_v4f(lowerbound), make_v4f(upperbound))   \n\
						clamped_hi = clamp(hi, make_v4f(lowerbound), make_v4f(upperbound))  in \n\
						PolarisationVec([e0(clamped_lo), e1(clamped_lo), e2(clamped_lo), e3(clamped_lo), e0(clamped_hi), e1(clamped_hi), e2(clamped_hi), e3(clamped_hi)]v)   \n\
																																												\n\
				  def main() float : \
					let a = PolarisationVec([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]v) in \
					e5(e(clamp(a, 2.0, 2.5)))", 2.5);

	//class PolarisationVec
	//{
	//public:
	//	__m128 e[2];


	/* Try matrix * vec4f mult

	*/
	/*testMainFloatArg("	struct Matrix { vector<float, 4> r0, vector<float, 4> r1, vector<float, 4> r2, vector<float, 4> r3 } \n\
						def mul(Matrix m, vector<float, 4> v) vector<float, 4> : [dot(r0(m), v), dot(r1(m), v), dot(r2(m), v), dot(r3(m), v)]v  \n\
						def main(float x) float : \
						let m = Matrix([x, x, x, x]v, [x, x, x, x]v, [x, x, x, x]v, [x, x, x, x]v) \
					 let v = [1.0, 2.0, 3.0, 4.0]v \
					 e0(mul(m, v))", 1.0f, 10.0f);*/


	// Test structure being returned from main function
	{
		struct TestStruct
		{
			float a;
			float b;
			float c;
			float d;

			bool operator == (const TestStruct& other) const { return (a == other.a) && (b == other.b); }
		};

		TestStruct target_result;
		target_result.a = 1;
		target_result.b = 2;
		target_result.c = 3;
		target_result.d = 4;

		std::string test_func = "struct TestStruct { float a, float b, float c, float d } \
			def main() TestStruct : TestStruct(1.0, 2.0, 3.0, 4.0)";
		//testMainStruct<TestStruct>(test_func, target_result);

		test_func = "struct TestStruct { float a, float b, float c, float d } \
			def main() TestStruct : TestStruct(1.0, 2.0, 3.0, 4.0)";
		//testMainStruct<TestStruct>(test_func, target_result);

	}
	{
		struct TestStruct
		{
			float a;
			float b;
			float c;
			float d;

			bool operator == (const TestStruct& other) const { return (a == other.a) && (b == other.b); }
		};

		TestStruct target_result;
		target_result.a = 5;
		target_result.b = 6;
		target_result.c = 3;
		target_result.d = 4;

		struct TestStructIn
		{
			float x;
			float y;
		};

		TestStructIn in;
		in.x = 5;
		in.y = 6;

		std::string test_func = "struct TestStruct { float a, float b, float c, float d } \
			struct TestStructIn { float x, float y } \
			def main(TestStructIn in_s) TestStruct : TestStruct(x(in_s), y(in_s), 3.0, 4.0)";
		//testMainStructInputAndOutput(test_func, in, target_result);
	}

	

	// Test vector in structure
	{


		StructWithVec in;
		in.a.e[0] = 1;
		in.a.e[1] = 2;
		in.a.e[2] = 3;
		in.a.e[3] = 4;

		in.b.e[0] = 4;
		in.b.e[1] = 5;
		in.b.e[2] = 6;
		in.b.e[3] = 7;

		in.data2 = 10;

		StructWithVec target_result;
		target_result.a.e[0] = 5;
		target_result.a.e[1] = 7;
		target_result.a.e[2] = 9;
		target_result.a.e[3] = 11;

		target_result.b.e[0] = 1;
		target_result.b.e[1] = 2;
		target_result.b.e[2] = 3;
		target_result.b.e[3] = 4;

		target_result.data2 = 10;

		testVectorInStruct(
							"struct StructWithVec { vector<float, 4> a, vector<float, 4> b, float data2 } \n\
							def main(StructWithVec in_s) StructWithVec : \n\
								StructWithVec(  \n\
								a(in_s) + b(in_s), #[e0(a(in_s)) + e0(b(in_s)), e1(a(in_s)) + e1(b(in_s)), e2(a(in_s)) + e2(b(in_s)), e3(a(in_s)) + e3(b(in_s))]v, \n\
								a(in_s), \n\
								data2(in_s))", 
							in, target_result);
	}


	// Winter::fuzzTests();

	std::cout << "===================All LanguageTests passed.  Elapsed: " << timer.elapsedString() << " =============================" << std::endl;
}


} // end namespace Winter


#endif // BUILD_TESTS
