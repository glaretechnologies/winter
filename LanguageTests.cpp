//
// Generated by makeclass.rb on Sun Oct 04 15:08:43 +1300 2009.
// Copyright Nicholas Chapman.
//
#include "LanguageTests.h"


#include "LanguageTestUtils.h"
//#include "ProgramBuilder.h"


namespace Winter
{


LanguageTests::LanguageTests()
{}


LanguageTests::~LanguageTests()
{}


/*

def main(int x) int : 
	if x < 5 then
		10 
	else
		20

def main(int x) int : 
	if x < 5
		10 
	else
		20

def main(int x) int : if x < 5 then 10 else	20

def main(int x) int : if (x < 5) then 10 else 20
def main(int x) int : if (x < 5) then 10 else 20

def main(int x) int : if (x < 5, 10, 20)

parse 'if ('
parse expression 'x < 5'
if next token == ')', then it's if-then-else.
if next token == ',', then it's if(,,)
*/

void LanguageTests::run()
{
//	ProgramBuilder::test();

	// truncateToInt with runtime args, with bounds checking
	testMainFloatArg("def main(float x) float : toFloat(if x >= -2147483648.0 && x < 2147483647.0 then truncateToInt(x) else 0)", 3.1f, 3.0f);

	// truncateToInt with constant value
	testMainFloatArg("def main(float x) float : toFloat(truncateToInt(3.1))", 3.1f, 3.0f);

	// Test truncateToInt where we can't prove the arg is in-bounds.
//TEMP	testMainFloatArgInvalidProgram("def main(float x) float : toFloat(truncateToInt(x))", 3.9f, 3.0f);



	

	// Test division by -1 where we prove the numerator is not INT_MIN
	/*testMainIntegerArg(
		"def main(int i) int : if i > 1 then 2 else 0", 
		8, -8);*/



	testMainIntegerArg("def div(int x, int y) int : if(y != 0 && x != -2147483648, x / y, 0)	\n\
					   def main(int i) int : div(i, i)",    
		5, 1);
	testMainIntegerArg("def main(int i) int : if i != 0 && i != -1 then i / i else 0",    
		5, 1);


	testMainFloatArg("def f(int x) int : x*x	      def main(float x) float : 14 / (f(2) + 2)", 2.0f, 2.0f);

	//testMainFloatArg("def f(int x) int : x*x	      def main(float x) float : f(2) + 3", 1.0f, 7.0f);
	testMainFloatArg("def f(int x) int : x*x	      def main(float x) float : 14 / (f(2) + 3)", 2.0f, 2.0f);

	// Test division by -1 where we prove the numerator is not INT_MIN
	testMainIntegerArg(
		"def main(int i) int : if i > -10000 then i / -1 else 0", 
		8, -8);

	// Test division where numerator = INT_MIN where we prove the denominator is not -1
	testMainIntegerArg(
		"def main(int i) int : if i >= 1 then -2147483648 / i else 0", 
		2, -1073741824);

	// Test division by -1 where we can't prove the numerator is not INT_MIN
	testMainIntegerArgInvalidProgram(
		"def main(int i) int : i / -1", 
		8);


	// Test division by a constant
	testMainIntegerArg(
		"def main(int i) int : i / 4", 
		8, 2);

	// Test division by zero
	testMainIntegerArgInvalidProgram(
		"def main(int i) int : i / 0", 
		1);


	// Test division by a runtime value
	testMainIntegerArg(
		"def main(int i) int : if i != 0 then 8 / i else 0", 
		4, 2);




	// Test array in array
	testMainIntegerArg(
		"def main(int i) int : if i >= 0 && i < 2 then elem(elem([[1, 2]a, [3, 4]a]a, i), i) else 0", 
		1, 4);

	// Test integer in-bounds runtime index access to array
	testMainIntegerArg(
		"def main(int i) int : if i >= 0 && i < 10 then elem([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]a, i) else 0", 
		2, 3);


	// Test integer in-bounds runtime index access to vector
	testMainIntegerArg(
		"def main(int i) int : if i >= 0 && i < 10 then elem([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]v, i) else 0", 
		2, 3);
	// ===================================================================
	// Test array access with elem()
	// ===================================================================
	// Test integer in-bounds constant index access to array
	testMainIntegerArg(
		"def main(int i) int :						\n\
			let										\n\
				a = [1, 2, 3, 4]a					\n\
			in										\n\
				elem(a, 1)							",
		1, 2);

	// Test integer out-of-bounds constant index access to array
	testMainIntegerArgInvalidProgram(
		"def main(int i) int :						\n\
			let										\n\
				a = [1, 2, 3, 4]a					\n\
			in										\n\
				elem(a, -1)							",
		1);

	// Test integer in-bounds runtime index access to array  (let clause)
	testMainIntegerArg(
		"def main(int i) int :						\n\
			let										\n\
				a = [1, 2, 3, 4]a					\n\
			in										\n\
				if inBounds(a, i)					\n\
					elem(a, i)						\n\
				else								\n\
					0								",
		1, 2);

	// Test integer in-bounds runtime index access to array (function arg var)
	testMainIntegerArg(
		"def f(array<int, 4> a, int i) int :		\n\
			if inBounds(a, i)						\n\
				elem(a, i)							\n\
			else									\n\
				0									\n\
		def main(int i) int :						\n\
			f([1, 2, 3, 4]a, i)",
		1, 2);

	// Test integer out-of-bounds runtime index access to array
	testMainIntegerArg(
		"def main(int i) int :						\n\
			let										\n\
				a = [1, 2, 3, 4]a					\n\
			in										\n\
				if inBounds(a, i)					\n\
					elem(a, i)						\n\
				else								\n\
					0								",
		-1, 0);

	// Test integer out-of-bounds runtime index access to array (function arg var)
	testMainIntegerArg(
		"def f(array<int, 4> a, int i) int :		\n\
			if inBounds(a, i)						\n\
				elem(a, i)							\n\
			else									\n\
				0									\n\
		def main(int i) int :						\n\
			f([1, 2, 3, 4]a, i)",
		-1, 0);


	// ===================================================================
	// Test vector access with elem()
	// ===================================================================
	// Test integer in-bounds constant index access to vector
	testMainIntegerArg(
		"def main(int i) int :						\n\
			let										\n\
				a = [1, 2, 3, 4]v					\n\
			in										\n\
				elem(a, 1)							",
		1, 2);

	// Test integer out-of-bounds constant index access to vector
	testMainIntegerArgInvalidProgram(
		"def main(int i) int :						\n\
			let										\n\
				a = [1, 2, 3, 4]v					\n\
			in										\n\
				elem(a, -1)							",
		1);

	// Test integer in-bounds runtime index access to vector
	testMainIntegerArg(
		"def main(int i) int :						\n\
			let										\n\
				a = [1, 2, 3, 4]v					\n\
			in										\n\
				if inBounds(a, i)					\n\
					elem(a, i)						\n\
				else								\n\
					0								",
		1, 2);

	// Test integer out-of-bounds runtime index access to vector
	testMainIntegerArg(
		"def main(int i) int :						\n\
			let										\n\
				a = [1, 2, 3, 4]v					\n\
			in										\n\
				if inBounds(a, i)					\n\
					elem(a, i)						\n\
				else								\n\
					0								",
		-1, 0);

	/*testMainIntegerArg(
		"def main(int i) int :						\n\
			match x = elem([1, 2, 3, 4]a, i)		\n\
				int: x								\n\
				error: 0							",
		1, 2);*/

	// Test integer out-of-bounds runtime index access
	/*testMainIntegerArg(
		"def main(int i) int :						\n\
			match x = elem([1, 2, 3, 4]a, i)		\n\
				int: x								\n\
				error: 0							",
		100, 0);*/



	/*float x = 2.0f;
	float y = (x + x) -1.5;*/

	// Test divide-by-zero
	//testMainIntegerArg("def main(int x) int : 10 / x ", 0, 10);

	// ===================================================================
	// Test if-then-else
	// ===================================================================
	testMainIntegerArg("def main(int x) int : if x < 5 then 10 else 5 ", 2, 10);
	testMainIntegerArg("def main(int x) int : if x < 5 then 10 else 5 ", 6, 5);

	testMainIntegerArg("def main(int x) int : if (x < 5) then 10 else 5 ", 6, 5);

	// Test optional 'then'
	testMainIntegerArg("def main(int x) int : if x < 5 10 else 5 ", 2, 10);
	testMainIntegerArg("def main(int x) int : if x < 5 10 else 5 ", 6, 5);

	// Test nested if-then-else
	testMainIntegerArg("def main(int x) int : if x < 5 then if x < 2 then 1 else 2 else 5 ", 1, 1);
	testMainIntegerArg("def main(int x) int : if x < 5 then if x < 2 then 1 else 2 else 5 ", 2, 2);
	testMainIntegerArg("def main(int x) int : if x < 5 then if x < 2 then 1 else 2 else 5 ", 10, 5);

	// Test nested if-then-else without the 'then'
	testMainIntegerArg("def main(int x) int : if x < 5 if x < 2 1 else 2 else 5 ", 1, 1);
	testMainIntegerArg("def main(int x) int : if x < 5 if x < 2 1 else 2 else 5 ", 2, 2);
	testMainIntegerArg("def main(int x) int : if x < 5 if x < 2 1 else 2 else 5 ", 10, 5);

	testMainIntegerArg("def main(int x) int :			\n\
								if x < 5				\n\
									if x < 3			\n\
										1				\n\
									else				\n\
										2				\n\
								else					\n\
									if x < 7			\n\
										6				\n\
									else				\n\
										7				\n\
		", 10, 7);

	// Test nested if-then-else with parentheses
	testMainIntegerArg("def main(int x) int : if x < 5 then (if x < 2 then 1 else 2) else 5 ", 1, 1);
	testMainIntegerArg("def main(int x) int : if x < 5 then (if x < 2 then 1 else 2) else 5 ", 2, 2);
	testMainIntegerArg("def main(int x) int : if x < 5 then (if x < 2 then 1 else 2) else 5 ", 10, 5);


	// ===================================================================
	// Ref counting tests
	// ===================================================================
	// Test putting a string in a structure, then returning it.
	testMainIntegerArg(
		"struct teststruct { string str }										\n\
		def f() teststruct : teststruct(\"hello world\")						\n\
		def main(int x) int : stringLength(str(f())) ",
		2, 11);

	// Test a string in a structure
	testMainIntegerArg(
		"struct teststruct { string str }										\n\
		def main(int x) int : stringLength(teststruct(\"hello world\").str) ",
		2, 11);

	

	// ===================================================================
	// String tests
	// ===================================================================

	// Double return of a string
	testMainIntegerArg(
		"def f() string : \"hello world\"	\n\
		def g() string : f()				\n\
		def main(int x) int : stringLength(g())",
		2, 11);
	

	// String test - string literal in let statement, with assignment.
	testMainIntegerArg(
		"def main(int x) int : stringLength(concatStrings(\"hello\", \"world\"))",
		2, 10);

	// String test - string literal in let statement, with assignment.
	testMainIntegerArg(
		"def main(int x) int :				\n\
			let								\n\
				s = \"hello world\"			\n\
				s2 = s						\n\
			in								\n\
				stringLength(s) + stringLength(s2)",
		2, 22);

	// String test - string literal in let statement, with assignment.
	testMainIntegerArg(
		"def main(int x) int :				\n\
			let								\n\
				s = \"hello world\"			\n\
				s2 = \"hallo thar\"			\n\
			in								\n\
				stringLength(s) + stringLength(s2)",
		2, 21);

	// a function returning a string
	testMainIntegerArg(
		"def f() string : \"hello world\"	\n\
		def main(int x) int : stringLength(f())",
		2, 11);

	// a function returning a string in a let block
	testMainIntegerArg(
		"def f() string : \"hello world\"	\n\
		def main(int x) int :				\n\
			let								\n\
				s = f()						\n\
			in								\n\
				stringLength(s)",
		2, 11);

	// String test - string literal in let statement
	testMainIntegerArg(
		"def main(int x) int :				\n\
			let								\n\
				s = \"hello world\"			\n\
			in								\n\
				stringLength(s)",
		2, 11);

	// String test - string literal as argument
	testMainIntegerArg(
		"def main(int x) int :				\n\
				stringLength(\"hello world\")",
		2, 11);

	// String test - string literal in let statement, with assignment.
	testMainIntegerArg(
		"def main(int x) int :				\n\
			let								\n\
				s = \"hello world\"			\n\
				s2 = s						\n\
			in								\n\
				stringLength(s2)",
		2, 11);

	// Char test
	testMainIntegerArg(
		"def main(int x) int :				\n\
			let								\n\
				c = 'a'						\n\
			in								\n\
				10",
		2, 10);


	// test type coercion on vectors: vector<float> initialisation with some int elems
	testMainFloatArg(
		"def main(float x) float: elem(   2.0 * [1.0, 2.0, 3, 4]v, 1)",
		1.0f, 4.0f);

	// float * Vector<float> multiplication
	testMainFloatArg(
		"def main(float x) float: elem(   2.0 * [1.0, 2.0, 3.0, 4.0]v, 1)",
		1.0f, 4.0f);

	// Vector<float> * float multiplication
	testMainFloatArg(
		"def main(float x) float: elem(   [1.0, 2.0, 3.0, 4.0]v * 2.0, 1)",
		1.0f, 4.0f);

	// int * Vector<int> multiplication
	testMainIntegerArg(
		"def main(int x) int: elem(   2 * [1, 2, 3, 4]v, 1)",
		1, 4);

	// Vector<int> * int multiplication
	testMainIntegerArg(
		"def main(int x) int: elem(   [1, 2, 3, 4]v * 2, 1)",
		1, 4);


	// float * Vector<float> multiplication
	testMainFloatArg(
		"def main(float x) float: elem(   x * [x, 2.0, 3.0, 4.0]v, 1)",
		2.0f, 4.0f);

	// Vector<float> * float multiplication
	testMainFloatArg(
		"def main(float x) float: elem(   [1.0, 2.0, 3.0, 4.0]v * x, 1)",
		2.0f, 4.0f);

	// int * Vector<int> multiplication
	testMainIntegerArg(
		"def main(int x) int: elem(   x * [1, 2, 3, 4]v, 1)",
		2, 4);

	// Vector<int> * int multiplication
	testMainIntegerArg(
		"def main(int x) int: elem(   [1, 2, 3, 4]v * x, 1)",
		2, 4);

	


	// Test integer in-bounds runtime index access to vector
	/*testMainIntegerArg(
		"def main(int i) int :								\n\
			let												\n\
				a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]v		\n\
				b = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]v		\n\
			in												\n\
				elem(a + b, i)",
		2, 4);

	

	// Test integer in-bounds runtime index access to vector
	testMainIntegerArg(
		"def main(int i) int :								\n\
			let												\n\
				a = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]v		\n\
				b = [1.0, 1.6, 1.0, 1.0, 1.3, 1.6, 1.8, 1.6]v		\n\
				c = [1.7, 2.8, 3.0, 4.7, 5.5, 6.7, 7.0, 8.4]v		\n\
			in												\n\
				truncateToInt(elem(a + if(i < 1, b, c), i))",
		2, 6);

	//exit(1);//TEMP

	// Test integer in-bounds runtime index access to vector
	testMainIntegerArg(
		"def main(int i) int :								\n\
			let												\n\
				a = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]v		\n\
				b = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ]v		\n\
				c = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]v		\n\
			in												\n\
				truncateToInt(elem(a + if(i < 1, b, c), i))",
		2, 6);
		*/
	

	// Test integer in-bounds runtime index access to vector
	testMainIntegerArg(
		"def main(int i) int : if i >= 0 && i < 10 then elem([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]v, i) else 0", 
		2, 3);

	testMainFloatArg(
		"def main(float x) float: elem( if(x < 0.5, [1.0, 2.0]a, [3.0, 4.0]a), 0)",
		1.0f, 3.0f);
	
	// Test a structure composed of another structure, and taking the dot product of two vectors in the child structures, in an if statement
	{
		Float4StructPair a(
			Float4Struct(1, 1, 1, 1),
			Float4Struct(2, 2, 2, 2)
		);
		
		testFloat4StructPairRetFloat(
			"struct Float4Struct { vector<float, 4> v }			\n\
			struct Float4StructPair { Float4Struct a, Float4Struct b }			\n\
			def main(Float4StructPair pair1, Float4StructPair pair2) float :			\n\
				if(e0(pair1.a.v) < 0.5, dot(pair1.a.v, pair2.b.v), dot(pair1.b.v, pair2.a.v))",
			a, a, 8.0f);
	}

	// Test a structure composed of another structure, and taking the dot product of two vectors in the child structures.
	{
		Float4StructPair a(
			Float4Struct(1, 1, 1, 1),
			Float4Struct(2, 2, 2, 2)
		);
		
		testFloat4StructPairRetFloat(
			"struct Float4Struct { vector<float, 4> v }			\n\
			struct Float4StructPair { Float4Struct a, Float4Struct b }			\n\
			def main(Float4StructPair pair1, Float4StructPair pair2) float :			\n\
				dot(pair1.a.v, pair2.b.v)",
			a, a, 8.0f);
	}


	

	// Test if with expensive-to-eval args
	testMainFloatArg(
		//"def expensiveA(float x) float : pow(x, 0.1 + pow(0.2, x))			\n
		"def expensiveA(float x) float : cos(x * 0.456 + cos(x))			\n\
		def expensiveB(float x) float : sin(x * 0.345 + sin(x))			\n\
		def main(float x) float: if(x < 0.5, expensiveA(x + 0.145), expensiveB(x + 0.2435))",
		0.2f, cos((0.2f + 0.145f) * 0.456f + cos((0.2f + 0.145f))));	

	// Test operator overloading (op_add) for an array
	testMainFloatArg(
		"def op_add(array<float, 2> a, array<float, 2> b) array<float, 2> : [elem(a, 0) + elem(b, 0), elem(a, 1) + elem(b, 1)]a		\n\
		def main(float x) float: elem([1.0, 2.0]a  + [3.0, 4.0]a, 1)",
		1.0f, 6.0f);	

	// Test operator overloading (op_mul) for an array
	testMainFloatArg(
		"def op_mul(array<float, 2> a, float x) array<float, 2> : [elem(a, 0) * x, elem(a, 1) * x]a		\n\
		def main(float x) float: elem([1.0, 2.0]a * 2.0, 1)",
		1.0f, 4.0f);	

	
	// Test array in array
	testMainIntegerArg(
		"def main(int i) int : if i >= 0 && i < 2 then elem(elem([[1, 2]a, [3, 4]a]a, i), i) else 0", 
		1, 4);

	// Test struct in array
	testMainIntegerArg(
		"struct Pair { int a, int b }		\n\
		def main(int i) int : if i >= 0 && i < 2 then b(elem([Pair(1, 2), Pair(3, 4)]a, i)) else 0 ", 
		1, 4);


	testMainIntegerArg(
		"def main(int i) int : if i >= 0 && i < 5 then elem([1, 2, 3, 4, 5]a, i) else 0", 
		1, 2);
		
	// Test integer in-bounds runtime index access
	testMainIntegerArg(
		"def main(int i) int : if i >= 0 && i < 20 then elem([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]a, i) else 0", 
		10, 11);

	// Test integer in-bounds runtime index access
	for(int i=0; i<5; ++i)
	{
		testMainIntegerArg(
			"def main(int i) int : if i >= 0 && i < 5 then elem([1, 2, 3, 4, 5]a, i) else 0", 
			i, i+1);
	}

	// Test integer in-bounds runtime index access
	testMainIntegerArg(
		"def main(int i) int : if i >= 0 && i < 4 then elem([1, 2, 3, 4]a, i) else 0", 
		1, 2);

	// Test runtime out of bounds access.  Should return 0.
	if(false)
	{
		testMainIntegerArg(
			"def main(int i) int : elem([1, 2, 3, 4]a, i)", 
			-1, 0);

		testMainIntegerArg(
			"def main(int i) int : elem([1, 2, 3, 4]a, i)", 
			4, 0);

		// Test out of bounds array access
		testMainFloatArg(
			"def main(float x) float : elem([1.0, 2.0, 3.0, 4.0]a, 4)", 
			10.0, std::numeric_limits<float>::quiet_NaN());

		testMainFloatArg(
			"def main(float x) float : elem([1.0, 2.0, 3.0, 4.0]a, -1)", 
			10.0, std::numeric_limits<float>::quiet_NaN());
	}

	



	

	// Test float arrays getting passed in to and returned from main function
	{
		const float a[] = {1.0f, 2.0f, 3.0f, 4.0f};
		const float b[] = {10.0f, 20.0f, 30.0f, 40.0f};
		float target_results[] = {1.0f, 2.0f, 3.0f, 4.0f};

		testFloatArray("def main(array<float, 4> a, array<float, 4> b) array<float, 4> : a",
			a, b, target_results, 4);
	}

	// Test map
	{
		const float a[] = {1.0f, 2.0f, 3.0f, 4.0f};
		const float b[] = {10.0f, 20.0f, 30.0f, 40.0f};
		float target_results[] = {1.0f, 4.0f, 9.0f, 16.0f};

		testFloatArray(
			"def square(float x) float : x*x			\n\
			def main(array<float, 4> a, array<float, 4> b) array<float, 4> : map(square, a)",
			a, b, target_results, 4);
	}

	// Test map with more elems
	{
		const size_t N = 256;
		std::vector<float> input(N, 2.0f);
		std::vector<float> target_results(N, 4.0f);


		testFloatArray(
			"def square(float x) float : x*x			\n\
			def main(array<float, 256> a, array<float, 256> b) array<float, 256> : map(square, a)",
			&input[0], &input[0], &target_results[0], N);
	}


	// Test float arrays getting passed in to and returned from main function
	{
		const float a[] = {1.0f, 2.0f, 3.0f, 4.0f};
		const float b[] = {10.0f, 20.0f, 30.0f, 40.0f};
		float target_results[] = {11.f, 22.f, 33.f, 44.f};

		testFloatArray("def main(array<float, 4> a, array<float, 4> b) array<float, 4> : [elem(a,0) + elem(b,0), elem(a,1) + elem(b,1), elem(a,2) + elem(b,2), elem(a,3) + elem(b,3)]a",
			a, b, target_results, 4);
	}



	

	// Test structure getting returned directly.
	{
		Float4Struct a(1.0f, -2.0f, 3.0f, -4.0f);
		Float4Struct target_result(1.0f, -2.0f, 3.0f, -4.0f);
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				a", 
			a, a, target_result
		);
	}


	

	// Test Array of structs
	testMainFloatArg(
		"struct Pair { float a, float b }		\n\
		def main(float x) float : b(elem([Pair(1.0, 2.0), Pair(3.0, 4.0)]a, 1)) ", 
		10.0, 4.0f);
	
	// Test mixing of int and float in an array - is invalid
	testMainFloatArgInvalidProgram("def main(float x) float : elem([1.0, 2, 3.0, 4.0]a, 1) + x", 10.0, 12.f);
	testMainFloatArgInvalidProgram("def main(float x) float : elem([1, 2.0, 3.0, 4.0]a, 1) + x", 10.0, 12.f);

	// Test Array Literal
	testMainFloatArg("def main(float x) float : elem([1.0, 2.0, 3.0, 4.0]a, 1) + x", 10.0, 12.f);

	// Test Array Literal with one element
	testMainFloatArg("def main(float x) float : elem([1.0]a, 0) + x", 10.0, 11.f);

	// Test Array Literal with non-const value
	testMainFloatArg("def main(float x) float : elem([x, x, x, x]a, 1) + x", 1.0, 2.f);
	testMainFloatArg("def main(float x) float : elem([x, x+1.0, x+2.0, x+3.0]a, 2)", 1.0, 3.f);

	// Test Array Literal of integers
	testMainIntegerArg("def main(int x) int : elem([1, 2, 3, 4]a, 1) + x", 10, 12);

	


	// Test array with let statement
	testMainFloatArg(
		"def main(float x) float :				\n\
			let									\n\
				a = [1.0, 2.0, 3.0, 4.0]a		\n\
			in									\n\
				elem(a, 0)",
		0.0f, 1.0f);

	// Passing array by argument
	testMainFloatArg(
		"def f(array<float, 4> a) float : elem(a, 1)		\n\
		def main(float x) float :						\n\
			f([1.0, 2.0, 3.0, 4.0]a) +  x",
		10.0f, 12.0f);


	// abs
	testMainFloatArg("def main(float x) float : abs(x)", 9.0f, 9.0f);
	testMainFloatArg("def main(float x) float : abs(x)", -9.0f, 9.0f);


	// Test abs on vector
	{
		Float4Struct a(1.0f, -2.0f, 3.0f, -4.0f);
		Float4Struct target_result(1.0f, 2.0f, 3.0f, 4.0f);
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def abs(Float4Struct f) : Float4Struct(abs(f.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				abs(a)", 
			a, a, target_result
		);
	}

	// TODO: abs for integers


	//testMainFloatArg("def main(float x) float : someFuncBleh(x)", 9.0f, 10.0f);

	// truncateToInt
	//testMainIntegerArg("def main(int x) int : truncateToInt(toFloat(x) + 0.2)", 3, 3);
	//testMainIntegerArg("def main(int x) int : truncateToInt(toFloat(x) + 0.2)", -3, -2);

	// Test truncateToInt on vector
/*	
TODO: FIXME: needs truncateToInt in bounds proof.
	{
		Float4Struct a(-2.2f, -1.2f, 0.2f, 1.2f);
		Float4Struct target_result(-2.f, -1.f, 0.f, 1.f);
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def sqrt(Float4Struct f) : Float4Struct(sqrt(f.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				let													\n\
					vec_int = truncateToInt(a.v)					\n\
				in													\n\
					Float4Struct(toFloat(vec_int))",
			a, a, target_result
		);
	}
*/
	// sqrt
	testMainFloatArg("def main(float x) float : sqrt(x)", 9.0f, std::sqrt(9.0f));

	// Test sqrt on vector
	{
		Float4Struct a(1.0f, 2.0f, 3.0f, 4.0f);
		Float4Struct target_result(std::sqrt(1.0f), std::sqrt(2.0f), std::sqrt(3.0f), std::sqrt(4.0f));
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def sqrt(Float4Struct f) : Float4Struct(sqrt(f.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				sqrt(a)", 
			a, a, target_result
		);
	}

	// pow
	testMainFloatArg("def main(float x) float : pow(2.4, x)", 3.0f, std::pow(2.4f, 3.0f));
	testMainFloatArg("def main(float x) float : pow(2.0, x)", 3.0f, std::pow(2.0f, 3.0f));

	// Test pow on vector
	{
		Float4Struct a(1.0f, 2.0f, 3.0f, 4.0f);
		Float4Struct b(1.4f, 2.4f, 3.4f, 4.4f);
		Float4Struct target_result(std::pow(1.0f, 1.4f), std::pow(2.0f, 2.4f), std::pow(3.0f, 3.4f), std::pow(4.0f, 4.4f));
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def pow(Float4Struct a, Float4Struct b) : Float4Struct(pow(a.v, b.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				pow(a, b)", 
			a, b, target_result
		);
	}

	// sin
	testMainFloatArg("def main(float x) float : sin(x)", 1.0f, std::sin(1.0f));

	// Test sin on vector
	{
		Float4Struct a(1.0f, 2.0f, 3.0f, 4.0f);
		Float4Struct target_result(std::sin(1.0f), std::sin(2.0f), std::sin(3.0f), std::sin(4.0f));
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def sin(Float4Struct f) : Float4Struct(sin(f.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				sin(a)", 
			a, a, target_result
		);
	}

	// exp
	testMainFloatArg("def main(float x) float : exp(x)", 3.0f, std::exp(3.0f));

	// Test exp on vector
	{
		Float4Struct a(1.0f, 2.0f, 3.0f, 4.0f);
		Float4Struct target_result(std::exp(1.0f), std::exp(2.0f), std::exp(3.0f), std::exp(4.0f));
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def exp(Float4Struct f) : Float4Struct(exp(f.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				exp(a)", 
			a, a, target_result
		);
	}

	// log
	testMainFloatArg("def main(float x) float : log(x)", 3.0f, std::log(3.0f));

	// Test exp on vector
	{
		Float4Struct a(1.0f, 2.0f, 3.0f, 4.0f);
		Float4Struct target_result(std::log(1.0f), std::log(2.0f), std::log(3.0f), std::log(4.0f));
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def log(Float4Struct f) : Float4Struct(log(f.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				log(a)", 
			a, a, target_result
		);
	}

	// cos
	testMainFloatArg("def main(float x) float : cos(x)", 1.0f, std::cos(1.0f));

	// Test cos on vector
	{
		Float4Struct a(1.0f, 2.0f, 3.0f, 4.0f);
		Float4Struct target_result(std::cos(1.0f), std::cos(2.0f), std::cos(3.0f), std::cos(4.0f));
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def cos(Float4Struct f) : Float4Struct(cos(f.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				cos(a)", 
			a, a, target_result
		);
	}



	// Test floor
	testMainFloatArg("def main(float x) float : floor(x)", 2.3f, 2.0f);
	testMainFloatArg("def main(float x) float : floor(x)", -2.3f, -3.0f);

	// Test floor on vector
	{
		Float4Struct a(-1.2, -0.2, 0.2, 1.2);
		Float4Struct target_result(-2, -1, 0, 1);
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def floor(Float4Struct f) : Float4Struct(floor(f.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				floor(a)", 
			a, a, target_result
		);
	}

	// Test ceil
	testMainFloatArg("def main(float x) float : ceil(x)", 2.3f, 3.0f);
	testMainFloatArg("def main(float x) float : ceil(x)", -2.3f, -2.0f);

	// Test ceil on vector
	{
		Float4Struct a(-1.2, -0.2, 0.2, 1.2);
		Float4Struct target_result(-1, 0, 1, 2);
		
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def ceil(Float4Struct f) : Float4Struct(ceil(f.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				ceil(a)", 
			a, a, target_result
		);
	}


	// Test avoidance of circular let definition: 
	testMainFloatArgInvalidProgram("									\n\
		def main(float y) float :		\n\
			let							\n\
				x = x					\n\
			in							\n\
				x						",
		2.0f,
		2.0f
	);

	// Test avoidance of circular let definition
	testMainFloatArgInvalidProgram("									\n\
		def main(float y) float :		\n\
			let							\n\
				x = 1.0 + x				\n\
			in							\n\
				x						",
		2.0f,
		2.0f
	);


	//COPIED:
	// Test two let clauses where one refers to the other.
	testMainFloat("def f() float : \
				  let	\
					z = 2.0 \
					y = z \
				  in \
					y \
				  def main() float : f()", 2.0);

	// Test vector in structure
	{
		Float4Struct a(1, 2, 3, 4);
		Float4Struct b(1, 2, 3, 4);
		Float4Struct target_result(1, 2, 3, 4);
		
		 //Float8Struct([min(e0(a.v), e0(b.v)), min(e1(a.v), e1(b.v)),	min(e2(a.v), e2(b.v)),	min(e3(a.v), e3(b.v)), min(e4(a.v), e4(b.v)), min(e5(a.v), e5(b.v)), min(e6(a.v), e6(b.v)), min(e7(a.v), e7(b.v))]v ) 
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def min(Float4Struct a, Float4Struct b) Float4Struct : Float4Struct(min(a.v, b.v)) \n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				min(a, b)", 
			a, b, target_result
		);
	}


	// Test vector in structure
	{
		Float8Struct a;
		a.v.e[0] = 10;
		a.v.e[1] = 2;
		a.v.e[2] = 30;
		a.v.e[3] = 4;
		a.v.e[4] = 4;
		a.v.e[5] = 5;
		a.v.e[6] = 6;
		a.v.e[7] = 7;

		Float8Struct b;
		b.v.e[0] = 1;
		b.v.e[1] = 20;
		b.v.e[2] = 3;
		b.v.e[3] = 40;
		b.v.e[4] = 4;
		b.v.e[5] = 5;
		b.v.e[6] = 6;
		b.v.e[7] = 7;

		Float8Struct target_result;
		target_result.v.e[0] = 1;
		target_result.v.e[1] = 2;
		target_result.v.e[2] = 3;
		target_result.v.e[3] = 4;
		target_result.v.e[4] = 4;
		target_result.v.e[5] = 5;
		target_result.v.e[6] = 6;
		target_result.v.e[7] = 7;
		
		 //Float8Struct([min(e0(a.v), e0(b.v)), min(e1(a.v), e1(b.v)),	min(e2(a.v), e2(b.v)),	min(e3(a.v), e3(b.v)), min(e4(a.v), e4(b.v)), min(e5(a.v), e5(b.v)), min(e6(a.v), e6(b.v)), min(e7(a.v), e7(b.v))]v ) 
		testFloat8Struct(
			"struct Float8Struct { vector<float, 8> v } \n\
			def min(Float8Struct a, Float8Struct b) Float8Struct : Float8Struct(min(a.v, b.v)) \n\
			def main(Float8Struct a, Float8Struct b) Float8Struct : \n\
				min(a, b)", 
			a, b, target_result
		);
	}


	// Test alignment of structure elements when they are vectors
	testMainFloatArg("struct vec4 { vector<float, 4> v }					\n\
				   struct vec16 { vector<float, 16> v }					\n\
				   struct large_struct { vec4 a, vec16 b }				\n\
				   def main(float x) float : large_struct(vec4([x, x, x, x]v), vec16([x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x]v)).a.v.e0",
				  3.0f, 3.0f);


	//TEMP:
	// Try dot product
	testMainFloatArg("	def main(float x) float : \
					 let v = [x, x, x, x]v in\
					 dot(v, v)", 2.0f, 16.0f);


	

	// Test avoidance of circular variable definition: 
	testMainFloatArg("									\n\
		def main(float x) float :		\n\
			let							\n\
				x = 2.0					\n\
			in							\n\
				x						",
		2.0f,
		2.0f
	);

	// Test avoidance of circular variable definition: the x(pos) expression was attempting to get the type of the 'x =' let node,
	// which was not known yet as was being computed.  The solution adopted is to not try to bind to let variables that are ancestors of the current variable.
	// Another solution could be to not try to bind to unbound variables.
	testMainFloatArg("									\n\
		struct vec3 { float x, float y, float z }		\n\
		def vec3(float v) vec3 : vec3(v, v, v)			\n\
		def eval(vec3 pos) vec3 :						\n\
			let											\n\
				x = sin(x(pos) * 1000.0)				\n\
			in											\n\
				vec3(0.1)								\n\
		def main(float t) float: x(eval(vec3(t, t, t)))",
		1.0f,
		0.1f
	);




	// Test operator overloading (op_add) in a let block.
	testMainFloatArg("								\n\
		struct vec3 { float x, float y, float z }	\n\
		def vec3(float v) vec3 : vec3(v, v, v)		\n\
		def op_add(vec3 a, vec3 b) vec3 : vec3(a.x+b.x, a.y+b.y, a.z+b.z)	\n\
		def eval(vec3 pos) vec3 :					\n\
			let											\n\
				scale = 20.0							\n\
			in											\n\
				vec3(scale) + vec3(0.2)					\n\
		def main(float x) float: x(eval(vec3(x, x, x)))",
		1.0f, 20.2f);	

	// Test operator overloading (op_mul) in a let block.
	testMainFloatArg("								\n\
		struct vec3 { float x, float y, float z }	\n\
		def vec3(float v) vec3 : vec3(v, v, v)		\n\
		def op_mul(vec3 a, float b) vec3 : vec3(a.x*b, a.y*b, a.z*b)	\n\
		def eval(vec3 pos) vec3 :					\n\
			let											\n\
				actualpos = vec3(pos.x, pos.y, pos.z + 10.0)				\n\
			in											\n\
				actualpos * 10000.0						\n\
		def main(float x) float: x(eval(vec3(x, x, x)))",
		1.0f, 10000.0f);	

	
	
	
	
	// Test comparison vs addition precedence: addition should have higher precedence.
	testMainFloatArg("def main(float x) float : if(x < 1.0 + 2.0, 5.0, 6.0)", 1.0f, 5.0f);




	// Test capture of let variable.
	
	//NOTE: Disabled, because these tests leak due to call to allocateRefCountedStructure().
	//testMainFloat("	def main() float :                          \n\
	//			  let blerg = 3.0 in                     \n\
	//			  let f = \\() : blerg  in                    \n\
	//			  f()", 3.0);
	

	testMainFloatArg("def main(float x) float : sin(x)", 1.0f, std::sin(1.0f));


	// Test boolean logical expressions
	testMainFloat(" def main() float : if(true && true, 1.0, 2.0)", 1.0f);
	testMainFloat(" def main() float : if(true && false, 1.0, 2.0)", 2.0f);
	testMainFloat(" def main() float : if(true || false, 1.0, 2.0)", 1.0f);
	testMainFloat(" def main() float : if(false || false, 1.0, 2.0)", 2.0f);


	// =================================================================== 
	// Test Operator Overloading 
	// ===================================================================

	// test op_add
	testMainFloat("struct s { float x, float y } \n\
				  def op_add(s a, s b) : s(a.x + b.x, a.y + b.y) \n\
				  def main() float : x(s(1, 2) + s(3, 4))", 4.0f);

	// test op_mul
	testMainFloat("struct s { float x, float y } \n\
				  def op_mul(s a, s b) : s(a.x * b.x, a.y * b.y) \n\
				  def main() float : x(s(2, 3) * s(3, 4))", 6.0f);

	// Test op_sub
	testMainFloat("struct s { float x, float y } \n\
				  def op_sub(s a, s b) : s(a.x - b.x, a.y - b.y) \n\
				  def main() float : x(s(2, 3) - s(3, 4))", -1.0f);

	// Test op_div
	testMainFloat("struct s { float x, float y } \n\
				  def op_div(s a, s b) : s(a.x / b.x, a.y / b.y) \n\
				  def main() float : x(s(2, 3) / s(3, 4))", 2.0f / 3.0f);

	// ===================================================================
	// Test Operator Overloading with two different structures
	// ===================================================================
	
	// op_add returning S
	testMainFloat("struct S { float x, float y }					\n\
				  struct T { float z, float w }					\n\
				  def op_add(S a, T b) S : S(a.x + b.z, a.y + b.w)	\n\
				  def main() float : x(S(1, 2) + T(3, 4))", 4.0f);

	// op_add returning T
	testMainFloat("struct S { float x, float y }					\n\
				  struct T { float z, float w }					\n\
				  def op_add(S a, T b) T : T(a.x + b.z, a.y + b.w)	\n\
				  def main() float : z(S(1, 2) + T(3, 4))", 4.0f);

	// ===================================================================
	// Test Operator Overloading within a generic function
	// ===================================================================
	testMainFloat("struct s { float x, float y }						\n\
				  def op_add(s a, s b) : s(a.x + b.x, a.y + b.y)		\n\
				  def f<T>(T a, T b) : a + b							\n\
				  def main() float : x(f(s(1, 2), s(3, 4)))", 4.0f);





	

	testMainFloat("def f(float x) float : x*x         def main() float : f(10)", 100.0);
	testMainFloat("def f(float x, float y) float : 1.0f   \n\
				  def f(float x, int y) float : 2.0f   \n\
				  def main() float : f(1.0, 2)", 2.0);

	// ===================================================================
	// Test implicit type conversions from int to float
	// ===================================================================

	// For numeric literals
	testMainFloat("def main() float : 3.0 + 4", 7.0);
	testMainFloat("def main() float : 3 + 4.0", 7.0);

	testMainFloat("def main() float : 3.0 - 4", -1.0);
	testMainFloat("def main() float : 3 - 4.0", -1.0);

	testMainFloat("def main() float : 3.0 * 4", 12.0);
	testMainFloat("def main() float : 3 * 4.0", 12.0);

	testMainFloat("def main() float : 12.0 / 4", 3.0);
	testMainFloat("def main() float : 12 / 4.0", 3.0);
	
	// Test with nodes that can't be constant-folded.
	// Addition
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : f(x) + 3", 2.0f, 7.0f);
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : 3 + f(x)", 2.0f, 7.0f);

	// Subtraction
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : f(x) - 3", 2.0f, 1.0f);
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : 3 - f(x)", 2.0f, -1.0f);

	// Multiplication
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : f(x) * 3", 2.0f, 12.0f);
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : 3 * f(x)", 2.0f, 12.0f);

	// Division
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : f(x) / 3", 3.0f, 3.0f);
	// Can't be done as f(x) might be zero:
	// testMainFloatArg("def f(float x) float : x*x      def main(float x) float : 3 / f(x)", 2.0f, 12.0f);

	// NOTE: this one can't convert because f(x) + 3 might be zero.
	//testMainFloatArg("def f(float x) float : x*x      def main(float x) float : 14 / (f(x) + 3)", 2.0f, 2.0f);
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : 14 / (f(2) + 3)", 2.0f, 2.0f);
	testMainFloatArg("def f(int x) int : x*x	      def main(float x) float : 14 / (f(2) + 3)", 2.0f, 2.0f);
	testMainFloatArg("def f<T>(T x) T : x*x           def main(float x) float : 14 / (f(2) + 3)", 2.0, 2.0f);

	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : f(x) * 2 + 1", 2.0f, 9.0f);
	
	testMainFloatArg("def main(float x) float : ( x + x) * (-0.4)", 2.0f, -1.6f);

	testMainFloatArg("def main(float x) float : (x + x) - 1.5", 2.0f, 2.5f);
	//testMainFloatArg("def main(float x) float : (x + x) -1.5", 2.0f, 2.0); // NOTE: this works in C++. (e.g. the -1.5 is interpreted as a binary subtraction)
	
	// Division
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : f(x) / 3", 3.0f, 3.0f);


	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : f(x) * (1.0 / 3.0)", 3.0f, 3.0f);
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : f(x) * (1 / 3.0)", 3.0f, 3.0f);
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : f(x) * (1.0 / 3)", 3.0f, 3.0f);

	// Division
	testMainFloatArg("def f(float x) float : x*x      def main(float x) float : 1.0 / 3.0", 3.0f, 1.0f / 3.0f);



	// Test promotion to match function return type:
	testMainFloat("def main() float : 3", 3.0);

	testMainFloat("def main() float : 1.0 + (2 + 3)", 6.0);
	
	testMainFloat("def main() float : 1.0 + 2 + 3", 6.0);
	
	// Test implicit conversion from int to float in addition operation with a function call
	//testMainFloat("def f(int x) : x*x    def main() float : 1.0 + f(2)", 5.0f);

	testMainFloat("def main() float : (1.0 + 2.0) + (3 + 4)", 10.0);
	testMainFloat("def main() float : (1.0 + 2) + (3 + 4)", 10.0);


	// Integer comparisons:
	// Test <=
	testMainInteger("def main() int : if(1 <= 2, 10, 20)", 10);
	testMainInteger("def main() int : if(1 <= 1, 10, 20)", 10);
	testMainInteger("def main() int : if(3 <= 1, 10, 20)", 20);

	// Test >=
	testMainInteger("def main() int : if(1 >= 2, 10, 20)", 20);
	testMainInteger("def main() int : if(1 >= 1, 10, 20)", 10);
	testMainInteger("def main() int : if(3 >= 1, 10, 20)", 10);

	// Test <
	testMainInteger("def main() int : if(1 < 2, 10, 20)", 10);
	testMainInteger("def main() int : if(3 < 1, 10, 20)", 20);

	// Test >
	testMainInteger("def main() int : if(1 > 2, 10, 20)", 20);
	testMainInteger("def main() int : if(3 > 1, 10, 20)", 10);

	// Test ==
	testMainInteger("def main() int : if(1 == 1, 10, 20)", 10);
	testMainInteger("def main() int : if(1 == 2, 10, 20)", 20);

	// Test !=
	testMainInteger("def main() int : if(1 != 1, 10, 20)", 20);
	testMainInteger("def main() int : if(1 != 2, 10, 20)", 10);


	// Float comparisons:
	// Test <=
	testMainFloat("def main() float : if(1.0 <= 2.0, 10.0, 20.0)", 10.0);
	testMainFloat("def main() float : if(1.0 <= 1.0, 10.0, 20.0)", 10.0);
	testMainFloat("def main() float : if(3.0 <= 1.0, 10.0, 20.0)", 20.0);

	// Test >=
	testMainFloat("def main() float : if(1.0 >= 2.0, 10.0, 20.0)", 20.0);
	testMainFloat("def main() float : if(1.0 >= 1.0, 10.0, 20.0)", 10.0);
	testMainFloat("def main() float : if(3.0 >= 1.0, 10.0, 20.0)", 10.0);

	// Test <
	testMainFloat("def main() float : if(1.0 < 2.0, 10.0, 20.0)", 10.0);
	testMainFloat("def main() float : if(3.0 < 1.0, 10.0, 20.0)", 20.0);

	// Test >
	testMainFloat("def main() float : if(1.0 > 2.0, 10.0, 20.0)", 20.0);
	testMainFloat("def main() float : if(3.0 > 1.0, 10.0, 20.0)", 10.0);

	// Test ==
	testMainFloat("def main() float : if(1.0 == 1.0, 10.0, 20.0)", 10.0);
	testMainFloat("def main() float : if(1.0 == 2.0, 10.0, 20.0)", 20.0);

	// Test !=
	testMainFloat("def main() float : if(1.0 != 1.0, 10.0, 20.0)", 20.0);
	testMainFloat("def main() float : if(1.0 != 2.0, 10.0, 20.0)", 10.0);


	// ===================================================================
	// Test implicit conversions from int to float in comparisons
	// ===================================================================
	// Comparison between two literals:

	// Test a comparison that returns true
	testMainFloat("def main() float : if(1.0 <= 2, 10.0, 20.0)", 10.0);
	testMainFloat("def main() float : if(1 <= 2.0, 10.0, 20.0)", 10.0);

	// Test a comparison that returns false
	testMainFloat("def main() float : if(3 <= 1.0, 10.0, 20.0)", 20.0);
	testMainFloat("def main() float : if(3.0 <= 1, 10.0, 20.0)", 20.0);

	// Comparison between a variable and a literal:
	testMainFloatArg("def main(float x) float : if(x <= 2, 10.0, 20.0)", 1.0, 10.0);
	testMainFloatArg("def main(float x) float : if(x <= 2, 10.0, 20.0)", 3.0, 20.0);

	testMainFloatArg("def main(float x) float : if(2 <= x, 10.0, 20.0)", 3.0, 10.0);
	testMainFloatArg("def main(float x) float : if(2 <= x, 10.0, 20.0)", 1.0, 20.0);




	// Test 'if'
	testMainInteger("def main() int : if(true, 2, 3)", 2);
	testMainInteger("def main() int : if(false, 2, 3)", 3);

	// Test 'if' with structures as the return type
	testMainInteger(
		"struct s { int a, int b }   \n\
		def main() int : a(if(true, s(1, 2), s(3, 4)))", 
		1);
	testMainInteger(
		"struct s { int a, int b }   \n\
		def main() int : a(if(false, s(1, 2), s(3, 4)))", 
		3);

	// Test 'if' with vectors as the return type
	testMainFloat(
		"def main() float : e0(if(true, [1.0, 2.0, 3.0, 4.0]v, [10.0, 20.0, 30.0, 40.0]v))", 
		1.0f);
	testMainFloat(
		"def main() float : e0(if(false, [1.0, 2.0, 3.0, 4.0]v, [10.0, 20.0, 30.0, 40.0]v))", 
		10.0f);



	// Test call to external function
	testMainFloat("def main() float : testFunc(3.0)", 10.0);


	
	// Simple test
	testMainFloat("def main() float : 1.0", 1.0);

	// Test addition expression
	testMainFloat("def main() float : 1.0 + 2.0", 3.0);

	// Test integer addition
	testMainInteger("def main() int : 1 + 2", 3);

	// Test multiple integer additions
	testMainInteger("def main() int : 1 + 2 + 3", 6);
	testMainInteger("def main() int : 1 + 2 + 3 + 4", 10);

	// Test multiple integer subtractions
	testMainInteger("def main() int : 1 - 2 - 3 - 4", 1 - 2 - 3 - 4);

	// Test left-to-right associativity
	// Note that right-to-left associativity here would give 2 - (3 + 4) = -5
	assert(2 - 3 + 4 == (2 - 3) + 4);
	assert(2 - 3 + 4 == 3);
	testMainInteger("def main() int : 2 - 3 + 4", 3);


	// Test multiplication expression
	testMainFloat("def main() float : 3.0 * 2.0", 6.0);




	// Test integer multiplication
	testMainInteger("def main() int : 2 * 3", 6);

	// Test multiple integer multiplication
	testMainInteger("def main() int : 2 * 3 * 4 * 5", 2 * 3 * 4 * 5);

	// Test left-to-right associativity of division
	// 12 / 4 / 3 = (12 / 4) / 3 = 1
	// whereas
	// 12 / (4 / 3) = 12 / 1 = 12
	testMainInteger("def main() int : 12 / 4 / 3", 1);


	// Test float subtraction
	testMainFloat("def main() float : 3.0 - 2.0", 1.0);

	// Test integer subtraction
	testMainInteger("def main() int : 2 - 3", -1);

	// Test precedence
	testMainInteger("def main() int : 2 + 3 * 4", 14);
	testMainInteger("def main() int : 2 * 3 + 4", 10);

	// Test parentheses controlling order of operation
	testMainInteger("def main() int : (2 + 3) * 4", 20);
	testMainInteger("def main() int : 2 * (3 + 4)", 14);


	// Test unary minus in front of parenthesis
	testMainInteger("def main() int : -(1 + 2)", -3);

	// Test floating point unary minus
	testMainFloat("def main() float : -(1.0 + 2.0)", -3.0);

	// Test unary minus in front of var
	testMainInteger("def f(int x) int : -x        def main() int : f(3)", -3);




	// Test simple function call
	testMainFloat("def f(float x) float : x        def main() float : f(3.0)", 3.0);

	// Test function call with two parameters
	testMainFloat("def f(float x, float y) float : x        def main() float : f(3.0, 4.0)", 3.0);
	testMainFloat("def f(float x, float y) float : y        def main() float : f(3.0, 4.0)", 4.0);

	// Test inferred return type (for f)
	testMainFloat("def f(float x) : x        def main() float : f(3.0)", 3.0);

	// Test two call levels of inferred return type (f, g)
	testMainFloat("def f(float x) : g(x)    def g(float x) : x    def main() float : f(3.0)", 3.0);
	testMainFloat("def f(float x) : x    def g(float x) : f(x)    def main() float : g(3.0)", 3.0);

	// Test generic function
	testMainFloat("def f<T>(T x) T : x        def main() float : f(2.0)", 2.0);

	// Test generic function with inferred return type (f)
	testMainFloat("def f<T>(T x) : x        def main() float : f(2.0)", 2.0);


	// Test function overloading - call with int param, should select 1st overload
	testMainFloat("def overloadedFunc(int x) float : 4.0 \
				  def overloadedFunc(float x) float : 5.0 \
				  def main() float: overloadedFunc(1)", 4.0f);

	// Call with float param, should select 2nd overload.
	testMainFloat("def overloadedFunc(int x) float : 4.0 \
				  def overloadedFunc(float x) float : 5.0 \
				  def main() float: overloadedFunc(1.0)", 5.0f);

	// Test binding to different overloaded functions based on type parameter to generic function
	testMainFloat("def overloadedFunc(int x) float : 4.0 \
				  def overloadedFunc(float x) float : 5.0 \
				  def f<T>(T x) float: overloadedFunc(x)\
				  def main() float : f(1)", 4.0f);

	// Call f with float param
	testMainFloat("def overloadedFunc(int x) float : 4.0 \
				  def overloadedFunc(float x) float : 5.0 \
				  def f<T>(T x) float: overloadedFunc(x)\
				  def main() float : f(1.0)", 5.0f);

	// Test let
	testMainFloat("def f(float x) float : \
				  let z = 2.0 \
				  in \
				  z \
				  def main() float : f(0.0)", 2.0);

	// Test two let clauses in a let block
	testMainFloat("def f(float x) float : \
				  let	\
					z = 2.0 \
					y = 3.0 \
				  in \
					y + z \
				  def main() float : f(0.0)", 5.0);

	// Test nested let blocks
	testMainFloat("	def f(float x) float : \
					let	\
						z = 2.0 \
					in \
						let		\
							y = 10.0  \
						in				\
							y + z			\
				  def main() float : f(0.0)", 12.0);

	// Test nested let blocks with multiple let clauses per block
	testMainFloat("	def f(float a) float : \
				  let	\
					x = 1.0  \
					y = 2.0 \
				  in \
					let		\
						z = 10.0  \
						w = 20.0  	\
					in				\
						x + y + z + w			\
				  def main() float : f(0.0)", 33.0);

	// Test two let clauses where one refers to the other.
	testMainFloat("def f() float : \
				  let	\
					z = 2.0 \
					y = z \
				  in \
					y \
				  def main() float : f()", 2.0);

	// Test two let clauses where one refers to the other (reverse order)
	/*testMainFloat("def f() float : \
				  let	\
					z = y \
					y = 2.0 \
				  in \
					y \
				  def main() float : f()", 2.0);*/
/*
	//testMainFloat("def f() float : \
	//			  let	\
	//				z = y \
	//				y = 2.0 \
	//			  in \
	//				y \
	//			  def main() float : f()", 2.0);

	// Test nested let blocks
	//testMainFloat("def f() float : \n\
	//			let	\n\
	//				x = 2.0 \n\
	//			in \n\
	//				let           \n\
	//					y = x     \n\
	//				in               \n\
	//					y           \n\
	//			def main() float : f()", 2.0);

	// Test Lambda in let
	//testMainFloat("def main() float :           \n\
	//			  let f = \\(float x) : x*x  in   \n\
	//			  f(2.0)", 4.0f);

	//testMainFloat("	def f(float x) float : x+1.0    \n\
	//					def main() float :							\n\
	//						let g = f									\n\
	//						in									\n\
	//							g(1.0)", 2.0f);		

	// Test variable capture: the returned lambda needs to capture the value of x.
	testMainFloat("	def makeFunc(float x) function<float> : \\() : x      \n\
					def main() float :                          \n\
					let f = makeFunc(2.0) in                    \n\
					f()", 2.0);



	// Test return of a lambda from a function
	testMainFloat("def makeLambda() : \\(float x) : x*x    \n\
					def main() float :           \n\
					let f = makeLambda()  in   \n\
				  f(2.0)", 4.0f);

	// Test generic lambda!!!
	//testMainFloat("def makeLambda() : \\<T>(T x) : x*x    \n\
	//				def main() float :           \n\
	//				let f = makeLambda()  in   \n\
	//			  f(2.0)", 4.0f);

	// Test Lambda passed as a function arg
	testMainFloat("def g(function<float, float> f, float x) : f(x)       \n\
					def main() float :           \n\
					g(\\(float x) : x*x*x, 2.0f)", 8.0f);


	// Test passing a normal function as an argument
	//TEMP: Can't do this yet as need to add code to compile globals in a version that takes captured var struct.
	//testMainFloat("def g(function<float, float> f, float x) : f(x)       \n\
	//			  def square(float x) : x*x                              \n\
	//				def main() float :           \n\
	//				g(square, 2.0f)", 4.0f);

	// Test 'compose' function: returns the composition of two functions
	// NOTE: this requires lexical closures to work :)
	//TEMP: Can't do this yet as need to add code to compile globals in a version that takes captured var struct.
	//testMainFloat("def compose(function<float, float> f, function<float, float> g) : \\(float x) : f(g(x))       \n\
	//				def addOne(float x) : x + 1.0                \n\
	//				def mulByTwo(float x) : x * 2.0                \n\
	//				def main() float :                         \n\
	//					let z = compose(addOne, mulByTwo)  in \n\
	//					z(1.0)", 3.0f);


	// Test closures

	
	//// Test variable capture: the returned lambda needs to capture the value of x.
	testMainFloat("	def makeFunc(float x) function<float> : \\() : x      \n\
					def main() float :                          \n\
					let f = makeFunc(2.0) in                    \n\
					f()", 2.0);


	//// Test variable capture with two captured variables.
	testMainFloat("	def makeFunc(float x, float y) function<float> : \\() : x + y     \n\
					def main() float :                          \n\
					let f = makeFunc(2.0, 3.0) in                    \n\
					f()", 5.0);
	
	// Test capture of one variable and one usual argument
	testMainFloat("	def makeFunc(float x) function<float, float> : \\(float y) : x + y     \n\
					def main() float :                          \n\
					let f = makeFunc(2.0) in                    \n\
					f(3.0)", 5.0);

	// Test capture of let variable.
	/*
	NOTE: Disabled, because these tests leak due to call to allocateRefCountedStructure().
	testMainFloat("	def main() float :                          \n\
					let z = 3.0 in                     \n\
					let f = \\() : z  in                    \n\
					f()", 3.0);
	*/

	// TODO: test two lets varables at same level

	// Test capture of let variable up one level.
	/*
	NOTE: Disabled, because these tests leak due to call to allocateRefCountedStructure().
	testMainFloat("	def main() float :                          \n\
					let x = 3.0 in                         \n\
					let z = 4.0 in                         \n\
					let f = \\() : x  in                    \n\
					f()", 3.0);

	testMainFloat("	def main() float :                          \n\
					let x = 3.0 in                         \n\
					let z = 4.0 in                         \n\
					let f = \\() : z  in                    \n\
					f()", 4.0);
	*/



	// Test addition expression in let
	testMainFloat("def f(float x) float : \
				  let z = 2.0 + 3.0 in\
				  z \
				  def main() float : f(0.0)", 5.0);

	// Test function expression in let
	testMainFloat("	def g(float x) float : x + 1.0 \
					def f(float x) float : \
					let z = g(1.0) in \
					z \
					def main() float : f(0.0)", 2.0);

	// Test function argument in let
	testMainFloat("	def f(float x) float : \
					let z = x + 1.0 in\
					z \
					def main() float : f(2.0)", 3.0);


	// Test use of let variable twice
	testMainFloat("	def f(float x) float : \
				  let z = x + 1.0 in\
				  z + z\
				  def main() float : f(2.0)", 6.0);


	// Test creation of struct
	{
		Float4Struct a(1.0f, -2.0f, 3.0f, -4.0f);
		Float4Struct target_result(std::sqrt(1.0f), std::sqrt(2.0f), std::sqrt(3.0f), std::sqrt(4.0f));
		testFloat4Struct(
			"struct Float4Struct { vector<float, 4> v } \n\
			def sqrt(Float4Struct f) : Float4Struct(sqrt(f.v))		\n\
			def main(Float4Struct a, Float4Struct b) Float4Struct : \n\
				let													\n\
					a = Float4Struct([1.0, 2.0, 3.0, 4.0]v)			\n\
				in													\n\
					sqrt(a)",
			a, a, target_result
		);
	}


	// Test struct
	testMainFloat("struct Complex { float re, float im } \
				  def main() float : re(Complex(2.0, 3.0))", 2.0f);
	
	testMainFloat("struct Complex { float re, float im } \
 				  def main() float : im(Complex(2.0, 3.0))", 3.0f);

	// Test struct in struct
	testMainFloat("struct Complex { float re, float im } \
				  struct ComplexPair { Complex a, Complex b } \
				  def main() float : im(a(ComplexPair(Complex(2.0, 3.0), Complex(4.0, 5.0))))",
				  3.0f);

	// Test field access with '.' applied to a variable.
	testMainFloat("struct Complex { float re, float im } \n\
 				  def main() float : \n\
					let z = Complex(2.0, 3.0) in \n\
					z.im", 3.0f);

	// Test field access with '.' applied to a structure literal.
	testMainFloat("struct Complex { float re, float im } \n\
 				  def main() float : \n\
					Complex(2.0, 3.0).im", 3.0f);

	// Test field access with '.' applied to a function call expression.
	testMainFloat("struct Complex { float re, float im } \n\
				  def f() Complex : Complex(1.0, 2.0) \n\
 				  def main() float : \n\
					f().im", 2.0f);


	// Test field access for nested structures.
	testMainFloat("struct Complex { float re, float im } \n\
				  struct ComplexPair { Complex a, Complex b } \n\
				  def main() float : ComplexPair(Complex(2.0, 3.0), Complex(4.0, 5.0)).a.im",
				  3.0f);


	// Test vector
	testMainFloat("	def main() float : \
					let x = [1.0, 2.0, 3.0, 4.0]v in\
					e0(x)", 1.0f);
	testMainFloat("	def main() float : \
					let x = [1.0, 2.0, 3.0, 4.0]v in \
					e1(x)", 2.0f);

	// Test vector being returned from a function
	testMainFloat("	def f() vector<float, 4> : [1.0, 2.0, 3.0, 4.0]v \
					def main() float : e2(f())", 3.0f);

	// Test vector addition
	testMainFloat("	def main() float : \
					let x = [1.0, 2.0, 3.0, 4.0]v \
					y = [10.0, 20.0, 30.0, 40.0]v in\
					e1(x + y)", 22.0f);

	// Test vector subtraction
	testMainFloat("	def main() float : \
					let x = [1.0, 2.0, 3.0, 4.0]v \
					y = [10.0, 20.0, 30.0, 40.0]v in \
					e1(x - y)", -18.0f);

	// Test vector * float multiplication
	testMainFloat("	def main() float : \
				  let x = [1.0, 2.0, 3.0, 4.0]v in \
			  e1(x * 10.0)", 2.0f * 10.0f);

	// Test vector * vector multiplication
	testMainFloat("	def main() float : \
				  let x = [1.0, 2.0, 3.0, 4.0]v \
				  y = [10.0, 20.0, 30.0, 40.0]v in\
				e1(x * y)", 2.0f * 20.0f);

	// Test vector<int> * vector<int> multiplication
	testMainInteger("	def main() int : \
				  let x = [1, 2, 3, 4]v \
				  y = [10, 20, 30, 40]v in\
				e1(x * y)", 2 * 20);

	// Test vector * scalar multiplication
	testMainFloat("	def mul(vector<float, 4> v, float x) vector<float, 4> : v * [x, x, x, x]v \n\
					def main() float : \
						let x = [1.0, 2.0, 3.0, 4.0]v \
						y = 10.0 in \
						mul(x, y).e1", 2.0f * 10.0f);

	testMainFloatArg("	def mul(vector<float, 4> v, float x) vector<float, 4> : v * [x, x, x, x]v \n\
				  def main(float x) float : \
				  let v = [1.0, 2.0, 3.0, 4.0]v in\
				  e1(mul(v, x))", 10.0f, 2.0f * 10.0f);

	// Try dot product
	testMainFloatArg("	def main(float x) float : \
					 let v = [x, x, x, x]v in\
					 dot(v, v)", 2.0f, 16.0f);

	testMainFloatArg("	def main(float x) float : \
					 let v = [x, x, x, x, x, x, x, x]v in\
					 dot(v, v)", 2.0f, 32.0f);

	// Test vector min
	testMainFloat("	def main() float : \
					 let a = [1.0, 2.0, 3.0, 4.0]v \
					 b = [11.0, 12.0, 13.0, 14.0]v in\
					 e2(min(a, b))", 3.0);
	testMainFloat("	def main() float : \
				  let a = [1.0, 2.0, 3.0, 4.0]v \
				  b = [11.0, 12.0, 13.0, 14.0]v in \
				  e2(min(b, a))", 3.0);

	// Test vector max
	testMainFloat("	def main() float : \
				  let a = [1.0, 2.0, 3.0, 4.0]v \
				  b = [11.0, 12.0, 13.0, 14.0]v in \
				  e2(max(a, b))", 13.0);
	testMainFloat("	def main() float : \
				  let a = [1.0, 2.0, 3.0, 4.0]v \
				  b = [11.0, 12.0, 13.0, 14.0]v in \
				  e2(max(b, a))", 13.0);
				  

	testMainFloat("	def clamp(vector<float, 4> x, vector<float, 4> lowerbound, vector<float, 4> upperbound) vector<float, 4> : max(lowerbound, min(upperbound, x))  \n\
					def make_v4f(float x) vector<float, 4> : [x, x, x, x]v  \n\
					def main() float : \
					let a = [1.0, 2.0, 3.0, 4.0]v in\
					e2(clamp(a, make_v4f(2.0), make_v4f(2.5)))", 2.5);

	testMainFloat("	struct PolarisationVec { vector<float, 8> e } \n\
																	\n\
					def clamp(vector<float, 4> x, vector<float, 4> lowerbound, vector<float, 4> upperbound) vector<float, 4> : max(lowerbound, min(upperbound, x))  \n\
																																					\n\
					def clamp(PolarisationVec x, float lowerbound, float upperbound) PolarisationVec : \n\
						let lo = [e0(e(x)), e1(e(x)), e2(e(x)), e3(e(x))]v   \n\
						hi = [e4(e(x)), e5(e(x)), e6(e(x)), e7(e(x))]v   \n\
						clamped_lo = clamp(lo, make_v4f(lowerbound), make_v4f(upperbound))   \n\
						clamped_hi = clamp(hi, make_v4f(lowerbound), make_v4f(upperbound))  in \n\
						PolarisationVec([e0(clamped_lo), e1(clamped_lo), e2(clamped_lo), e3(clamped_lo), e0(clamped_hi), e1(clamped_hi), e2(clamped_hi), e3(clamped_hi)]v)   \n\
																																												\n\
				  def make_v4f(float x) vector<float, 4> : [x, x, x, x]v  \n\
																		\n\
				  def main() float : \
					let a = PolarisationVec([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]v) in \
					e5(e(clamp(a, 2.0, 2.5)))", 2.5);

	//class PolarisationVec
	//{
	//public:
	//	__m128 e[2];


	/* Try matrix * vec4f mult

	*/
	/*testMainFloatArg("	struct Matrix { vector<float, 4> r0, vector<float, 4> r1, vector<float, 4> r2, vector<float, 4> r3 } \n\
						def mul(Matrix m, vector<float, 4> v) vector<float, 4> : [dot(r0(m), v), dot(r1(m), v), dot(r2(m), v), dot(r3(m), v)]v  \n\
						def main(float x) float : \
						let m = Matrix([x, x, x, x]v, [x, x, x, x]v, [x, x, x, x]v, [x, x, x, x]v) \
					 let v = [1.0, 2.0, 3.0, 4.0]v \
					 e0(mul(m, v))", 1.0f, 10.0f);*/


	// Test structure being returned from main function
	{
		struct TestStruct
		{
			float a;
			float b;
			float c;
			float d;

			bool operator == (const TestStruct& other) const { return (a == other.a) && (b == other.b); }
		};

		TestStruct target_result;
		target_result.a = 1;
		target_result.b = 2;
		target_result.c = 3;
		target_result.d = 4;

		std::string test_func = "struct TestStruct { float a, float b, float c, float d } \
			def main() TestStruct : TestStruct(1.0, 2.0, 3.0, 4.0)";
		//testMainStruct<TestStruct>(test_func, target_result);

		test_func = "struct TestStruct { float a, float b, float c, float d } \
			def main() TestStruct : TestStruct(1.0, 2.0, 3.0, 4.0)";
		//testMainStruct<TestStruct>(test_func, target_result);

	}
	{
		struct TestStruct
		{
			float a;
			float b;
			float c;
			float d;

			bool operator == (const TestStruct& other) const { return (a == other.a) && (b == other.b); }
		};

		TestStruct target_result;
		target_result.a = 5;
		target_result.b = 6;
		target_result.c = 3;
		target_result.d = 4;

		struct TestStructIn
		{
			float x;
			float y;
		};

		TestStructIn in;
		in.x = 5;
		in.y = 6;

		std::string test_func = "struct TestStruct { float a, float b, float c, float d } \
			struct TestStructIn { float x, float y } \
			def main(TestStructIn in_s) TestStruct : TestStruct(x(in_s), y(in_s), 3.0, 4.0)";
		//testMainStructInputAndOutput(test_func, in, target_result);
	}

	

	// Test vector in structure
	{


		StructWithVec in;
		in.a.e[0] = 1;
		in.a.e[1] = 2;
		in.a.e[2] = 3;
		in.a.e[3] = 4;

		in.b.e[0] = 4;
		in.b.e[1] = 5;
		in.b.e[2] = 6;
		in.b.e[3] = 7;

		in.data2 = 10;

		StructWithVec target_result;
		target_result.a.e[0] = 5;
		target_result.a.e[1] = 7;
		target_result.a.e[2] = 9;
		target_result.a.e[3] = 11;

		target_result.b.e[0] = 1;
		target_result.b.e[1] = 2;
		target_result.b.e[2] = 3;
		target_result.b.e[3] = 4;

		target_result.data2 = 10;

		testVectorInStruct(
							"struct StructWithVec { vector<float, 4> a, vector<float, 4> b, float data2 } \n\
							def main(StructWithVec in_s) StructWithVec : \n\
								StructWithVec(  \n\
								a(in_s) + b(in_s), #[e0(a(in_s)) + e0(b(in_s)), e1(a(in_s)) + e1(b(in_s)), e2(a(in_s)) + e2(b(in_s)), e3(a(in_s)) + e3(b(in_s))]v, \n\
								a(in_s), \n\
								data2(in_s))", 
							in, target_result);
	}

	std::cout << "===================All LanguageTests passed.=============================" << std::endl;
}


}
