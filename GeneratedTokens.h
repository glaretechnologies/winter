// Autogenerated by make_tokens.rb on Sat Aug 15 19:00:42 +1200 2009


const unsigned int COMMA_TOKEN = 10;
class COMMA_Token : public TokenBase
{
public:
 COMMA_Token(unsigned int char_index) : TokenBase(char_index, COMMA_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int OPEN_PARENTHESIS_TOKEN = 11;
class OPEN_PARENTHESIS_Token : public TokenBase
{
public:
 OPEN_PARENTHESIS_Token(unsigned int char_index) : TokenBase(char_index, OPEN_PARENTHESIS_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return true; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int CLOSE_PARENTHESIS_TOKEN = 12;
class CLOSE_PARENTHESIS_Token : public TokenBase
{
public:
 CLOSE_PARENTHESIS_Token(unsigned int char_index) : TokenBase(char_index, CLOSE_PARENTHESIS_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return true; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int OPEN_BRACE_TOKEN = 13;
class OPEN_BRACE_Token : public TokenBase
{
public:
 OPEN_BRACE_Token(unsigned int char_index) : TokenBase(char_index, OPEN_BRACE_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int CLOSE_BRACE_TOKEN = 14;
class CLOSE_BRACE_Token : public TokenBase
{
public:
 CLOSE_BRACE_Token(unsigned int char_index) : TokenBase(char_index, CLOSE_BRACE_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int COLON_TOKEN = 15;
class COLON_Token : public TokenBase
{
public:
 COLON_Token(unsigned int char_index) : TokenBase(char_index, COLON_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int RIGHT_ARROW_TOKEN = 16;
class RIGHT_ARROW_Token : public TokenBase
{
public:
 RIGHT_ARROW_Token(unsigned int char_index) : TokenBase(char_index, RIGHT_ARROW_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int EQUALS_TOKEN = 17;
class EQUALS_Token : public TokenBase
{
public:
 EQUALS_Token(unsigned int char_index) : TokenBase(char_index, EQUALS_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int PLUS_TOKEN = 18;
class PLUS_Token : public TokenBase
{
public:
 PLUS_Token(unsigned int char_index) : TokenBase(char_index, PLUS_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "add"; }
 virtual int precedence() const { return 100; }
};

const unsigned int MINUS_TOKEN = 19;
class MINUS_Token : public TokenBase
{
public:
 MINUS_Token(unsigned int char_index) : TokenBase(char_index, MINUS_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "sub"; }
 virtual int precedence() const { return 100; }
};

const unsigned int FORWARDS_SLASH_TOKEN = 20;
class FORWARDS_SLASH_Token : public TokenBase
{
public:
 FORWARDS_SLASH_Token(unsigned int char_index) : TokenBase(char_index, FORWARDS_SLASH_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "div"; }
 virtual int precedence() const { return 200; }
};

const unsigned int BACK_SLASH_TOKEN = 21;
class BACK_SLASH_Token : public TokenBase
{
public:
 BACK_SLASH_Token(unsigned int char_index) : TokenBase(char_index, BACK_SLASH_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int ASTERISK_TOKEN = 22;
class ASTERISK_Token : public TokenBase
{
public:
 ASTERISK_Token(unsigned int char_index) : TokenBase(char_index, ASTERISK_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "mul"; }
 virtual int precedence() const { return 200; }
};

const unsigned int LEFT_ANGLE_BRACKET_TOKEN = 23;
class LEFT_ANGLE_BRACKET_Token : public TokenBase
{
public:
 LEFT_ANGLE_BRACKET_Token(unsigned int char_index) : TokenBase(char_index, LEFT_ANGLE_BRACKET_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "lt"; }
 virtual int precedence() const { return 60; }
};

const unsigned int RIGHT_ANGLE_BRACKET_TOKEN = 24;
class RIGHT_ANGLE_BRACKET_Token : public TokenBase
{
public:
 RIGHT_ANGLE_BRACKET_Token(unsigned int char_index) : TokenBase(char_index, RIGHT_ANGLE_BRACKET_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "gt"; }
 virtual int precedence() const { return 60; }
};

const unsigned int LESS_EQUAL_TOKEN = 25;
class LESS_EQUAL_Token : public TokenBase
{
public:
 LESS_EQUAL_Token(unsigned int char_index) : TokenBase(char_index, LESS_EQUAL_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "lte"; }
 virtual int precedence() const { return 60; }
};

const unsigned int GREATER_EQUAL_TOKEN = 26;
class GREATER_EQUAL_Token : public TokenBase
{
public:
 GREATER_EQUAL_Token(unsigned int char_index) : TokenBase(char_index, GREATER_EQUAL_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "gte"; }
 virtual int precedence() const { return 60; }
};

const unsigned int DOUBLE_EQUALS_TOKEN = 27;
class DOUBLE_EQUALS_Token : public TokenBase
{
public:
 DOUBLE_EQUALS_Token(unsigned int char_index) : TokenBase(char_index, DOUBLE_EQUALS_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "eq"; }
 virtual int precedence() const { return 50; }
};

const unsigned int NOT_EQUALS_TOKEN = 28;
class NOT_EQUALS_Token : public TokenBase
{
public:
 NOT_EQUALS_Token(unsigned int char_index) : TokenBase(char_index, NOT_EQUALS_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "neq"; }
 virtual int precedence() const { return 50; }
};

const unsigned int AND_TOKEN = 29;
class AND_Token : public TokenBase
{
public:
 AND_Token(unsigned int char_index) : TokenBase(char_index, AND_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "and"; }
 virtual int precedence() const { return 40; }
};

const unsigned int OR_TOKEN = 30;
class OR_Token : public TokenBase
{
public:
 OR_Token(unsigned int char_index) : TokenBase(char_index, OR_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "or"; }
 virtual int precedence() const { return 30; }
};
const std::string tokenName(unsigned int t)
{
	switch(t) {
		case 10: return "COMMA";
		case 11: return "OPEN_PARENTHESIS";
		case 12: return "CLOSE_PARENTHESIS";
		case 13: return "OPEN_BRACE";
		case 14: return "CLOSE_BRACE";
		case 15: return "COLON";
		case 16: return "RIGHT_ARROW";
		case 17: return "EQUALS";
		case 18: return "PLUS";
		case 19: return "MINUS";
		case 20: return "FORWARDS_SLASH";
		case 21: return "BACK_SLASH";
		case 22: return "ASTERISK";
		case 23: return "LEFT_ANGLE_BRACKET";
		case 24: return "RIGHT_ANGLE_BRACKET";
		case 25: return "LESS_EQUAL";
		case 26: return "GREATER_EQUAL";
		case 27: return "DOUBLE_EQUALS";
		case 28: return "NOT_EQUALS";
		case 29: return "AND";
		case 30: return "OR";
		default: return "[Unknown]";
	}
}
