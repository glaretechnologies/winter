// Autogenerated by make_tokens.rb on 2010-11-01 21:50:39 +1300


const unsigned int COMMA_TOKEN = 10;
class COMMA_Token : public TokenBase
{
public:
 COMMA_Token(unsigned int char_index) : TokenBase(char_index, COMMA_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int OPEN_PARENTHESIS_TOKEN = 11;
class OPEN_PARENTHESIS_Token : public TokenBase
{
public:
 OPEN_PARENTHESIS_Token(unsigned int char_index) : TokenBase(char_index, OPEN_PARENTHESIS_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return true; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int CLOSE_PARENTHESIS_TOKEN = 12;
class CLOSE_PARENTHESIS_Token : public TokenBase
{
public:
 CLOSE_PARENTHESIS_Token(unsigned int char_index) : TokenBase(char_index, CLOSE_PARENTHESIS_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return true; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int OPEN_BRACE_TOKEN = 13;
class OPEN_BRACE_Token : public TokenBase
{
public:
 OPEN_BRACE_Token(unsigned int char_index) : TokenBase(char_index, OPEN_BRACE_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int CLOSE_BRACE_TOKEN = 14;
class CLOSE_BRACE_Token : public TokenBase
{
public:
 CLOSE_BRACE_Token(unsigned int char_index) : TokenBase(char_index, CLOSE_BRACE_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int OPEN_SQUARE_BRACKET_TOKEN = 15;
class OPEN_SQUARE_BRACKET_Token : public TokenBase
{
public:
 OPEN_SQUARE_BRACKET_Token(unsigned int char_index) : TokenBase(char_index, OPEN_SQUARE_BRACKET_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int CLOSE_SQUARE_BRACKET_TOKEN = 16;
class CLOSE_SQUARE_BRACKET_Token : public TokenBase
{
public:
 CLOSE_SQUARE_BRACKET_Token(unsigned int char_index) : TokenBase(char_index, CLOSE_SQUARE_BRACKET_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int COLON_TOKEN = 17;
class COLON_Token : public TokenBase
{
public:
 COLON_Token(unsigned int char_index) : TokenBase(char_index, COLON_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int RIGHT_ARROW_TOKEN = 18;
class RIGHT_ARROW_Token : public TokenBase
{
public:
 RIGHT_ARROW_Token(unsigned int char_index) : TokenBase(char_index, RIGHT_ARROW_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int EQUALS_TOKEN = 19;
class EQUALS_Token : public TokenBase
{
public:
 EQUALS_Token(unsigned int char_index) : TokenBase(char_index, EQUALS_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int PLUS_TOKEN = 20;
class PLUS_Token : public TokenBase
{
public:
 PLUS_Token(unsigned int char_index) : TokenBase(char_index, PLUS_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "add"; }
 virtual int precedence() const { return 100; }
};

const unsigned int MINUS_TOKEN = 21;
class MINUS_Token : public TokenBase
{
public:
 MINUS_Token(unsigned int char_index) : TokenBase(char_index, MINUS_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "sub"; }
 virtual int precedence() const { return 100; }
};

const unsigned int FORWARDS_SLASH_TOKEN = 22;
class FORWARDS_SLASH_Token : public TokenBase
{
public:
 FORWARDS_SLASH_Token(unsigned int char_index) : TokenBase(char_index, FORWARDS_SLASH_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "div"; }
 virtual int precedence() const { return 200; }
};

const unsigned int BACK_SLASH_TOKEN = 23;
class BACK_SLASH_Token : public TokenBase
{
public:
 BACK_SLASH_Token(unsigned int char_index) : TokenBase(char_index, BACK_SLASH_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int ASTERISK_TOKEN = 24;
class ASTERISK_Token : public TokenBase
{
public:
 ASTERISK_Token(unsigned int char_index) : TokenBase(char_index, ASTERISK_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "mul"; }
 virtual int precedence() const { return 200; }
};

const unsigned int LEFT_ANGLE_BRACKET_TOKEN = 25;
class LEFT_ANGLE_BRACKET_Token : public TokenBase
{
public:
 LEFT_ANGLE_BRACKET_Token(unsigned int char_index) : TokenBase(char_index, LEFT_ANGLE_BRACKET_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "lt"; }
 virtual int precedence() const { return 60; }
};

const unsigned int RIGHT_ANGLE_BRACKET_TOKEN = 26;
class RIGHT_ANGLE_BRACKET_Token : public TokenBase
{
public:
 RIGHT_ANGLE_BRACKET_Token(unsigned int char_index) : TokenBase(char_index, RIGHT_ANGLE_BRACKET_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "gt"; }
 virtual int precedence() const { return 60; }
};

const unsigned int LESS_EQUAL_TOKEN = 27;
class LESS_EQUAL_Token : public TokenBase
{
public:
 LESS_EQUAL_Token(unsigned int char_index) : TokenBase(char_index, LESS_EQUAL_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "lte"; }
 virtual int precedence() const { return 60; }
};

const unsigned int GREATER_EQUAL_TOKEN = 28;
class GREATER_EQUAL_Token : public TokenBase
{
public:
 GREATER_EQUAL_Token(unsigned int char_index) : TokenBase(char_index, GREATER_EQUAL_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "gte"; }
 virtual int precedence() const { return 60; }
};

const unsigned int DOUBLE_EQUALS_TOKEN = 29;
class DOUBLE_EQUALS_Token : public TokenBase
{
public:
 DOUBLE_EQUALS_Token(unsigned int char_index) : TokenBase(char_index, DOUBLE_EQUALS_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "eq"; }
 virtual int precedence() const { return 50; }
};

const unsigned int NOT_EQUALS_TOKEN = 30;
class NOT_EQUALS_Token : public TokenBase
{
public:
 NOT_EQUALS_Token(unsigned int char_index) : TokenBase(char_index, NOT_EQUALS_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "neq"; }
 virtual int precedence() const { return 50; }
};

const unsigned int AND_TOKEN = 31;
class AND_Token : public TokenBase
{
public:
 AND_Token(unsigned int char_index) : TokenBase(char_index, AND_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "and"; }
 virtual int precedence() const { return 40; }
};

const unsigned int OR_TOKEN = 32;
class OR_Token : public TokenBase
{
public:
 OR_Token(unsigned int char_index) : TokenBase(char_index, OR_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return true; }
 virtual const std::string functionName() const { return "or"; }
 virtual int precedence() const { return 30; }
};

const unsigned int EXCLAMATION_MARK_TOKEN = 33;
class EXCLAMATION_MARK_Token : public TokenBase
{
public:
 EXCLAMATION_MARK_Token(unsigned int char_index) : TokenBase(char_index, EXCLAMATION_MARK_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return false; }
};

const unsigned int DOT_TOKEN = 34;
class DOT_Token : public TokenBase
{
public:
 DOT_Token(unsigned int char_index) : TokenBase(char_index, DOT_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return false; }
};


// Added manually:
const unsigned int QUESTION_MARK_TOKEN = 35;
class QUESTION_MARK_Token : public TokenBase
{
public:
 QUESTION_MARK_Token(unsigned int char_index) : TokenBase(char_index, QUESTION_MARK_TOKEN) {}
 virtual bool isLiteral() const { return false; }
 virtual bool isParanthesis() const { return false; }
 virtual bool isBinaryInfixOp() const { return false; }
};


inline const std::string tokenName(unsigned int t)
{
	switch(t) {
		case 10: return "COMMA";
		case 11: return "OPEN_PARENTHESIS";
		case 12: return "CLOSE_PARENTHESIS";
		case 13: return "OPEN_BRACE";
		case 14: return "CLOSE_BRACE";
		case 15: return "OPEN_SQUARE_BRACKET";
		case 16: return "CLOSE_SQUARE_BRACKET";
		case 17: return "COLON";
		case 18: return "RIGHT_ARROW";
		case 19: return "EQUALS";
		case 20: return "PLUS";
		case 21: return "MINUS";
		case 22: return "FORWARDS_SLASH";
		case 23: return "BACK_SLASH";
		case 24: return "ASTERISK";
		case 25: return "LEFT_ANGLE_BRACKET";
		case 26: return "RIGHT_ANGLE_BRACKET";
		case 27: return "LESS_EQUAL";
		case 28: return "GREATER_EQUAL";
		case 29: return "DOUBLE_EQUALS";
		case 30: return "NOT_EQUALS";
		case 31: return "AND";
		case 32: return "OR";
		case 33: return "EXCLAMATION_MARK";
		case 34: return "DOT";
		case 35: return "QUESTION_MARK_TOKEN";
		default: return "[Unknown]";
	}
}


inline Reference<TokenBase> makeTokenObject(unsigned int token_type, unsigned int char_index)
{
	switch(token_type) {
		case 10: return Reference<TokenBase>(new COMMA_Token(char_index));
		case 11: return Reference<TokenBase>(new OPEN_PARENTHESIS_Token(char_index));
		case 12: return Reference<TokenBase>(new CLOSE_PARENTHESIS_Token(char_index));
		case 13: return Reference<TokenBase>(new OPEN_BRACE_Token(char_index));
		case 14: return Reference<TokenBase>(new CLOSE_BRACE_Token(char_index));
		case 15: return Reference<TokenBase>(new OPEN_SQUARE_BRACKET_Token(char_index));
		case 16: return Reference<TokenBase>(new CLOSE_SQUARE_BRACKET_Token(char_index));
		case 17: return Reference<TokenBase>(new COLON_Token(char_index));
		case 18: return Reference<TokenBase>(new RIGHT_ARROW_Token(char_index));
		case 19: return Reference<TokenBase>(new EQUALS_Token(char_index));
		case 20: return Reference<TokenBase>(new PLUS_Token(char_index));
		case 21: return Reference<TokenBase>(new MINUS_Token(char_index));
		case 22: return Reference<TokenBase>(new FORWARDS_SLASH_Token(char_index));
		case 23: return Reference<TokenBase>(new BACK_SLASH_Token(char_index));
		case 24: return Reference<TokenBase>(new ASTERISK_Token(char_index));
		case 25: return Reference<TokenBase>(new LEFT_ANGLE_BRACKET_Token(char_index));
		case 26: return Reference<TokenBase>(new RIGHT_ANGLE_BRACKET_Token(char_index));
		case 27: return Reference<TokenBase>(new LESS_EQUAL_Token(char_index));
		case 28: return Reference<TokenBase>(new GREATER_EQUAL_Token(char_index));
		case 29: return Reference<TokenBase>(new DOUBLE_EQUALS_Token(char_index));
		case 30: return Reference<TokenBase>(new NOT_EQUALS_Token(char_index));
		case 31: return Reference<TokenBase>(new AND_Token(char_index));
		case 32: return Reference<TokenBase>(new OR_Token(char_index));
		case 33: return Reference<TokenBase>(new EXCLAMATION_MARK_Token(char_index));
		case 34: return Reference<TokenBase>(new DOT_Token(char_index));
		case 35: return Reference<TokenBase>(new QUESTION_MARK_Token(char_index));
		default: return  Reference<TokenBase>();
	}
}
